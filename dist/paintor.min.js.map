{"version":3,"sources":["webpack://paintor/webpack/bootstrap","webpack://paintor/webpack/runtime/define property getters","webpack://paintor/webpack/runtime/hasOwnProperty shorthand","webpack://paintor/./src/ElementsCollector.js","webpack://paintor/./src/functions.js","webpack://paintor/./src/htmlTags.js","webpack://paintor/./src/Paintor.js","webpack://paintor/./src/PaintorWrapper.js","webpack://paintor/./src/state.js","webpack://paintor/./src/index.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ElementsCollector","elements","addElement","element","this","push","getElements","importElements","elementsCollector","removeAllElements","removeTheseElements","length","newElements","indexOf","addChildrenToStack","inputChildren","childrenStack","child","addEventListenerIfPossible","eventName","callback","Node","eventNameLowerCase","toLowerCase","addEventListener","substr","appendChildrenToElement","children","input","Array","fragment","DocumentFragment","append","appendChild","setElementAttrOrProp","attrOrPropName","value","setAttribute","styleRuleModificator","name","output","Paintor","constructor","paintorWrapper","createElement","tagName","args","document","argumentID","argument","textContent","Function","propertyName","bindFunction","Error","properties","elcLevel","finalPaint","containerElement","forLoop","data","handler","start","end","loopType","levels","result","forLoopOne","forLoopTwo","if","condition","thisLevel","upperLevel","commentElementBegin","createComment","statementCallback","allow","console","error","commentElementEnd","beginElement","lastElement","body","contains","newElement","newNode","existingNode","parentNode","insertBefore","nextSibling","nodeType","COMMENT_NODE","beginElementText","endElementText","currentElement","statementsCounter","deletedElements","isBeginElement","text","remove","pop","property","styleRules","ruleName","ruleValue","finalValue","subPropertyName","style","fn","string","toString","pattern","list","matches","exec","base","path","includes","extractVariablesFromFunction","stateName","states","exploded","split","subscribe","bindArgs","boundArgs","targetFunction","for","PaintorWrapper","target","contents","paintor","treeFunction","getElementById","el","firstChild","removeChild","StateSubscriptions","subscriptions","proxy","object","getState","item","unsubscribe","subscriptionsGroup","subscriptionRemoved","i","filter","Boolean","statePath","set","Proxy","configurable","writable","innerStatePath","createState","state"],"mappings":"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","file":"paintor.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * This class has an array where HTML elements are stored. Its methods provide\n * an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type HTMLElement[] */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   * @param element\n   */\n  addElement(element) {\n    this.elements.push(element)\n  }\n\n  /**\n   * Returns the array of collected elements\n   * @returns {HTMLElement[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements)\n      this.addElement(element)\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements = []\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   * @param {HTMLElement[]} elements\n   */\n  removeTheseElements(elements) {\n    if (elements.length > 0) {\n      const newElements = []\n\n      for (const element of this.elements) {\n        if (elements.indexOf(element) === -1)\n          newElements.push(element)\n      }\n\n      this.elements = newElements\n    }\n  }\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport { ElementsCollector }\n","/**\n * @param {Array} inputChildren\n * @param {Array} childrenStack\n *\n * @returns {Array}\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren)\n    childrenStack.push(child)\n\n  return childrenStack\n}\n\n/**\n * @param {HTMLElement} element\n * @param {string} eventName\n * @param {function} callback\n *\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, eventName, callback) {\n  if (\n    !(element instanceof Node)\n\t\t|| typeof eventName !== 'string'\n\t\t|| typeof callback !== 'function'\n  ) return false\n\n  const eventNameLowerCase = eventName.toLowerCase()\n\n  if (eventNameLowerCase.indexOf('on') !== 0)\n    return false\n\n  element.addEventListener(eventNameLowerCase.substr(2), callback)\n\n  return true\n}\n\n/**\n * @param {HTMLElement} element\n * - The element in which to append the children\n *\n * @param {Array|HTMLElement} children\n * - The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, ...children) {\n  for (const input of children) {\n    if (input instanceof Array) {\n      if (input.length > 1) {\n        // For multiple elements it's faster to use document fragment\n        const fragment = new DocumentFragment()\n\n        for (const child of input) {\n          if (child)\n            fragment.append(child)\n        }\n\n        element.appendChild(fragment)\n      } else if (input.length === 1)\n        element.appendChild(input[0])\n    } else if (input instanceof Node)\n      element.append(input)\n  }\n}\n\n/**\n * Turns the input function to a string and extracts what looks like this: stateName.varName1\n * @param {*} fn\n */\nexport function extractVariablesFromFunction(fn) {\n  // TODO: Make it also detect bracket notation\n\n  const string = fn.toString()\n  const pattern = /(?:[^\\w_$.]|^)([a-zA-Z_$][\\w_$]*)\\.([\\w_$.]+)/g\n  const list = {}\n\n  let matches\n\n  while ((matches = pattern.exec(string)) !== null) {\n    const base = matches[1] // base in base.pa.th\n    const path = matches[2] // pa.th in base.pa.th\n\n    if (!(base in list))\n      list[base] = {}\n\n    if (!(path in list[base]))\n      list[base][path] = []\n\n    if (!list[base][path].includes(fn))\n      list[base][path].push(fn)\n  }\n\n  return list\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values and the \"handler\" function is looped\n * once for each pair. The loop breaks if \"false\" is returned by the \"handler\" function.\n *\n * @param {Object|Array} data\n * @param {Function} handler\n *\n * @returns {boolean|Error}\n */\nexport function forLoopOne(data, handler) {\n  if (!(data instanceof Object) && !(data instanceof Array))\n    return new Error('\"data\" argument should be an Object or an Array')\n\n  if (!(handler instanceof Function))\n    return new Error('\"handler\" argument should be a Function')\n\n  for (const key in data) {\n    const ret = handler(key, data[key])\n\n    if (ret === false) break\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {Function} handler\n *\n * @returns {boolean|Error}\n */\nexport function forLoopTwo(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number')\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n\n  if (!(handler instanceof Function))\n    return new Error('\"handler\" argument should be a Function')\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  } else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n *\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling)\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends of the name of the attribute or property.\n * @param {HTMLElement} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    // eslint-disable-next-line\n    element[attrOrPropName] = value\n  } else\n    element.setAttribute(attrOrPropName, value)\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function styleRuleModificator(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n","/**\n * For each of the following tags a method will be created in the class below\n * @type {string[]}\n */\nconst htmlTags = [\n  'a', 'abbr', 'address', 'applet', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'param', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n]\n\nexport default htmlTags\n","import { ElementsCollector } from './ElementsCollector.js'\nimport {\n  addChildrenToStack, addEventListenerIfPossible,\n  appendChildrenToElement, extractVariablesFromFunction,\n  forLoopOne,\n  forLoopTwo,\n  insertAfter, setElementAttrOrProp, styleRuleModificator,\n} from './functions.js'\nimport htmlTags from './htmlTags.js'\nimport './typedefs.js'\n\nclass Paintor {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the elements separately. Then,\n   * when the IF or FOR statement ends, the collected elements are moved to the upper level\n   * and that new level is deleted.\n   * @type ElementsCollector[]\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /** @type {PaintorWrapper} */\n  #paintorWrapper\n\n  /**\n   * @param {PaintorWrapper} paintorWrapper\n   */\n  constructor(paintorWrapper) {\n    this.#paintorWrapper = paintorWrapper\n  }\n\n  /**\n   * Create HTML element\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * Three variants are possible:<br>\n   * - String value - It will be textContent of the element. Use this in div tags and similar.\n   * - Object value - For all the properties of the element, like \"id\", \"class\" and so on...\n   * - HTMLElement (multiple arguments) - For other calls of this same function\n   * @returns {HTMLElement}\n   */\n  createElement(tagName, ...args) {\n    const element = document.createElement(tagName)\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string' || typeof argument === 'number') {\n        // In case of a string, it is the Text content of the node\n\n        element.textContent = argument\n      } else if (argument instanceof Function) {\n        const propertyName = 'propertyName'\n        const bindFunction = argument\n\n        this.#subscribeToBindings({ element, propertyName, bindFunction })\n\n        element[propertyName] = bindFunction(element)\n      } else if (argument instanceof Node) {\n        // If Node, this is a child (created by this function) to be appended to its parent\n\n        children.push(argument)\n      } else if (argument instanceof Array) {\n        // If Array, it contains children to be added to their parent\n\n        children = addChildrenToStack(argument, children)\n      } else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = argument\n      } else if (argument instanceof Object && argumentID === 1) {\n        // If Object and first argument, this is a property\n        // ! This condition needs to be at the end of the 'if' chain\n\n        this.#setPropertiesToElement({\n          element,\n          properties: argument,\n        })\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    if (children.length >= 0) {\n      const elcLevel = this.#collectedElements.length - 1\n\n      this.#collectedElements[elcLevel].removeTheseElements(children)\n      this.#collectedElements[elcLevel].addElement(element)\n    }\n\n    return element\n  }\n\n  /**\n   * At the end paint the DOM elements at level 0\n   */\n  finalPaint() {\n    appendChildrenToElement(\n      this.#paintorWrapper.containerElement,\n      this.#collectedElements[0].getElements(),\n    )\n\n    // Reset\n    this.#collectedElements = [new ElementsCollector()]\n  }\n\n  /**\n   * \"FOR\" loop\n   * @returns {Error|HTMLElement[]}\n   */\n  forLoop(...args) {\n    // 1) Parse arguments\n    if (args.length < 2 || args.length > 3)\n      return new Error(`Wrong number of arguments. Expected 2 or 3, got ${args.length}`)\n\n    let data\n    let handler\n    let start = 0\n    let end = 0\n\n    // 1 when the input is Object/Array,\n    // 2 when the input is a number,\n    // 3 if two numbers\n    let loopType = 0\n\n    if (args.length === 2) {\n      [data, handler] = args\n\n      if (typeof args[0] !== 'number')\n        loopType = 1\n      else {\n        loopType = 2\n\n        if (args[0] >= 0) {\n          start = 0\n          end = args[0] - 1\n        } else {\n          start = -args[0] - 1\n          end = 0\n        }\n      }\n    } else if (args.length === 3) {\n      [start, end, handler] = args\n      loopType = 3\n    }\n\n    // 2) Run For\n    const levels = this.#beforeStatement()\n\n    let result = null\n\n    if (loopType === 1)\n      result = forLoopOne(data, handler)\n\n    else if (loopType === 2 || loopType === 3)\n      result = forLoopTwo(start, end, handler)\n\n    const elements = this.#afterStatement(levels)\n\n    if (result instanceof Error)\n      return result\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   * @param {boolean|StatementBindFunction} condition\n   * @param {function():void} handler\n   * @returns {HTMLElement[]}\n   */\n  if(condition, handler) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    if (typeof condition === 'function') {\n      const bindFunction = condition\n      const commentElementBegin = document.createComment('IF BEGIN')\n      this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n      /** @type {StatementCallback} */\n      const statementCallback = (allow) => {\n        this.#collectedElements[0].removeAllElements()\n        this.#removeStatementElements(commentElementBegin)\n\n        if (allow) handler()\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[0].getElements(),\n        )\n\n        if (!success)\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n      }\n\n      this.#subscribeToBindings({\n        element: commentElementBegin,\n        propertyName: '--if',\n        bindFunction,\n        statementCallback,\n      })\n    }\n\n    const allow = (condition instanceof Function) ? condition() : condition\n\n    // Run the handler function\n    if (allow && (typeof handler === 'function'))\n      handler()\n\n    if (typeof condition === 'function') {\n      const commentElementEnd = document.createComment('IF END')\n\n      this.#collectedElements[thisLevel].addElement(commentElementEnd)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {Comment} beginElement\n   * @param {HTMLElement[]} elements\n   * @returns {boolean}\n   * - Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginElement, elements) {\n    let lastElement = beginElement\n\n    if (document.body.contains(lastElement) === false)\n      return false\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   * @param {Comment} beginElement\n   * @returns {number} - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginElement) {\n    if (beginElement.nodeType !== Node.COMMENT_NODE)\n      return -1\n\n    // Decide what will be the text content of the end element\n    const beginElementText = beginElement.textContent\n    let endElementText = ''\n\n    if (beginElementText === 'IF BEGIN')\n      endElementText = 'IF END'\n    else if (beginElementText === 'FOR BEGIN')\n      endElementText = 'FOR END'\n    else\n      return -1\n\n    // Delete elements until the 'end' element is found\n    let currentElement = beginElement.nextSibling\n    let statementsCounter = 0\n    let deletedElements = 0\n\n    while (true) {\n      if (currentElement === null)\n        break\n\n      let isBeginElement = false\n\n      if (currentElement.nodeType === Node.COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginElementText) {\n          statementsCounter += 1\n          isBeginElement = true\n        } else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0)\n            break\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      // Mark any BEGIN element from inner statements for further deletion\n      if (isBeginElement) currentElement['--deleted'] = true\n\n      currentElement.remove()\n      deletedElements += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElements\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop before calling the handler\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    const thisLevel = this.#collectedElements.length\n    const upperLevel = thisLevel - 1\n\n    this.#collectedElements.push(new ElementsCollector())\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler\n   * @param {number} thisLevel\n   * @param {number} upperLevel\n   * @returns {HTMLElement[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n    this.#collectedElements[thisLevel].removeAllElements()\n\n    // ... and clean this level\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<string, string|number|{}|Function>} properties\n   */\n  #setPropertiesToElement({ element, properties }) {\n    for (const propertyName in properties) {\n      const property = properties[propertyName]\n\n      if (addEventListenerIfPossible(element, propertyName, property))\n        continue\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        const bindFunction = property\n\n        this.#subscribeToBindings({ element, propertyName, bindFunction })\n\n        const value = bindFunction(element)\n\n        setElementAttrOrProp(element, propertyName, value)\n      } else if (propertyName === 'style' && property instanceof Object) {\n        const styleRules = property\n\n        for (const ruleName in styleRules) {\n          const ruleValue = styleRules[ruleName]\n          let finalValue = ''\n\n          if (ruleValue instanceof Function) {\n            const bindFunction = ruleValue\n\n            this.#subscribeToBindings({\n              element,\n              propertyName,\n              subPropertyName: ruleName,\n              bindFunction,\n            })\n\n            finalValue = bindFunction(element)\n          } else\n            finalValue = ruleValue\n\n          // eslint-disable-next-line no-param-reassign\n          element.style[ruleName] = styleRuleModificator(ruleName, finalValue)\n        }\n      } else\n        setElementAttrOrProp(element, propertyName, property)\n    }\n  }\n\n  /**\n   * @param {HTMLElement|Comment} element\n   * @param {string} propertyName\n   * @param {string} [subPropertyName]\n   * @param {BindFunction|StatementBindFunction} [bindFunction]\n   * @param {StatementCallback} [statementCallback]\n   */\n  #subscribeToBindings({\n    element,\n    propertyName,\n    subPropertyName = '',\n    bindFunction,\n    statementCallback,\n  }) {\n    const result = extractVariablesFromFunction(bindFunction)\n\n    for (const stateName in result) {\n      if (!(stateName in this.#paintorWrapper.states)) {\n        // console.error(`State \"${stateName}\" is not defined`)\n        continue\n      }\n\n      for (const path in result[stateName]) {\n        const exploded = path.split('.')\n\n        let obj = this.#paintorWrapper.states[stateName]\n\n        for (let key = 0; key < exploded.length - 1; key++) {\n          const value = exploded[key]\n          obj = obj[value]\n        }\n\n        const stateSubscriptions = this.#paintorWrapper.states[stateName]['--subscribe']\n\n        stateSubscriptions.subscribe(\n          path,\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementCallback,\n        )\n      }\n    }\n  }\n}\n\n/**\n * https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n *\n * @param boundArgs\n * @returns {function(...[*]) : *}\n */\nFunction.prototype.bindArgs = function bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\nfor (const tagName of htmlTags)\n  Paintor.prototype[tagName] = Paintor.prototype.createElement.bindArgs(tagName)\n\n// \"for\" is placed below, otherwise if it is in the class, the typings for its multiple\n// overloads doesn't work correctly.\n// Must have an empty row below this comment section, otherwise it is considered a description\n\nPaintor.prototype.for = Paintor.prototype.forLoop\n\nexport { Paintor }\n","import { Paintor } from './Paintor.js'\nimport './typedefs.js'\n\n/**\n * This class complements the Paintor class and exists mostly because of treeFunction(), its\n * parameter specifically. If both classes are merged into one, then this parameter cannot be\n * typed correctly.\n */\nclass PaintorWrapper {\n  /**\n   * The main element in which to append all the contents\n   * @type {HTMLElement | null}\n   */\n  #containerElement = null\n\n  // A state is an Object where the key is the name of the state and the value is a Proxy object\n  /** @type {Object<string, {}>} */\n  #states = {}\n\n  /**\n   * @param {string|HTMLElement} target\n   * @param {{}} states\n   * @param {*} contents\n   * @returns {PaintorWrapper}\n   */\n  constructor(target, states, contents) {\n    const paintor = new Paintor(this)\n    const result = this.#initConstructorArguments(target, states, contents)\n\n    if (!(result instanceof Error)) {\n      this.#clearContainerElement()\n      contents(paintor)\n      paintor.finalPaint()\n    }\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get containerElement() {\n    return this.#containerElement\n  }\n\n  /**\n   * @returns {Object<string, {}>}\n   */\n  get states() {\n    return this.#states\n  }\n\n  /**\n   * @param {string|HTMLElement} target\n   * @param {State|States} states\n   * @param {Contents} treeFunction\n   * @returns {Error|boolean}\n   */\n  #initConstructorArguments(target, states, treeFunction) {\n    // argument 1\n    if (target instanceof Node)\n      this.#containerElement = target\n    else if (typeof target === 'string') {\n      this.#containerElement = document.getElementById(target)\n\n      if (!this.#containerElement)\n        return new Error(`Could not locate element #${target}`)\n    } else {\n      return new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof target}>`,\n      )\n    }\n\n    // argument 2\n    if (!(states instanceof Object))\n      return new Error('states must be an Object')\n\n    for (const stateName in states) {\n      if ('--state-path' in states[stateName])\n        this.states[stateName] = states[stateName]\n      else {\n        // Give an error when the object is not a state object\n        console.error(\n          `The input \"${stateName}\" is \"${typeof states[stateName]}\", `\n          + 'but it should be a state',\n        )\n      }\n    }\n\n    // argument 3\n    if (typeof treeFunction !== 'function')\n      return new Error('treeFunction must be a function')\n\n    return true\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElement() {\n    const el = this.#containerElement\n\n    while (el.firstChild)\n      el.removeChild(el.firstChild)\n  }\n}\n\nexport { PaintorWrapper }\n","import { setElementAttrOrProp, styleRuleModificator } from './functions.js'\nimport './typedefs.js'\n\nclass StateSubscriptions {\n  subscriptions = {}\n\n  /** @type {ProxyHandler} */\n  proxy\n\n  /**\n   * @template T\n   * @param {T} object - A generic parameter that flows through to the return type\n   * @return {T}\n   */\n  constructor(object) {\n    this.proxy = this.#createProxy(object)\n  }\n\n  /**\n   * @returns {ProxyHandler}\n   */\n  getState() {\n    return this.proxy\n  }\n\n  /**\n   * A function that binds the property of a html element with element from a state\n   * @param {string} path\n   * @param {HTMLElement} element\n   * @param {string} propertyName\n   * @param {string} subPropertyName\n   * @param {BindFunction} bindFunction\n   * @param {function} [statementCallback]\n   */\n  subscribe(path, element, propertyName, subPropertyName, bindFunction, statementCallback) {\n    this.subscriptions[path] = this.subscriptions[path] || []\n\n    // Search for the same subscription. If it already exists, don't make new one\n    for (const item of this.subscriptions[path]) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementCallback === statementCallback\n      ) return\n    }\n\n    this.subscriptions[path].push({\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementCallback,\n    })\n  }\n\n  /**\n   * A function that removes binds from html element\n   * @param {HTMLElement} element\n   */\n  unsubscribe(element) {\n    for (const key in this.subscriptions) {\n      const subscriptionsGroup = this.subscriptions[key]\n      let subscriptionRemoved = false\n\n      for (let i = 0; i < subscriptionsGroup.length; i++) {\n        const item = subscriptionsGroup[i]\n\n        // if the element is marked for deletion, delete the subscription as well\n        if (item.element === element) {\n          delete subscriptionsGroup[i]\n          subscriptionRemoved = true\n        }\n      }\n\n      // If a subscription has been removed from the array,\n      // remove the remaining empty element of the array\n      if (subscriptionRemoved)\n        this.subscriptions[key] = this.subscriptions[key].filter(Boolean)\n    }\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * @param {string} [statePath]\n   * @return {T}\n   */\n  #createProxy(object, statePath = '') {\n    /** @type {ProxyHandler} */\n    const handler = {}\n\n    handler.get = (target, prop) => {\n      if (prop === '--subscribe')\n        return this\n\n      return target[prop]\n    }\n\n    handler.set = (target, prop, value) => {\n      if (prop === '--subscribe')\n        return true\n\n      // eslint-disable-next-line no-param-reassign\n      target[prop] = value\n\n      let path = target['--state-path']\n\n      path = path ? `${path}.${prop}` : prop\n\n      if (path in this.subscriptions) {\n        const list = this.subscriptions[path] || []\n\n        for (const i in list) {\n          const {\n            element,\n            propertyName,\n            subPropertyName,\n            bindFunction,\n            statementCallback,\n          } = list[i]\n\n          if (element['--deleted'])\n            this.unsubscribe(element)\n          else {\n            const result = bindFunction(element)\n\n            if (propertyName === 'style' && subPropertyName)\n              element.style[subPropertyName] = styleRuleModificator(subPropertyName, result)\n            else if (propertyName === '--if')\n              statementCallback(result)\n            else\n              setElementAttrOrProp(element, propertyName, result)\n          }\n        }\n      }\n\n      return true\n    }\n\n    const proxy = new Proxy(object, handler)\n\n    Object.defineProperty(proxy, '--state-path', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: statePath,\n    })\n\n    // Recursive proxy\n    for (const key in proxy) {\n      if (proxy[key] instanceof Object) {\n        const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n        proxy[key] = this.#createProxy(proxy[key], innerStatePath)\n      }\n    }\n\n    return proxy\n  }\n}\n\n/**\n * @template T\n * @param {T} object - A generic parameter that flows through to the return type\n * @return {T}\n */\nfunction createState(object) {\n  const stateSubscriptions = new StateSubscriptions(object)\n\n  return stateSubscriptions.getState()\n}\n\nexport { createState }\n","import { PaintorWrapper } from './PaintorWrapper.js'\nimport { createState } from './state.js'\nimport './typedefs.js'\n\n/** @type {Paintor} */\nconst paintor = function paintor(target, states, contents) {\n  return new PaintorWrapper(target, states, contents)\n}\n\npaintor.state = createState\npaintor.createState = createState\n\nexport default paintor\nexport { paintor, createState }\n"],"sourceRoot":""}