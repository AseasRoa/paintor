{"version":3,"sources":["webpack://paintor/webpack/bootstrap","webpack://paintor/webpack/runtime/define property getters","webpack://paintor/webpack/runtime/hasOwnProperty shorthand","webpack://paintor/./src/ElementsCollector.js","webpack://paintor/./src/VirtualDOM/Constants.js","webpack://paintor/./src/VirtualDOM/VirtualElement.js","webpack://paintor/./src/VirtualDOM/VirtualDocument.js","webpack://paintor/./src/functions.js","webpack://paintor/./src/htmlTags.js","webpack://paintor/./src/Paintor.js","webpack://paintor/./src/PaintorWrapper.js","webpack://paintor/./src/StateSubscriptions.js","webpack://paintor/./src/index.js"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ElementsCollector","elements","addElement","element","this","push","getElements","importElements","elementsCollector","removeAllElements","removeTheseElements","length","newElements","indexOf","BOOLEAN_ATTRIBUTES","SELF_CLOSING_TAGS","formatStringFromCamelCase","str","output","replace","all","char","toLowerCase","VirtualElement","nextSibling","previousSibling","constructor","parentElement","tagName","isComment","className","attribute","name","value","setAttribute","text","textContent","toUpperCase","html","charsToReplace","tag","escapeHTML","toString","input","style","split","forEach","el","property","formattedProperty","splitted","slice","map","word","join","formatStringToCamelCase","trim","getStyleObjectFromString","append","childElement","appendChild","child","nodeType","Error","prevKey","paint","tabsCount","isChild","tabs","newRow","i","generateTabs","selfClosingTag","includes","attributes","Array","undefined","generateAttributesString","keys","getStyleStringFromObject","children","paintChildren","childNumber","remove","attributeName","attributeValue","index","findIndex","VirtualDocument","createComment","createElement","prettyPrint","body","addChildrenToStack","inputChildren","childrenStack","isEventAttribute","addEventListenerIfPossible","callback","Node","addEventListener","substr","appendChildrenToElement","appendVirtualChildrenToElement","fragment","DocumentFragment","appendDOMChildrenToElement","setElementAttrOrProp","attrOrPropName","styleRuleModificator","Paintor","paintorWrapper","global","args","isVirtualGlobal","argumentID","argument","Function","propertyName","bindFunction","elcLevel","finalPaint","finalHtmlCode","containerElement","forLoop","data","handler","start","end","loopType","levels","result","forLoopOne","forLoopTwo","if","condition","thisLevel","upperLevel","commentElementBegin","statementCallback","allow","console","error","commentElementEnd","beginElement","lastElement","contains","newElement","newNode","existingNode","parentNode","insertBefore","beginElementText","endElementText","currentElement","statementsCounter","deletedElements","isBeginElement","pop","properties","styleRules","ruleName","ruleValue","finalValue","subPropertyName","fn","string","pattern","list","matches","exec","base","path","extractVariablesFromFunction","stateName","states","exploded","subscribe","bindArgs","boundArgs","targetFunction","for","PaintorWrapper","target","contents","theGlobal","paintor","getHtmlCode","treeFunction","valid","document","getElementById","state","firstChild","removeChild","StateSubscriptions","subscriptions","proxy","object","getState","item","unsubscribe","subscriptionsGroup","subscriptionRemoved","filter","Boolean","statePath","set","Proxy","configurable","writable","innerStatePath","isBrowser","mode","desiredMode","theGlobalScope","createState"],"mappings":"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","file":"paintor.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * This class has an array where HTML elements are stored. Its methods provide\n * an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type HTMLElement[] */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   * @param element\n   */\n  addElement(element) {\n    this.elements.push(element)\n  }\n\n  /**\n   * Returns the array of collected elements\n   * @returns {HTMLElement[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements)\n      this.addElement(element)\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements = []\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   * @param {HTMLElement[]} elements\n   */\n  removeTheseElements(elements) {\n    if (elements.length > 0) {\n      const newElements = []\n\n      for (const element of this.elements) {\n        if (elements.indexOf(element) === -1)\n          newElements.push(element)\n      }\n\n      this.elements = newElements\n    }\n  }\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport { ElementsCollector }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @type {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = [\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n]\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from each other, such as elements, text and comments.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const NODE_TYPES = {\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n}\n\n/**\n * List of HTML tags\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @type {string[]}\n */\nexport const SELF_CLOSING_TAGS = [\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n]\n","import { BOOLEAN_ATTRIBUTES, NODE_TYPES, SELF_CLOSING_TAGS } from './Constants.js'\nimport './typedefs.js'\n\n/**\n * @param {number} tabsCount\n * @return {string}\n */\nfunction generateTabs(tabsCount) {\n  let output = ''\n\n  for (let i = 0; i < tabsCount; i++)\n\n    output += '\\t'\n\n  return output\n}\n\n/**\n * @param {string} html\n * @return {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  // Replace characters\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace)\n\n      output = charsToReplace[tag]\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {VirtualElementAttributeItem[]} attributes\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      )\n        output += ` ${name}`\n    } else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else value = value.toString()\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n * @param {string} str\n * @return {string}\n */\nfunction formatStringToCamelCase(str) {\n  const splitted = str.split('-')\n\n  if (splitted.length === 1) return splitted[0]\n\n  return (\n    splitted[0]\n    + splitted\n        .slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @return {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * @param {string} str\n * @return {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @return {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass VirtualElement {\n  /** @type {VirtualElement | null} */\n  nextSibling = null\n\n  /** @type {VirtualElement | null} */\n  previousSibling = null\n\n  /** @type {VirtualElementAttributeItem[]} */\n  #attributes = []\n\n  /** @type {VirtualElement[]} */\n  #children = []\n\n  /** @type {VirtualElement | null} */\n  #parentElement = null\n\n  /** @type {string} */\n  #tagName = ''\n\n  /** @type {string} */\n  #textContent = ''\n\n  /**\n   * An integer which specifies the type of the node.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n   * @type {NODE_TYPES}\n   */\n  #nodeType = NODE_TYPES.ELEMENT_NODE\n\n  // Flags the current element as removed or not\n  #removed = false\n\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {VirtualElement | null} parentElement\n   * @param {string} tagName\n   * @param {boolean} [isComment]\n   */\n  constructor(parentElement, tagName, isComment = false) {\n    this.#parentElement = parentElement\n    this.#tagName = tagName.toLowerCase()\n    this.#nodeType = (isComment) ? NODE_TYPES.COMMENT_NODE : NODE_TYPES.ELEMENT_NODE\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @return {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @return {string}\n   */\n  get innerHTML() {\n    return this.#textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.#textContent = text\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @return {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @return {string}\n   */\n  get nodeName() {\n    return this.#tagName.toUpperCase()\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodetype.asp\n   * @return {NODE_TYPES}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentelement.asp\n   * @return {VirtualElement | null}\n   */\n  get parentElement() {\n    return this.#parentElement\n  }\n\n  /**\n   * @param {VirtualElement | null} parentElement\n   */\n  set parentElement(parentElement) {\n    this.#parentElement = parentElement\n  }\n\n  /**\n   * @return {string}\n   */\n  get tagName() {\n    return this.#tagName.toUpperCase()\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_textcontent.asp\n   * @return {string}\n   */\n  get textContent() {\n    return this.#textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set textContent(text) {\n    this.#textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @return {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | {}} input\n   * @return {StylesObject}\n   */\n  set style(input) {\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style)\n        this.#style[key] = style[key].toString()\n    }\n\n    return this.#style\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   * @param {VirtualElement | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof VirtualElement)\n      this.appendChild(childElement)\n    else\n      this.textContent = childElement\n  }\n\n  /**\n   * Similar to the .append method, this method is used to elements\n   * in the DOM, but in this case, only accepts a Node object.\n   * @param {VirtualElement} childElement\n   */\n  appendChild(childElement) {\n    const child = childElement\n\n    if (this.nodeType === NODE_TYPES.COMMENT_NODE)\n      throw new Error('This node type does not support this method.')\n\n    if (!(child instanceof VirtualElement)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Element\\''\n        + ': parameter 1 is not of type \\'Element\\'.'\n\n      throw new Error(errorMessage)\n    }\n\n    child.parentElement = this\n    this.#children.push(child)\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#children.length - 2\n\n    if (prevKey >= 0) {\n      this.#children[prevKey].nextSibling = child\n      child.previousSibling = this.#children[prevKey]\n    }\n  }\n\n  /**\n   * @param {number} [tabsCount] - Value of -1 means that no tabs or empty space is painted\n   * @param {boolean} isChild - If true, a new row is put in the beginning\n   * @return {string}\n   */\n  paint(tabsCount = 0, isChild = false) {\n    if (this.#removed)\n      return ''\n\n    let output = ''\n    let tabs = ''\n    let newRow = ''\n\n    if (tabsCount > -1) {\n      tabs = generateTabs(tabsCount)\n      newRow = '\\n'\n    }\n\n    if (this.nodeType === NODE_TYPES.COMMENT_NODE)\n      output += `${newRow}${tabs}<!--${this.textContent}-->`\n\n    else {\n      const selfClosingTag = (SELF_CLOSING_TAGS.includes(this.#tagName))\n      const attributes = generateAttributesString(this.#attributes)\n\n      let style = ''\n\n      if (Object.keys(this.style).length > 0)\n        style = ` style=\"${getStyleStringFromObject(this.style)}\"`\n\n      // Paint the opening tag (including attributes)\n      if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n      output += `${tabs}<${this.#tagName}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n\n      // Paint the text in the element\n      output += this.#textContent\n\n      // Paint the children\n      let children = ''\n\n      for (const child of this.#children)\n        children += child.paint((tabsCount === -1) ? -1 : tabsCount + 1, true)\n\n      if (children)\n        output += children + newRow + tabs\n\n      // Paint the closing tag\n      output += (selfClosingTag) ? '/>' : `</${this.#tagName}>`\n    }\n\n    return output\n  }\n\n  /**\n   * @return {string}\n   */\n  paintChildren() {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.#children) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += child.paint(0, isChild)\n    }\n\n    return children\n  }\n\n  remove() {\n    this.#removed = true\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name)\n      return\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1)\n      this.#attributes.push({ name, value })\n    else\n      this.#attributes[index] = { name, value }\n  }\n}\n\nexport { VirtualElement }\n","import './typedefs.js'\nimport { VirtualElement } from './VirtualElement.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass VirtualDocument {\n  /** @type {VirtualElement} */\n  #container\n\n  constructor() {\n    this.#container = new VirtualElement(null, 'body')\n  }\n\n  /** @type {VirtualElement} */\n  get body() {\n    return this.#container\n  }\n\n  /**\n   * @return {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @param {string} text\n   * @return {VirtualElement}\n   */\n  createComment(text = '') {\n    const element = new VirtualElement(null, '', true)\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   */\n  createElement(tagName) {\n    return new VirtualElement(null, tagName, false)\n  }\n\n  /**\n   * @param {boolean} [prettyPrint]\n   * @return {string}\n   */\n  paint(prettyPrint = true) {\n    const tabsCount = (prettyPrint) ? 0 : -1\n\n    return this.body.paint(tabsCount)\n  }\n}\n\nexport { VirtualDocument, VirtualElement }\n","import { VirtualDocument, VirtualElement } from './VirtualDOM/VirtualDocument.js'\nimport './typedefs.js'\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @return {boolean}\n */\nexport function isBrowserEnvironment() {\n  // eslint-disable-next-line @typescript-eslint/no-implied-eval\n  const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n  return isBrowser()\n}\n\n/**\n * Get the global scope, depending on what is desired and what is possible\n * @param {boolean} isBrowser\n * @param {EnvironmentMode | string} [desiredMode]\n * @return {TheGlobal}\n */\nexport function theGlobalScope(isBrowser, desiredMode = '') {\n  return (!isBrowser || desiredMode === 'server') ? new VirtualDocument() : document\n}\n\n/**\n * @param {Array} inputChildren\n * @param {Array} childrenStack\n *\n * @returns {Array}\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren)\n    childrenStack.push(child)\n\n  return childrenStack\n}\n\n/**\n * @param {string} attributeName\n * @return {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {HTMLElement} element\n * @param {string} attributeName\n * @param {function} callback\n *\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  element.addEventListener(attributeName.toLowerCase().substr(2), callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n * @param {HTMLElement} element\n * @param {HTMLElement[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  } else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child)\n        fragment.append(child)\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {VirtualElement} element\n * @param {VirtualElement[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child)\n      element.appendChild(child)\n  }\n}\n\n/**\n * @param {TheElement} element\n * - The element in which to append the children\n *\n * @param {TheElement[]} children\n * - The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (element instanceof VirtualElement)\n    appendVirtualChildrenToElement(element, children)\n  else\n    appendDOMChildrenToElement(element, children)\n}\n\n/**\n * Turns the input function to a string and extracts what looks like this: stateName.varName1\n * @param {*} fn\n */\nexport function extractVariablesFromFunction(fn) {\n  // TODO: Make it also detect bracket notation\n\n  const string = fn.toString()\n  const pattern = /(?:[^\\w_$.]|^)([a-zA-Z_$][\\w_$]*)\\.([\\w_$.]+)/g\n  const list = {}\n\n  let matches\n\n  while ((matches = pattern.exec(string)) !== null) {\n    const base = matches[1] // base in base.pa.th\n    const path = matches[2] // pa.th in base.pa.th\n\n    if (!(base in list))\n      list[base] = {}\n\n    if (!(path in list[base]))\n      list[base][path] = []\n\n    if (!list[base][path].includes(fn))\n      list[base][path].push(fn)\n  }\n\n  return list\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values and the \"handler\" function is looped\n * once for each pair. The loop breaks if \"false\" is returned by the \"handler\" function.\n *\n * @param {Object | Array} data\n * @param {Function} handler\n *\n * @returns {boolean | Error}\n */\nexport function forLoopOne(data, handler) {\n  if (!(data instanceof Object) && !(data instanceof Array))\n    return new Error('\"data\" argument should be an Object or an Array')\n\n  if (!(handler instanceof Function))\n    return new Error('\"handler\" argument should be a Function')\n\n  for (const key in data) {\n    const ret = handler(key, data[key])\n\n    if (ret === false) break\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {Function} handler\n *\n * @returns {boolean | Error}\n */\nexport function forLoopTwo(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number')\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n\n  if (!(handler instanceof Function))\n    return new Error('\"handler\" argument should be a Function')\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  } else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n *\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  existingNode.parentNode.insertBefore(newNode, existingNode.nextSibling)\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends of the name of the attribute or property.\n * @param {HTMLElement} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    // eslint-disable-next-line\n    element[attrOrPropName] = value\n  } else\n    element.setAttribute(attrOrPropName, value)\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function styleRuleModificator(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n","/**\n * For each of the following tags a method will be created in the class below\n * @type {string[]}\n */\nconst htmlTags = [\n  'a', 'abbr', 'address', 'applet', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'param', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n]\n\nexport default htmlTags\n","import { ElementsCollector } from './ElementsCollector.js'\nimport { VirtualDocument, VirtualElement } from './VirtualDOM/VirtualDocument.js'\nimport {\n  addChildrenToStack, addEventListenerIfPossible,\n  appendChildrenToElement, extractVariablesFromFunction,\n  forLoopOne,\n  forLoopTwo,\n  insertAfter, isEventAttribute, setElementAttrOrProp, styleRuleModificator,\n} from './functions.js'\nimport htmlTags from './htmlTags.js'\nimport './typedefs.js'\n\nclass Paintor {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the elements separately. Then,\n   * when the IF or FOR statement ends, the collected elements are moved to the upper level\n   * and that new level is deleted.\n   * @type ElementsCollector[]\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /** @type {PaintorWrapper} */\n  #paintorWrapper\n\n  /** @type {TheGlobal} */\n  #global\n\n  /**\n   * @param {PaintorWrapper} paintorWrapper\n   */\n  constructor(paintorWrapper) {\n    this.#paintorWrapper = paintorWrapper\n    this.#global = this.#paintorWrapper.global\n  }\n\n  /**\n   * Create HTML element\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * Different variants are possible:<br>\n   * - String value - It will be textContent of the element. Use this in div tags and similar.\n   * - Object value - For all the properties of the element, like \"id\", \"class\" and so on...\n   * - Element (multiple arguments) - For other calls of this same function (creating children)\n   * - Array - Alternative for creating children\n   * @returns {TheElement}\n   */\n  createElement(tagName, ...args) {\n    const element = this.#global.createElement(tagName)\n    const isVirtualGlobal = this.#global instanceof VirtualDocument\n\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string' || typeof argument === 'number') {\n        // In case of a string, it is the Text content of the node\n\n        element.textContent = argument\n      } else if (argument instanceof Function) {\n        // TODO: I don't remember why I made this functionality and what it does\n        const propertyName = 'propertyName'\n        const bindFunction = argument\n\n        this.#subscribeToBindings({ element, propertyName, bindFunction })\n\n        element[propertyName] = bindFunction(element)\n      } else if (\n        (isVirtualGlobal && argument instanceof VirtualElement)\n        || (!isVirtualGlobal && argument instanceof Node)\n      ) {\n        // If Node, this is a child (created by this function) to be appended to its parent\n\n        children.push(argument)\n      } else if (argument instanceof Array) {\n        // If Array, it contains children to be added to their parent\n\n        children = addChildrenToStack(argument, children)\n      } else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = argument\n      } else if (argument instanceof Object && argumentID === 1) {\n        // If Object and first argument, this is a property\n        // ! This condition needs to be at the end of the 'if' chain\n\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    if (children.length >= 0) {\n      const elcLevel = this.#collectedElements.length - 1\n\n      this.#collectedElements[elcLevel].removeTheseElements(children)\n      this.#collectedElements[elcLevel].addElement(element)\n    }\n\n    return element\n  }\n\n  /**\n   * Browser mode: Append the DOM elements at level 0 to the container element\n   * <br>\n   * Server mode: Generate HTML code of the elements at level 0\n   *\n   * @return {string}\n   * Browser mode: Empty string\n   * <br>\n   * Server mode: The final HTML code\n   */\n  finalPaint() {\n    let finalHtmlCode = ''\n\n    const children = this.#collectedElements[0].getElements()\n    const containerElement = this.#paintorWrapper.containerElement\n\n    appendChildrenToElement(containerElement, children)\n\n    if (this.#global instanceof VirtualDocument)\n      finalHtmlCode = containerElement.paintChildren()\n\n    // Reset\n    this.#collectedElements = [new ElementsCollector()]\n\n    return finalHtmlCode\n  }\n\n  /**\n   * \"FOR\" loop\n   * @returns {Error | TheElement[]}\n   */\n  forLoop(...args) {\n    // 1) Parse arguments\n    if (args.length < 2 || args.length > 3)\n      return new Error(`Wrong number of arguments. Expected 2 or 3, got ${args.length}`)\n\n    let data\n    let handler\n    let start = 0\n    let end = 0\n\n    // 1 when the input is Object/Array,\n    // 2 when the input is a number,\n    // 3 if two numbers\n    let loopType = 0\n\n    if (args.length === 2) {\n      [data, handler] = args\n\n      if (typeof args[0] !== 'number')\n        loopType = 1\n      else {\n        loopType = 2\n\n        if (args[0] >= 0) {\n          start = 0\n          end = args[0] - 1\n        } else {\n          start = -args[0] - 1\n          end = 0\n        }\n      }\n    } else if (args.length === 3) {\n      [start, end, handler] = args\n      loopType = 3\n    }\n\n    // 2) Run For\n    const levels = this.#beforeStatement()\n\n    let result = null\n\n    if (loopType === 1)\n      result = forLoopOne(data, handler)\n\n    else if (loopType === 2 || loopType === 3)\n      result = forLoopTwo(start, end, handler)\n\n    const elements = this.#afterStatement(levels)\n\n    if (result instanceof Error)\n      return result\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   * @param {boolean | StatementBindFunction} condition\n   * @param {function():void} handler\n   * @returns {TheElement[]}\n   */\n  if(condition, handler) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    if (typeof condition === 'function') {\n      const bindFunction = condition\n      const commentElementBegin = this.#global.createComment('IF BEGIN')\n\n      this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n      /** @type {StatementCallback} */\n      const statementCallback = (allow) => {\n        this.#collectedElements[0].removeAllElements()\n        this.#removeStatementElements(commentElementBegin)\n\n        if (allow) handler()\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[0].getElements(),\n        )\n\n        if (!success)\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n      }\n\n      this.#subscribeToBindings({\n        element: commentElementBegin,\n        propertyName: '--if',\n        bindFunction,\n        statementCallback,\n      })\n    }\n\n    const allow = (condition instanceof Function) ? condition() : condition\n\n    // Run the handler function\n    if (allow && (typeof handler === 'function'))\n      handler()\n\n    if (typeof condition === 'function') {\n      const commentElementEnd = this.#global.createComment('IF END')\n\n      this.#collectedElements[thisLevel].addElement(commentElementEnd)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {Comment | VirtualElement} beginElement\n   * @param {HTMLElement[]} elements\n   * @returns {boolean}\n   * - Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginElement, elements) {\n    let lastElement = beginElement\n\n    if (this.#global.body.contains(lastElement) === false)\n      return false\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   * @param {TheElement} beginElement\n   * @returns {number} - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginElement) {\n    /**\n     * @type {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n     */\n    const COMMENT_NODE = 8 // Node.COMMENT_NODE\n\n    if (beginElement.nodeType !== COMMENT_NODE)\n      return -1\n\n    // Decide what will be the text content of the end element\n    const beginElementText = beginElement.textContent\n    let endElementText = ''\n\n    if (beginElementText === 'IF BEGIN')\n      endElementText = 'IF END'\n    else if (beginElementText === 'FOR BEGIN')\n      endElementText = 'FOR END'\n    else\n      return -1\n\n    // Delete elements until the 'end' element is found\n    let currentElement = beginElement.nextSibling\n    let statementsCounter = 0\n    let deletedElements = 0\n\n    while (true) {\n      if (currentElement === null)\n        break\n\n      let isBeginElement = false\n\n      if (currentElement.nodeType === COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginElementText) {\n          statementsCounter += 1\n          isBeginElement = true\n        } else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0)\n            break\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      // Mark any BEGIN element from inner statements for further deletion\n      if (isBeginElement) currentElement['--deleted'] = true\n\n      currentElement.remove()\n      deletedElements += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElements\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop before calling the handler\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    const thisLevel = this.#collectedElements.length\n    const upperLevel = thisLevel - 1\n\n    this.#collectedElements.push(new ElementsCollector())\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler\n   * @param {number} thisLevel\n   * @param {number} upperLevel\n   * @returns {HTMLElement[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n    this.#collectedElements[thisLevel].removeAllElements()\n\n    // ... and clean this level\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  /**\n   * @param {TheElement} element\n   * @param {Object<string, string | number | {} | Function>} properties\n   */\n  #setPropertiesToElement(element, properties) {\n    for (const propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#global instanceof VirtualDocument) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function)\n          property = property.toString()\n      } else {\n        // If the property name is an event (for example onClick), then is the value is a function,\n        // this function should not be called to get a value from it. Instead, it should be added\n        // as a listener\n        if (addEventListenerIfPossible(element, propertyName, property))\n          continue\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        const bindFunction = property\n\n        this.#subscribeToBindings({ element, propertyName, bindFunction })\n\n        const value = bindFunction(element)\n\n        setElementAttrOrProp(element, propertyName, value)\n      } else if (propertyName === 'style' && property instanceof Object) {\n        const styleRules = property\n\n        for (const ruleName in styleRules) {\n          const ruleValue = styleRules[ruleName]\n          let finalValue = ''\n\n          if (ruleValue instanceof Function) {\n            const bindFunction = ruleValue\n\n            this.#subscribeToBindings({\n              element,\n              propertyName,\n              subPropertyName: ruleName,\n              bindFunction,\n            })\n\n            finalValue = bindFunction(element)\n          } else\n            finalValue = ruleValue\n\n          // eslint-disable-next-line no-param-reassign\n          element.style[ruleName] = styleRuleModificator(ruleName, finalValue)\n        }\n      } else\n        setElementAttrOrProp(element, propertyName, property)\n    }\n  }\n\n  /**\n   * @param {TheElement} element\n   * @param {string} propertyName\n   * @param {string} [subPropertyName]\n   * @param {BindFunction | StatementBindFunction} [bindFunction]\n   * @param {StatementCallback} [statementCallback]\n   */\n  #subscribeToBindings({\n    element,\n    propertyName,\n    subPropertyName = '',\n    bindFunction,\n    statementCallback,\n  }) {\n    const result = extractVariablesFromFunction(bindFunction)\n\n    for (const stateName in result) {\n      if (!(stateName in this.#paintorWrapper.states)) {\n        // console.error(`State \"${stateName}\" is not defined`)\n        continue\n      }\n\n      for (const path in result[stateName]) {\n        const exploded = path.split('.')\n\n        let obj = this.#paintorWrapper.states[stateName]\n\n        for (let key = 0; key < exploded.length - 1; key++) {\n          const value = exploded[key]\n          obj = obj[value]\n        }\n\n        const stateSubscriptions = this.#paintorWrapper.states[stateName]['--subscribe']\n\n        stateSubscriptions.subscribe(\n          path,\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementCallback,\n        )\n      }\n    }\n  }\n}\n\n/**\n * https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n *\n * @param boundArgs\n * @returns {function(...[*]) : *}\n */\nFunction.prototype.bindArgs = function bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\nfor (const tagName of htmlTags)\n  Paintor.prototype[tagName] = Paintor.prototype.createElement.bindArgs(tagName)\n\n// \"for\" is placed below, otherwise if it is in the class, the typings for its multiple\n// overloads doesn't work correctly.\n// Must have an empty row below this comment section, otherwise it is considered a description\n\nPaintor.prototype.for = Paintor.prototype.forLoop\n\nexport { Paintor }\n","import { Paintor } from './Paintor.js'\nimport { VirtualDocument } from './VirtualDOM/VirtualDocument.js'\nimport { VirtualElement } from './VirtualDOM/VirtualElement.js'\nimport './typedefs.js'\n\n/**\n * This class complements the Paintor class and exists mostly because of treeFunction(), its\n * parameter specifically. If both classes are merged into one, then this parameter cannot be\n * typed correctly.\n */\nclass PaintorWrapper {\n  /**\n   * The main element in which to append all the contents\n   * @type {TheElement | null}\n   */\n  #containerElement = null\n\n  // A state is an Object where the key is the name of the state and the value is a Proxy object\n  /** @type {Object<string, {}>} */\n  #states = {}\n\n  /** @type {TheGlobal} */\n  #global\n\n  #finalHtmlCode = '' // In server mode this will hold the final html code\n\n  /**\n   * @param {string | TheElement} target\n   * @param {{}} states\n   * @param {*} contents\n   * @param {TheGlobal} theGlobal\n   * @returns {PaintorWrapper}\n   */\n  constructor({\n    target,\n    states,\n    contents,\n    theGlobal,\n  }) {\n    this.#global = theGlobal\n\n    const paintor = new Paintor(this)\n    const result = this.#initConstructorArguments(target, states, contents)\n\n    if (!(result instanceof Error)) {\n      this.#clearContainerElement()\n      contents(paintor, states)\n      this.#finalHtmlCode = paintor.finalPaint()\n    }\n  }\n\n  /**\n   * @returns {TheElement}\n   */\n  get containerElement() {\n    return this.#containerElement\n  }\n\n  /**\n   * @return {HTMLDocument | VirtualDocument}\n   */\n  get global() {\n    return this.#global\n  }\n\n  /**\n   * @returns {Object<string, {}>}\n   */\n  get states() {\n    return this.#states\n  }\n\n  /**\n   * @return {string}\n   */\n  getHtmlCode() {\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {string | TheElement} target\n   * @param {State | States} states\n   * @param {Contents} treeFunction\n   * @returns {Error | boolean}\n   */\n  #initConstructorArguments(target, states, treeFunction) {\n    let valid\n\n    // argument 1\n    valid = this.#validateTarget(target)\n\n    if (valid instanceof Error) return valid\n\n    // argument 2\n    valid = this.#validateStates(states)\n\n    if (valid instanceof Error) return valid\n\n    // argument 3\n    valid = this.#validateTreeFunction(treeFunction)\n\n    if (valid instanceof Error) return valid\n\n    return true\n  }\n\n  /**\n   * @param {string | TheElement} target\n   * @returns {Error | boolean}\n   */\n  #validateTarget(target) {\n    const isVirtualGlobal = this.#global instanceof VirtualDocument\n\n    if (\n      (isVirtualGlobal && target instanceof VirtualElement)\n      || (!isVirtualGlobal && target instanceof Node)\n    )\n      this.#containerElement = target\n    else if (typeof target === 'string') {\n      this.#containerElement = (this.#global instanceof VirtualDocument)\n        ? this.#global.createElement('#container')\n        : document.getElementById(target)\n\n      if (!this.#containerElement)\n        return new Error(`Could not locate element #${target}`)\n    } else {\n      return new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof target}>`,\n      )\n    }\n\n    return true\n  }\n\n  /**\n   * @param {State | States} states\n   * @return {Error | boolean}\n   */\n  #validateStates(states) {\n    if (!(states instanceof Object))\n      return new Error('states must be an Object')\n\n    for (const stateName in states) {\n      const state = states[stateName]\n\n      if ('--state-path' in state)\n        this.states[stateName] = state\n      else if (!(this.#global instanceof VirtualDocument))\n        console.error(`The input \"${stateName}\" is \"${typeof state}\", but it should be a state`)\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Contents} treeFunction\n   * @returns {Error | boolean}\n   */\n  #validateTreeFunction(treeFunction) {\n    if (typeof treeFunction !== 'function')\n      return new Error('treeFunction must be a function')\n\n    return true\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElement() {\n    const el = this.#containerElement\n\n    while (el.firstChild)\n      el.removeChild(el.firstChild)\n  }\n}\n\nexport { PaintorWrapper }\n","import { setElementAttrOrProp, styleRuleModificator } from './functions.js'\nimport './typedefs.js'\n\nclass StateSubscriptions {\n  subscriptions = {}\n\n  /** @type {ProxyHandler} */\n  proxy\n\n  /**\n   * @template T\n   * @param {T} object - A generic parameter that flows through to the return type\n   * @return {T}\n   */\n  constructor(object) {\n    this.proxy = this.#createProxy(object)\n  }\n\n  /**\n   * @returns {ProxyHandler}\n   */\n  getState() {\n    return this.proxy\n  }\n\n  /**\n   * A function that binds the property of a html element with element from a state\n   * @param {string} path\n   * @param {HTMLElement} element\n   * @param {string} propertyName\n   * @param {string} subPropertyName\n   * @param {BindFunction} bindFunction\n   * @param {function} [statementCallback]\n   */\n  subscribe(path, element, propertyName, subPropertyName, bindFunction, statementCallback) {\n    this.subscriptions[path] = this.subscriptions[path] || []\n\n    // Search for the same subscription. If it already exists, don't make new one\n    for (const item of this.subscriptions[path]) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementCallback === statementCallback\n      ) return\n    }\n\n    this.subscriptions[path].push({\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementCallback,\n    })\n  }\n\n  /**\n   * A function that removes binds from html element\n   * @param {HTMLElement} element\n   */\n  unsubscribe(element) {\n    for (const key in this.subscriptions) {\n      const subscriptionsGroup = this.subscriptions[key]\n      let subscriptionRemoved = false\n\n      for (let i = 0; i < subscriptionsGroup.length; i++) {\n        const item = subscriptionsGroup[i]\n\n        // if the element is marked for deletion, delete the subscription as well\n        if (item.element === element) {\n          delete subscriptionsGroup[i]\n          subscriptionRemoved = true\n        }\n      }\n\n      // If a subscription has been removed from the array,\n      // remove the remaining empty element of the array\n      if (subscriptionRemoved)\n        this.subscriptions[key] = this.subscriptions[key].filter(Boolean)\n    }\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * @param {string} [statePath]\n   * @return {T}\n   */\n  #createProxy(object, statePath = '') {\n    /** @type {ProxyHandler} */\n    const handler = {}\n\n    handler.get = (target, prop) => {\n      if (prop === '--subscribe')\n        return this\n\n      return target[prop]\n    }\n\n    handler.set = (target, prop, value) => {\n      if (prop === '--subscribe')\n        return true\n\n      // eslint-disable-next-line no-param-reassign\n      target[prop] = value\n\n      let path = target['--state-path']\n\n      path = path ? `${path}.${prop}` : prop\n\n      if (path in this.subscriptions) {\n        const list = this.subscriptions[path] || []\n\n        for (const i in list) {\n          const {\n            element,\n            propertyName,\n            subPropertyName,\n            bindFunction,\n            statementCallback,\n          } = list[i]\n\n          if (element['--deleted'])\n            this.unsubscribe(element)\n          else {\n            const result = bindFunction(element)\n\n            if (propertyName === 'style' && subPropertyName)\n              element.style[subPropertyName] = styleRuleModificator(subPropertyName, result)\n            else if (propertyName === '--if')\n              statementCallback(result)\n            else\n              setElementAttrOrProp(element, propertyName, result)\n          }\n        }\n      }\n\n      return true\n    }\n\n    const proxy = new Proxy(object, handler)\n\n    Object.defineProperty(proxy, '--state-path', {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: statePath,\n    })\n\n    // Recursive proxy\n    for (const key in proxy) {\n      if (proxy[key] instanceof Object) {\n        const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n        proxy[key] = this.#createProxy(proxy[key], innerStatePath)\n      }\n    }\n\n    return proxy\n  }\n}\n\nexport { StateSubscriptions }\n","import { PaintorWrapper } from './PaintorWrapper.js'\nimport { StateSubscriptions } from './StateSubscriptions.js'\nimport { isBrowserEnvironment, theGlobalScope } from './functions.js'\nimport './typedefs.js'\n\nconst isBrowser = isBrowserEnvironment()\n\n/** @type {PaintorFunction} */\nconst paintor = function paintor(target, states, contents) {\n  const { mode } = paintor\n  const theGlobal = theGlobalScope(isBrowser, mode)\n\n  const result = new PaintorWrapper({\n    target,\n    states,\n    contents,\n    theGlobal,\n  })\n\n  if (mode === 'server')\n    return result.getHtmlCode()\n\n  return result\n}\n\n/**\n * @template T\n * @param {T} object - A generic parameter that flows through to the return type\n * @return {T}\n */\nconst createState = function createState(object) {\n  const stateSubscriptions = new StateSubscriptions(object)\n\n  return stateSubscriptions.getState()\n}\n\npaintor.mode = (isBrowser) ? 'browser' : 'server'\npaintor.state = createState\npaintor.createState = createState\n\nexport default paintor\nexport { paintor, createState }\n"],"sourceRoot":""}