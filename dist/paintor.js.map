{"version":3,"mappings":"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","names":["EnumStateAction","HTML_TAGS","symSubscriptions","symAccess","symTemplateFunction","symState","suggestedItems","setSuggestedItems","element","propertyName","subPropertyName","bindFunction","statementRepaintFunction","unsetSuggestedItems","StateProxyArrayFunctions","#arrayFnObjects","fnName","target","receiver","callback","#arrayFnPush","#arrayFnCopyWithin","#arrayFnReverse","#arrayFnShift","#arrayFnSort","#arrayFnSplice","#arrayFnUnshift","args","targetIndex","start","end","length","result","i","len","j","StateProxySubscriptions","#subscriptions","state","stateProp","subscriptions","elementSubscriptions","item","subscription","subs","index","key","hasSubscriptions","moveSubscriptions","fromElement","toElement","newSubscriptionProperties","prop","removeAllSubscriptions","elementSubs","idx","StateProxy","#arrayFunctions","#subs","object","statePath","isState","handler","#createProxyHandler","proxy","innerStatePath","fn","#onPropCreate","#onPropDelete","#onArrayFunctionCallback","value","#onPropUpdateInForState","#onPropUpdate","#getStatementRepaintFunction","updatedState","elementSubscription","action","#onPropCreateOrDelete","modifyStyleRule","setElementAttrOrProp","getGlobalObject","format","fmt","re","replacer","match","escaped","ptn","flag","arg","out","isBrowserEnvironment","isBrowser","addChildToStack","inputChild","childrenStack","addChildrenToStack","inputChildren","child","isEventAttribute","attributeName","isWhitespace","char","isValidCustomElementName","name","selectorEndsWithId","selector","stringToBoolean","string","int","addEventListenerIfPossible","eventSmallName","appendDOMChildrenToElement","children","fragment","appendVirtualChildrenToElement","appendChildrenToElement","forEachLoop","templateTree","forLoopType","handlerOnEmpty","beforeIterationCallback","keyToRender","iterationCallback","isProxy","ret","component","Component","val","forLoop","arrayRemoveKey","arr","insertAfter","newNode","existingNode","nextSibling","parentNode","setDataSetAttributesToElement","dataSet","attrOrPropName","output","objectLength","arrayMoveIndex","array","oldIndex","newIndex","k","chainElements","elements","ElementsCollector","elementsCollector","elementToMove","referenceElement","indexOfElementToMove","indexOfReferenceElement","indexInput","indexOutput","HtmlTemplateParserElement","parent","attributes","SELF_CLOSING_TAGS","HtmlTemplateParser","#attrName","#attrQuote","#attrValue","#attributes","#char","#charPrevious","#data","#stage","#stageNothing","#styleAttrName","#styleAttrValue","#styles","#tagName","#tagNameClosing","#textContents","#topElement","#currentElement","strings","keys","#mergeStringsAndKeys","#rotate","elementsCreator","#generateChildren","#appendData","to","data","el","#makeNewElement","dataIndex","charIndex","#setAttribute","#setStage","stage","#stageAttrName","#setStyle","#stageTagToClose","#stageAttrOpenQuote","#stageStyleAttrName","#stageAttrValue","#stageTag","#stageTextContents","#stageStyleAttrValue","ElementsCreator","#collectedElements","#containerElement","#document","#isSr","#reusableTemplateElement","#templateTree","#templates","#translations","#window","window","containerElement","templates","translations","tagName","argumentID","argument","textNode","#translate","isChildrenArray","#arrayTranslateFormatTranslate","generatedChildren","thisLevel","upperLevel","#beforeStatement","generatedElements","#afterStatement","inlineScript","#setPropertiesToElement","callbackOnTemplate","#statementHandlerForFunction","isInitialRun","commentElementBegin","commentElementEnd","level","#unsubscribeElementAndItsChildren","collectedElements","indexOfFirstKnownChild","from","#statementHandler","input","#forEachLoop","htmlOptions","htmlCode","#htmlForSimpleString","#htmlForTemplateLiteral","condition","elseHandler","callbackForFunction","#statementHandlerResolver","template","returnedValue","#applyComponent","allComponents","allFunctions","#appendChildrenToContainer","collectAtLevel","childrenGroup","#arrayTranslate","renderedElementsMapOnEmpty","callbackForState","renderedElementsMap","onIteration","elementsFromCollector","#statementHandlerForState","type","#insertStatementElements","beginCommentElement","lastElement","newElement","#removeRenderedElements","isArray","properties","property","#setStylesToElement","styleRules","ruleName","ruleValue","finalValue","autoAddCommentElements","bindFunctionResult","hasHandlerOnEmpty","createElements","updatedObject","isTemporaryLevel","added","arrayFunctionArgs","prevKey","iterator","deleteCount","newItems","oldSize","newSize","sizeDiff","key1","key2","tmp","fromIndex","toIndex","mapIndex","elementsLength","newLength","translated","#translateString","globalObject","globallyTranslated","str","translateObject","bindArgs","boundArgs","targetFunction","prototype","BOOLEAN_ATTRIBUTES","EnumNodeTypes","DOMException","message","Node","#childNodes","#nodeName","#nodeType","#parentNode","nodeType","nodeName","aChild","errorMessage","newChildren","childNode","node","indent","childNumber","isChild","paint","Comment","Text","escapeHTML","html","text","charsToReplace","tag","generateAttributesString","attribute","formatStringFromCamelCase","all","getStyleStringFromObject","style","indentWith","indentCurrent","newRow","HTMLElement","selfClosingTag","Element","className","childElement","attributeValue","formatStringToCamelCase","split","word","getStyleObjectFromString","formattedProperty","#style","Document","#body","#children","head","body","DocumentFragment","Window","isBrowserEnv","srWindow","SrWindow","#containerDOMElements","#finalElements","#finalHtmlCode","#isStatic","#renderCustomElements","#selector","#selectorNonId","#staticFinalElements","#staticHtmlCodes","#initialized","#clearForContainer","indexFound","container","translation","#getElementsAsStatic","#render","#getSrWindow","options","on","tree","subItem","#clearContainerElements","#init","#initContainer","#initTranslations","#initTemplates","isSr","nodeList","clearContainers","customElements","customElement","#renderElements","getCustomElementConstructor","mutationList","mutation","addedNodes","removedNodes","creator","getLocale","locale","createSingleTranslation","defaultPath","filePath","__vitePreload","fetchTranslations","defaultPaths","promises","path","isTemplate","func","paintor"],"sources":["../src/constants.js","../src/elementsSuggestor.js","../src/StateProxyArrayFunctions.js","../src/StateProxySubscriptions.js","../src/StateProxy.js","../src/state.js","../src/functions.js","../src/ElementsCollector.js","../src/HtmlTemplateParser/HtmlTemplateParserElement.js","../src/HtmlTemplateParser/constants.js","../src/HtmlTemplateParser/HtmlTemplateParser.js","../src/ElementsCreator.js","../src/SrDOM/constants.js","../src/SrDOM/exceptions/DOMException.js","../src/SrDOM/Node.js","../src/SrDOM/Comment.js","../src/SrDOM/Text.js","../src/SrDOM/functions.js","../src/SrDOM/Element.js","../src/SrDOM/HTMLElement.js","../src/SrDOM/DocumentFragment.js","../src/SrDOM/Document.js","../src/SrDOM/Window.js","../src/Component.js","../src/Translation.js","../src/paintor.js"],"sourcesContent":["/**\n * @readonly\n * @enum {number}\n */\nexport const EnumStateAction = Object.freeze({\n  CREATE: 1,\n  READ: 2,\n  UPDATE: 3,\n  DELETE: 4,\n  ARRAY_SPLICE: 5,\n  ARRAY_SWAP: 6,\n  ARRAY_COPY_WITHIN: 7,\n  ARRAY_SORT: 8,\n  ARRAY_PUSH: 9,\n  ARRAY_LENGTH: 10,\n})\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n * @see https://www.w3schools.com/tags/\n * @readonly\n * @enum {string[]}\n */\nexport const HTML_TAGS = Object.freeze([\n  'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', // 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n])\n\nexport const symSubscriptions  = Symbol('Subscriptions')\nexport const symAccess  = Symbol('Access')\nexport const symTemplateFunction = Symbol('TemplateFunction')\nexport const symState = Symbol('State')\n","/**\n * @type {{\n *   element: null | Element | Comment,\n *   propertyName: string,\n *   subPropertyName: string,\n *   bindFunction: null | BindFunction,\n *   statementRepaintFunction: null | StatementRepaintFunction\n * }}\n */\nlet suggestedItems = {\n  element                 : null,\n  propertyName            : '',\n  subPropertyName         : '',\n  bindFunction            : null,\n  statementRepaintFunction: null,\n}\n\n/**\n * This function should be called just before calling the bindFunction. The idea is\n * that the bindFunction, along with its html element and property name are suggested\n * here to the proxy handler. When the bindFunction is called, any state used in it\n * would trigger the proxy get event, which means that it will be added to the subscriptions.\n *\n * @param {Element | Comment | Text} element\n * @param {string} propertyName\n * @param {string} subPropertyName\n * @param {BindFunction} bindFunction\n * @param {null | StatementRepaintFunction} statementRepaintFunction\n */\nfunction setSuggestedItems(\n  element,\n  propertyName,\n  subPropertyName,\n  bindFunction,\n  statementRepaintFunction,\n) {\n  suggestedItems.element                  = element\n  suggestedItems.propertyName             = propertyName\n  suggestedItems.subPropertyName          = subPropertyName\n  suggestedItems.bindFunction             = bindFunction\n  suggestedItems.statementRepaintFunction = statementRepaintFunction\n}\n\n/**\n * Reset the suggested items\n *\n * @returns {void}\n */\nfunction unsetSuggestedItems() {\n  suggestedItems.element                  = null\n  suggestedItems.propertyName             = ''\n  suggestedItems.subPropertyName          = ''\n  suggestedItems.bindFunction             = null\n  suggestedItems.statementRepaintFunction = null\n}\n\nexport { suggestedItems, setSuggestedItems, unsetSuggestedItems }\n","import { EnumStateAction } from './constants.js'\n\n/** @typedef {Object<*, *> | Array<*>} ProxyObject */\n\nexport class StateProxyArrayFunctions {\n  /**\n   * @type {{receiver: State, target: ProxyObject, callback: Function}}\n   */\n  #arrayFnObjects = { receiver: [], target: [], callback: () => {} }\n\n  /**\n   * @param {string} fnName\n   * @param {ProxyObject} target\n   * @param {State} receiver\n   * @param {Function} callback\n   * @returns {Function | void}\n   */\n  callArrayFn(fnName, target, receiver, callback) {\n    this.#arrayFnObjects.target = target\n    this.#arrayFnObjects.receiver = receiver\n    this.#arrayFnObjects.callback = callback\n\n    switch (fnName) {\n      case 'push':       return this.#arrayFnPush\n      case 'copyWithin': return this.#arrayFnCopyWithin\n      case 'reverse':    return this.#arrayFnReverse\n      case 'shift':      return this.#arrayFnShift\n      case 'sort':       return this.#arrayFnSort\n      case 'splice':     return this.#arrayFnSplice\n      case 'unshift':    return this.#arrayFnUnshift\n      default:           return target[fnName]\n    }\n  }\n\n  /**\n   * @param {any} args\n   * @returns {any}\n   */\n  #arrayFnCopyWithin = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let [targetIndex, start, end] = args\n    const { length } = target\n\n    /**\n     * Fix the arguments, according to the rules in the following link:\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin\n     */\n    if (targetIndex < 0) targetIndex += length\n    else if (targetIndex < -length) targetIndex = 0\n    else if (targetIndex >= length) return\n    else if (targetIndex > start) end = length - 1\n\n    if (start < 0) start += length\n    else if (start < -length || start === undefined) start = 0\n    else if (start >= length) return\n\n    if (end < 0) end += length\n    else if (end < -length) end = 0\n    else if (end >= length || end === undefined) end = length\n    else if (end <= start) return\n\n    // Apply the function\n    const result = target.copyWithin.apply(target, [targetIndex, start, end])\n\n    this.#arrayFnObjects.callback(\n      EnumStateAction.ARRAY_COPY_WITHIN,\n      receiver,\n      [targetIndex, start, end],\n    )\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnPush = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.push.apply(target, args)\n\n    //this.#onPropCreate(receiver, (target.length - 1).toString())\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_PUSH, receiver, args)\n\n    return result\n  }\n\n  #arrayFnReverse = () => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.reverse.apply(target)\n\n    for (let i = 0, len = target.length; i < len; i++) {\n      const j = len - 1 - i\n\n      if (i >= j) break\n\n      this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SWAP, receiver, [i, j])\n    }\n\n    return result\n  }\n\n  #arrayFnShift = () => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.shift.apply(target)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, [0, 1])\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnSort = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.sort.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SORT, receiver, args)\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnSplice = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.splice.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, args)\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnUnshift = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.unshift.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, [0, 0, ...args])\n\n    return result\n  }\n}\n","import { symState, symSubscriptions } from './constants.js'\n\nexport class StateProxySubscriptions {\n  /** @type {Map<string | symbol, Map<Node | Element | Comment | Text, Subscription[]>>} */\n  #subscriptions = new Map()\n\n  get subscriptions() {\n    return this.#subscriptions\n  }\n\n  /**\n   * @param {State} state\n   * @param {string | symbol} stateProp\n   * @param {Element | Comment} element\n   * The HTML element for which the other parameters apply.\n   * @param {string} propertyName\n   * The name of the property of the HTML element, for\n   * which the subscription is going to be created.\n   * For example: 'style', 'value', 'textContent', 'innerHTML'.\n   * Also, '--if' for IF statement.\n   * @param {string} subPropertyName\n   * If the property name is 'style', the sub-property could be\n   * any style property.\n   * For example: 'fontSize'\n   * @param {BindFunction} bindFunction\n   * The function that is used instead of a fixed value.\n   * For example: () => (state.clicks)\n   * @param {StatementRepaintFunction | null} statementRepaintFunction\n   * This is only used in the if() function. It's a function that\n   * is used to repaint the elements in case the condition is changed\n   * from false to true or vice versa.\n   */\n  subscribe(\n    state,\n    stateProp,\n    element,\n    propertyName,\n    subPropertyName,\n    bindFunction,\n    statementRepaintFunction,\n  ) {\n    if (\n      propertyName === '-s-if'\n      || propertyName === '-s-forEach'\n      || propertyName === '-s-forState'\n    ) {\n      stateProp = propertyName\n    }\n\n    if (!this.#subscriptions.has(stateProp)) {\n      this.#subscriptions.set(stateProp, new Map())\n    }\n\n    const subscriptions = this.#subscriptions.get(stateProp) ?? new Map()\n\n    if (!subscriptions.has(element)) {\n      subscriptions.set(element, [])\n    }\n\n    const elementSubscriptions = subscriptions.get(element)\n\n    // Search for a subscription with the same parameters.\n    // If such already exists, just don't create a new one.\n    for (const item of elementSubscriptions) {\n      if (\n        item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementRepaintFunction === statementRepaintFunction\n      ) return\n    }\n\n    /**\n     * @type {Subscription}\n     */\n    const subscription = {\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementRepaintFunction,\n      stateSubscription: this,\n      // @ts-ignore\n      statePath: (state?.[symState]?.path ?? ''),\n    }\n\n    elementSubscriptions.push(subscription)\n\n    // @ts-ignore\n    element[symSubscriptions] ??= []\n    // @ts-ignore\n    element[symSubscriptions].push(subscription)\n  }\n\n  /**\n   * Remove any subscriptions that the element is subscribed to\n   *\n   * @param {Node} element\n   */\n  unsubscribe(element) {\n    if (\n      symSubscriptions in element\n      && element[symSubscriptions] instanceof Array\n    ) {\n      /** @type {Subscription[]} */\n      const subs = element[symSubscriptions]\n      let index = subs.length\n\n      while (index > 0) {\n        index -= 1\n\n        if (subs[index].stateSubscription === this) {\n          subs.splice(index, 1)\n        }\n      }\n    }\n\n    for (const [key, subscriptions] of this.#subscriptions) {\n      subscriptions.delete(element)\n    }\n  }\n}\n\n/**\n * @param {Node | Element | Comment | Text} element\n * @returns {boolean}\n */\nexport function hasSubscriptions(element) {\n  return Object.hasOwn(element, symSubscriptions)\n}\n\n/**\n * Move subscription records from one DOM element into another DOM element.\n * Subscription records are located in a special array in the DOM element.\n *\n * @param {Element | Comment | Text} fromElement\n * @param {Element | Comment | Text} toElement\n * @param {BindFunction} [bindFunction] Optionally filter by the bind function\n * @param {Partial<Subscription>} [newSubscriptionProperties] Optionally set these parameters\n */\nexport function moveSubscriptions(fromElement, toElement, bindFunction, newSubscriptionProperties) {\n  if (\n    symSubscriptions in fromElement\n    && fromElement[symSubscriptions] instanceof Array\n  ) {\n    let index = fromElement[symSubscriptions].length\n\n    while (index > 0) {\n      index -= 1\n\n      /** @type {Subscription} */\n      const subscription = fromElement[symSubscriptions][index]\n\n      if (\n        bindFunction === undefined\n        || bindFunction === subscription.bindFunction\n      ) {\n        /**\n         * 1. Move the subscription record\n         */\n\n        if (newSubscriptionProperties) {\n          for (const prop in newSubscriptionProperties) {\n            // @ts-ignore\n            subscription[prop] = newSubscriptionProperties[prop]\n          }\n        }\n\n        // @ts-ignore\n        toElement[symSubscriptions] ??= []\n        // @ts-ignore\n        toElement[symSubscriptions].push(subscription)\n\n        /**\n         * 2. Remove the subscription record from the origin element\n         */\n        fromElement[symSubscriptions].splice(index, 1)\n      }\n    }\n  }\n}\n\n/**\n * @param {Node | Element | Comment | Text} element\n */\nexport function removeAllSubscriptions(element) {\n  /** @type {Subscription[]} */\n  // @ts-ignore\n  const elementSubs = element[symSubscriptions]\n\n  // No subscriptions to remove -> return\n  if (elementSubs === undefined) return\n\n  let idx = elementSubs.length\n\n  while (idx > 0) {\n    idx -= 1\n\n    if (!elementSubs[idx]) continue\n\n    elementSubs[idx].stateSubscription.unsubscribe(element)\n  }\n\n  // @ts-ignore\n  delete element[symSubscriptions]\n}\n","import { EnumStateAction, symAccess, symState } from './constants.js'\nimport { suggestedItems } from './elementsSuggestor.js'\nimport { modifyStyleRule, setElementAttrOrProp } from './functions.js'\nimport { StateProxyArrayFunctions } from './StateProxyArrayFunctions.js'\nimport { StateProxySubscriptions } from './StateProxySubscriptions.js'\nimport { isState } from './state.js'\n\n/** @typedef {Object<*, *> | Array<*>} ProxyObject */\n\nclass StateProxy {\n  /** @type {StateProxyArrayFunctions} */\n  #arrayFunctions\n\n  /** @type {StateProxySubscriptions} */\n  #subs\n\n  constructor() {\n    this.#arrayFunctions = new StateProxyArrayFunctions()\n    this.#subs = new StateProxySubscriptions()\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * The input object that will be used to create\n   * a proxy object with the same keys and values.\n   * @param {string} statePath\n   * The path to the state:\n   * <br>\n   * - If the state is the parent state, this is an empty string.\n   * <br>\n   * - If the state is a child state, this is the path to it (dot notated).\n   * @returns {T}\n   */\n  createProxy(object, statePath) {\n    /**\n     * Performance hint: Access to the original object instead of the proxy object\n     * whenever possible, because accessing a proxy has worse performance.\n     */\n\n    if (!(object instanceof Object)) {\n      throw new Error('Cannot create a Proxy on non-object')\n    }\n\n    if (\n      isState(object)\n      || object instanceof Date\n    ) {\n      return object\n    }\n\n    const handler = this.#createProxyHandler()\n    const proxy   = new Proxy(object, handler)\n\n    // Store the path to the state in a special value in the\n    // proxy object, but make that value invisible for \"for\"\n    // (and similar) statements.\n    // Object.defineProperty(proxy, '--state-path', {\n    //   enumerable: false,\n    //   configurable: false,\n    //   writable: false,\n    //   value: statePath,\n    // })\n\n    if (object instanceof Object) {\n      if (!(symState in proxy)) {\n        proxy[symState] = { target: object, path: statePath }\n      }\n    }\n\n    for (const key in object) {\n      /**\n       * Recursive proxy - find all inner objects and turn them into child states.\n       */\n      // @ts-ignore\n      if (object[key] instanceof Object) {\n        if (symState in proxy[key]) {\n          continue\n        }\n\n        const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n        // @ts-ignore\n        proxy[key] = this.createProxy(object[key], innerStatePath)\n      }\n      else {\n        // This is done only to ensure that \"set\" event is triggered on the proxy\n        // @ts-ignore\n        proxy[key] = object[key]\n      }\n    }\n\n    return proxy\n  }\n\n  /**\n   * @returns {ProxyHandler<ProxyObject>}\n   */\n  #createProxyHandler() {\n    /** @type {ProxyHandler<ProxyObject>} */\n    const handler = {\n      get: (target, prop, receiver) => {\n        // If the target is a Proxy, get the original target\n        if (symState in target) {\n          target = target[symState].target\n        }\n\n        if (prop === symState) {\n          return target[prop]\n        }\n        /**\n         * Why is hasOwn() needed?\n         * If the state is for example an array and its whole value is read,\n         * then JS tries to read few extra properties first - map, length, constructor\n         */\n        else if (\n          Object.hasOwn(target, prop)\n          || prop === symAccess\n        ) {\n          /**\n           * In the \"if\" below it would be enough to check just one element,\n           * but because of TS more than one is checked\n           */\n          if (\n            suggestedItems.element\n            && suggestedItems.bindFunction\n          ) {\n            this.#subs.subscribe(\n              target,\n              prop,\n              suggestedItems.element,\n              suggestedItems.propertyName,\n              suggestedItems.subPropertyName,\n              suggestedItems.bindFunction,\n              suggestedItems.statementRepaintFunction,\n            )\n          }\n        }\n        // Internal functions of Set() and Map()\n        else if (\n          (target instanceof Map || target instanceof Set)\n          // @ts-ignore\n          && target[prop] instanceof Function\n        ) {\n          /**\n           * @see https://stackoverflow.com/questions/48452885/observe-changes-to-a-map-using-a-proxy\n           */\n\n          // @ts-ignore\n          const fn = target[prop]\n\n          /**\n           * @param {any[]} args\n           * @returns {*}\n           */\n          const boundFunction = (...args) => {\n            const result = fn.apply(target, args)\n\n            if (target instanceof Set) {\n              if (prop === 'add') {\n                this.#onPropCreate(receiver, prop)\n              }\n              else if (prop === 'delete') {\n                this.#onPropDelete(receiver, prop)\n              }\n            }\n            else if (target instanceof Map) {\n              if (prop === 'set') {\n                this.#onPropCreate(receiver, prop)\n              }\n              else if (prop === 'delete') {\n                this.#onPropDelete(receiver, prop)\n              }\n            }\n\n            return result\n          }\n\n          return boundFunction\n        }\n        else if (\n          target instanceof Array\n          // @ts-ignore\n          && target[prop] instanceof Function\n          && typeof prop === 'string'\n        ) {\n          return this.#arrayFunctions.callArrayFn(\n            prop, target, receiver, this.#onArrayFunctionCallback,\n          )\n        }\n\n        return target[prop]\n      },\n      set: (target, prop, value, receiver) => {\n        if (prop === symState || prop === symAccess) {\n          target[prop] = value\n        }\n        // Array's length is set every time after\n        // adding or removing elements\n        else if (target instanceof Array && prop === 'length') {\n          target[prop] = value\n\n          this.#onArrayFunctionCallback(\n            EnumStateAction.ARRAY_LENGTH, receiver, [value],\n          )\n        }\n        else if (Object.hasOwn(target, prop)) {\n          if (\n            value instanceof Object\n            && !(value instanceof Date)\n            && !(isState(value)) // prevents infinite loop\n          ) {\n            let statePath = (typeof prop === 'string') ? prop : ''\n\n            // If the target is already a proxy state, prepend the path from it\n            if (symState in target && target[symState].path !== '') {\n              statePath = target[symState].path + '.' + statePath\n            }\n\n            if (target[prop] instanceof Object && value instanceof Object) {\n              /**\n               * - Find inner Arrays and set the length. This will cause only previously\n               * created DOM elements to be deleted\n               * - Find inner Objects and delete their elements.\n               */\n              for (const key in value) {\n                if (\n                  value[key] instanceof Array\n                  && target[prop][key] instanceof Array\n                  && target[prop][key].length !== value[key].length\n                ) {\n                  target[prop][key].length = value[key].length\n                }\n                else if (\n                  value[key] instanceof Object\n                  && target[prop][key] instanceof Object\n                ) {\n                  this.#onPropDelete(target, prop)\n                }\n              }\n\n              for (const key in target[prop]) {\n                if (!(key in value)) {\n                  this.#onPropDelete(target[prop], key)\n                }\n              }\n\n              /**\n               * When in an Object a whole Array is set, its new values could be primitive\n               * and non-reactive. Loop through the array and for each primitive value that\n               * is changed, fire the update events.\n               */\n              // for (const i in value) {\n              //   if (!(value[i] instanceof Object)) {\n              //     if (value[i] !== target[prop][i]) {\n              //       target[prop][symState] ??= { target: value, path: statePath }\n              //       target[prop][i] = value[i]\n              //\n              //       this.#onPropDelete(target[prop], i)\n              //       this.#onPropCreate(target[prop], i)\n              //     }\n              //   }\n              // }\n            }\n\n            target[prop] = this.createProxy(value, statePath)\n\n            this.#onPropUpdateInForState(receiver, prop, value)\n            //this.#onPropDelete(receiver, prop)\n            //this.#onPropCreate(receiver, prop)\n            //this.#onPropUpdate(receiver, prop, value)\n          }\n          else if (value instanceof Object\n            && !(value instanceof Date)\n            && (isState(value))\n          ) {\n            target[prop] = value\n\n            this.#onPropUpdateInForState(receiver, prop, value)\n            this.#onPropUpdate(receiver, prop, value)\n          }\n          else {\n            target[prop] = value\n\n            this.#onPropUpdateInForState(receiver, prop, value)\n            this.#onPropUpdate(receiver, prop, value)\n          }\n        }\n        else {\n          if (\n            value instanceof Object\n            && !(isState(value))\n          ) {\n            target[prop] = this.createProxy(value, '')\n          }\n          else {\n            target[prop] = value\n          }\n\n          this.#onPropCreate(receiver, prop)\n        }\n\n        return true\n      },\n\n      /**\n       * Trap for the delete operator. This trap can intercept these operations:\n       *  - delete proxy[foo] and delete proxy.foo\n       *  - Reflect.deleteProperty()\n       *\n       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty\n       * @param {ProxyObject} target\n       * @param {string | symbol} prop\n       * @returns {boolean}\n       * A Boolean indicating whether the property has been successfully deleted.\n       */\n      deleteProperty: (target, prop) => {\n        delete target[prop]\n\n        this.#onPropDelete(target, prop)\n\n        return true\n      },\n    }\n\n    return handler\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {Subscription} elementSubscription\n   * @returns {StatementRepaintFunction | null}\n   */\n  #getStatementRepaintFunction(updatedState, elementSubscription) {\n    if (!(symState in updatedState)) {\n      throw new Error('The state must have symState')\n    }\n\n    const { statementRepaintFunction, statePath } = elementSubscription\n\n    if (\n      // @ts-ignore\n      updatedState?.[symState].path !== statePath\n      || !statementRepaintFunction\n    ) {\n      return null\n    }\n\n    return statementRepaintFunction\n  }\n\n  /**\n   * @param {EnumStateAction} action\n   * @param {State} updatedState\n   * @param {any[]} args\n   */\n  #onArrayFunctionCallback = (action, updatedState, args) => {\n    const subscriptions = this.#subs.subscriptions.get('-s-forState')\n\n    if (subscriptions) {\n      for (const [element, elementSubscriptions] of subscriptions) {\n        for (let index = 0, length = elementSubscriptions.length; index < length; index++) {\n          const statementRepaintFunction = this.#getStatementRepaintFunction(\n            updatedState,\n            elementSubscriptions[index],\n          )\n\n          if (statementRepaintFunction) {\n            // @ts-ignore\n            statementRepaintFunction(action, updatedState, '', args)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreate(updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.CREATE, updatedState, prop)\n  }\n\n  /**\n   * @param {EnumStateAction} action\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreateOrDelete(action, updatedState, prop) {\n    const subscriptions = this.#subs.subscriptions.get('-s-forState')\n\n    if (subscriptions) {\n      for (const [element, elementSubscriptions] of subscriptions) {\n        for (let index = 0, length = elementSubscriptions.length; index < length; index++) {\n          const statementRepaintFunction = this.#getStatementRepaintFunction(\n            updatedState,\n            elementSubscriptions[index],\n          )\n\n          if (statementRepaintFunction) {\n            // @ts-ignore\n            statementRepaintFunction(action, updatedState, prop)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropDelete(updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.DELETE, updatedState, prop)\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   * @param {any} value\n   */\n  #onPropUpdate(updatedState, prop, value) {\n    if (this.#subs.subscriptions.has(prop)) {\n      const subscriptions = this.#subs.subscriptions.get(prop)\n\n      if (subscriptions) {\n        for (const [element, elementSubscriptions] of subscriptions) {\n          for (const subscription of elementSubscriptions) {\n            const {\n              propertyName,\n              subPropertyName,\n              bindFunction,\n              statementRepaintFunction,\n            } = subscription\n\n            if (Object.hasOwn(element, '--deleted')) {\n              this.#subs.unsubscribe(element)\n\n              return\n            }\n\n            let result = bindFunction.call(element, element)\n\n            if (propertyName === 'style' && subPropertyName) {\n              // @ts-ignore\n              element.style[subPropertyName]\n                = modifyStyleRule(subPropertyName, result)\n            }\n            else if (\n              propertyName === '--if'\n              || propertyName === '--for'\n              || propertyName === '--nest'\n            ) {\n              if (statementRepaintFunction) {\n                // @ts-ignore\n                statementRepaintFunction(result)\n              }\n            }\n            else {\n              /**\n               * @see Remark \"() => value\"\n               */\n              if (result instanceof Function) {\n                result = result()\n              }\n\n              // @ts-ignore\n              setElementAttrOrProp(element, propertyName, result)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   * @param {any} value\n   */\n  #onPropUpdateInForState(updatedState, prop, value) {\n    if (!(symState in updatedState)) {\n      throw new Error('The state must have symState')\n    }\n\n    const subscriptions = this.#subs.subscriptions.get('-s-forState')\n\n    if (subscriptions) {\n      for (const [element, elementSubscriptions] of subscriptions) {\n        for (\n          let index = 0, length = elementSubscriptions.length;\n          index < length;\n          index++\n        ) {\n          const statementRepaintFunction = this.#getStatementRepaintFunction(\n            updatedState,\n            elementSubscriptions[index],\n          )\n\n          if (statementRepaintFunction) {\n            // @ts-ignore\n            statementRepaintFunction(EnumStateAction.UPDATE, updatedState, prop)\n          }\n        }\n      }\n    }\n  }\n}\n\nexport { StateProxy }\n","import { StateProxy } from './StateProxy.js'\nimport { symState } from './constants.js'\n\n/**\n * @template T\n * @param {T} object\n * Your input object or array\n * @returns {T}\n * A proxy object/array that looks the same as the input object/array\n */\nconst state = function state(object) {\n  if (!(object instanceof Object)) {\n    throw new Error('state() only accepts Object, Array, Set or Map as input value.')\n  }\n\n  const stateProxy = new StateProxy()\n\n  return stateProxy.createProxy(object, '')\n}\n\n/**\n * @param {Object<*,*>} object\n * @returns {boolean}\n */\nconst isState = function (object) {\n  return (object instanceof Object) && (symState in object)\n}\n\nexport { state, isState }\n","import { isState } from './state.js'\nimport { symAccess, symState, symTemplateFunction } from './constants.js'\nimport { ElementsCreator } from './ElementsCreator.js'\nimport { Component } from './Component.js'\n\n/**\n * @see https://github.com/purposeindustries/window-or-global/blob/master/lib/index.js\n * @returns {Window | any}\n */\nexport function getGlobalObject() {\n  return (typeof self === 'object' && self.self === self && self)\n    || (typeof global === 'object' && global.global === global && global)\n    // @ts-ignore\n    || this\n}\n\n/**\n * @see https://github.com/tmpfs/format-util/blob/master/format.js\n * @param {string} fmt\n * @param {...any[]} args\n * @returns {string}\n */\nexport function format(fmt, ...args) {\n  const re = /(%?)(%([ojdsif]))/g\n\n  fmt = fmt ?? ''\n\n  if (args.length > 0) {\n    /**\n     * @param {string} match\n     * @param {string} escaped % (for %%) or null (for anything else)\n     * @param {string} ptn %o or %s or whatever\n     * @param {string} flag The s from %s\n     * @returns {string}\n     */\n    const replacer = (match, escaped, ptn, flag) => {\n      let arg = args.shift()\n      let out = ''\n\n      switch (flag) {\n        case 'o':\n          if (Array.isArray(arg)) {\n            out = JSON.stringify(arg)\n          }\n          break\n        case 's':\n          out = '' + arg\n          break\n        case 'd':\n          out = '' + Number(arg)\n          break\n        case 'j':\n          out = JSON.stringify(arg)\n          break\n        case 'i':\n          out = '' + parseInt('' + arg, 10)\n          break\n        case 'f':\n          out = '' + parseFloat('' + arg)\n          break\n      }\n\n      if (!escaped) {\n        return out\n      }\n\n      // @ts-ignore\n      args.unshift(out)\n\n      return match\n    }\n\n    fmt = fmt.replace(re, replacer)\n  }\n\n  // arguments, remained after the formatting\n  if (args.length > 0) {\n    fmt += ' ' + args.join(' ')\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%')\n\n  return '' + fmt\n}\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @returns {boolean}\n */\nexport function isBrowserEnvironment() {\n  if (isBrowserEnvironment.isIt === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n    isBrowserEnvironment.isIt = isBrowser()\n  }\n\n  return isBrowserEnvironment.isIt ?? false\n}\n\n/**\n * The environment doesn't change over time, so it's enough\n * to determine it once. This variable is used to store the\n * environment, it's a cache.\n *\n * @type {undefined | boolean}\n */\nisBrowserEnvironment.isIt = undefined\n\n/**\n * @template T\n * @param {T} inputChild\n * @param {T[]} childrenStack\n */\nexport function addChildToStack(inputChild, childrenStack) {\n  childrenStack.push(inputChild)\n}\n\n/**\n * @template T\n * @param {T[]} inputChildren\n * @param {T[]} childrenStack\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren) {\n    childrenStack.push(child)\n  }\n}\n\n/**\n * @param {string} attributeName\n * @returns {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {string} char\n * @returns {boolean}\n */\nexport function isWhitespace(char) {\n  return (\n    char === ' '\n    || char === '\\t'\n    || char === '\\r'\n    || char === '\\n'\n  )\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function isValidCustomElementName(name) {\n  return /^[a-z][a-z0-9-]+$/.test(name) && name.includes('-')\n}\n\n/**\n * @param {string} selector\n * @returns {boolean}\n */\nexport function selectorEndsWithId(selector) {\n  return /#[a-z0-9-]+\\s*$/.test(selector)\n}\n\n/**\n * Turns a string into boolean.\n * Covers the cases when the string is 'true', 'false' or a number.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexport function stringToBoolean(string) {\n  if (string === 'true') return true\n\n  if (string === 'false') return false\n\n  const int = parseInt(string)\n\n  return (isNaN(int)) ? Boolean(string) : Boolean(int)\n}\n\n/**\n * @param {Element | Text} element\n * @param {string} attributeName\n * @param {EventListenerOrEventListenerObject} callback\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof window.Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  const eventSmallName = attributeName.toLowerCase().substring(2)\n\n  element.addEventListener(eventSmallName, callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n *\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  }\n  else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child) {\n        fragment.append(child)\n      }\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child) {\n      element.appendChild(child)\n    }\n  }\n}\n\n/**\n * @param {Node | null} element\n * The element in which to append the children\n * @param {Node[]} children\n * The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (!element) return\n\n  if (isBrowserEnvironment() && element instanceof window.Node) {\n    appendDOMChildrenToElement(element, children)\n  }\n  else {\n    appendVirtualChildrenToElement(element, children)\n  }\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values\n * and the \"handler\" function is looped once for each pair.\n * The loop breaks if \"false\" is returned by the \"handler\"\n * function.\n *\n * @template T\n * @param {TemplateTree} templateTree\n * @param {1 | 2} forLoopType\n * @param {Array<T> | Object<string | number, T> | Map<string | number, T>} state\n * @param {ForLoopCallback<T>} handler\n * @param {ForLoopCallbackOnEmpty} [handlerOnEmpty]\n * @param {(key: number | string) => void} [beforeIterationCallback]\n * @param {string | number | symbol} [keyToRender]\n * @param {(key: number | string | undefined, component?: Component | null) => void} [iterationCallback]\n * @returns {boolean}\n * @throws {TypeError}\n */\nexport function forEachLoop(\n  templateTree,\n  forLoopType,\n  state,\n  handler,\n  handlerOnEmpty,\n  beforeIterationCallback,\n  keyToRender,\n  iterationCallback,\n) {\n  if (!(handler instanceof Function)) {\n    throw new TypeError('\"handler\" argument should be a Function')\n  }\n\n  const object = isState(state) ? state[symState].target : state\n  const isProxy = forLoopType === 2 && isState(object)\n\n  /**\n   * Dummy variable, used when the proxy needs to be\n   * forced to fire \"get\" event.\n   *\n   * @type {any}\n   */\n  let nothing = undefined\n\n  if (object instanceof Array) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = isProxy ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && object.length === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const key in object) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy\n        ? (object[key] instanceof Object)\n          ? state[key]\n          : object[key]\n        : object[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      let ret = handler(value, key)\n      /** @type {Component | null} */\n      let component = null\n\n      if (ret instanceof Component) {\n        component = ret\n      }\n      // @ts-ignore\n      if (ret instanceof Function && ret[symTemplateFunction]) {\n        // @ts-ignore\n        ret = ret(templateTree)\n      }\n\n      iterationCallback?.(key, component)\n\n      if (ret === false) break\n    }\n  }\n  else if (\n    object instanceof Map\n    || object instanceof Set\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = (isProxy) ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && object.size === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const [key, value] of object.entries()) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let val = value\n\n      if (beforeIterationCallback) {\n        val = beforeIterationCallback?.(val)\n      }\n\n      let ret = handler(val, key)\n      /** @type {Component | null} */\n      let component = null\n\n      if (ret instanceof Component) {\n        component = ret\n      }\n      // @ts-ignore\n      else if (ret instanceof Function && ret[symTemplateFunction]) {\n        // @ts-ignore\n        ret = ret(templateTree)\n      }\n\n      iterationCallback?.(key, component)\n\n      if (ret === false) break\n    }\n  }\n  else if (object instanceof Object) {\n    /**\n     * The Object loop must be at the end,\n     * because Array, Set and Map are also Object.\n     */\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = isProxy ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && Object.keys(object).length === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const key in object) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy\n        ? (object[key] instanceof Object)\n          ? state[key]\n          : object[key]\n        : object[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      let ret = handler(value, key)\n      /** @type {Component | null} */\n      let component = null\n\n      if (ret instanceof Component) {\n        component = ret\n      }\n      // @ts-ignore\n      else if (ret instanceof Function && ret[symTemplateFunction]) {\n        // @ts-ignore\n        ret = ret(templateTree)\n      }\n\n      iterationCallback?.(key, component)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    throw new TypeError(`The state argument should be an Object or an Array, but instead it is ${object}`)\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {ForLoopIterableCallback} handler\n * @returns {boolean | Error}\n */\nexport function forLoop(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number') {\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n  }\n\n  if (!(handler instanceof Function)) {\n    return new Error('\"handler\" argument should be a Function')\n  }\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} key\n * @returns {T[]}\n */\nexport function arrayRemoveKey(arr, key) {\n  arr.splice(key, 1)\n\n  return arr\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {T} value\n * @returns {T[]}\n */\nexport function arrayRemoveValue(arr, value) {\n  return arr.filter(function (el) {\n    return el !== value\n  })\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n *\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  if (!existingNode) return\n\n  const { nextSibling, parentNode } = existingNode\n\n  if (parentNode) {\n    parentNode.insertBefore(newNode, nextSibling)\n  }\n}\n\n/**\n *\n * @param {HTMLElement} element\n * @param {Object<string, (string | number | boolean)>}dataSet\n */\nexport function setDataSetAttributesToElement(element, dataSet) {\n  if (dataSet instanceof Object) {\n    for (const key in dataSet) {\n      const value = dataSet[key].toString()\n\n      element.setAttribute(`data-${key}`, value)\n    }\n  }\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends on the name of the attribute or property.\n *\n * @param {Element | Text} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    if (value instanceof Array) {\n      // @ts-ignore\n      element[attrOrPropName] = format.apply(null, value)\n    }\n    else {\n      // @ts-ignore\n      element[attrOrPropName] = value ?? ''\n    }\n  }\n  else {\n    if ('setAttribute' in element) {\n      element.setAttribute(attrOrPropName, value)\n    }\n  }\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n *\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function modifyStyleRule(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {HTMLElement}\n */\nexport function stringToHTML(str) {\n  const parser = new DOMParser()\n  const doc    = parser.parseFromString(str, 'text/html')\n\n  return doc.body\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {boolean}\n */\nexport function objectHasKey(object, key) {\n  if (object instanceof Map || object instanceof Set) {\n    return object.has(key)\n  }\n  else {\n    return (key in object)\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {any}\n */\nexport function objectGetValue(object, key) {\n  if (object instanceof Map) {\n    return object.get(key)\n  }\n  else if (object instanceof Set) {\n    return object.has(key) ? key : undefined\n  }\n  else {\n    return object[key]\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @returns {number}\n */\nexport function objectLength(object) {\n  if (object instanceof Array) {\n    return object.length\n  }\n  else if (object instanceof Map || object instanceof Set) {\n    return object.size\n  }\n  else if (object instanceof Object) {\n    return Object.keys(object).length\n  }\n\n  return 0\n}\n\n/**\n * @see https://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another\n * @template T\n * @param {T[]} array\n * @param {number} oldIndex\n * @param {number} newIndex\n * @returns {T[]}\n */\nexport function arrayMoveIndex(array, oldIndex, newIndex) {\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length + 1\n\n    while (k > 0) {\n      k -= 1\n\n      // @ts-ignore\n      array.push(undefined)\n    }\n  }\n\n  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0])\n\n  return array\n}\n\n/**\n * @param {...Element} elements\n */\nexport const chainElements = (...elements) => {\n  const length = elements.length\n\n  for (let i = 1; i < length; i++) {\n    elements[i-1].after(elements[i])\n  }\n}\n","import { arrayMoveIndex } from './functions.js'\n\n/**\n * This class has an array where HTML elements are stored.\n * The class methods provide an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type {Node[]} */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   *\n   * @param {Node} element\n   */\n  addElement(element) {\n    if (element) this.elements.push(element)\n  }\n\n  /**\n   * Add multiple elements to the array of collected elements\n   *\n   * @param {Node[]} elements\n   */\n  addElements(elements) {\n    for (let element of elements) {\n      this.elements.push(element)\n    }\n  }\n\n  /**\n   * Returns the array of collected elements\n   *\n   * @returns {Node[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * @param {Node} element\n   * @returns {boolean}\n   */\n  hasElement(element) {\n    return this.elements.indexOf(element) > -1\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   *\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements) {\n      this.addElement(element)\n    }\n  }\n\n  /**\n   * @param {Node} elementToMove\n   * @param {Node} referenceElement\n   */\n  moveElementAfterAnother(elementToMove, referenceElement) {\n    const indexOfElementToMove    = this.elements.indexOf(elementToMove)\n    const indexOfReferenceElement = this.elements.indexOf(referenceElement)\n\n    if (indexOfElementToMove === -1 || indexOfReferenceElement === -1) {\n      throw new Error('Cannot move one element after another, because one element is missing')\n    }\n\n    if (indexOfReferenceElement - indexOfElementToMove === 1) {\n      // no need to move\n      return\n    }\n\n    this.elements = arrayMoveIndex(\n      this.elements,\n      indexOfElementToMove,\n      indexOfReferenceElement + 1,\n    )\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements.length = 0\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   *\n   * @param {Node[]} elements\n   */\n  removeTheseElements(elements) {\n    let indexInput = elements.length\n\n    while (indexInput > 0) {\n      indexInput -= 1\n\n      let indexOutput = this.elements.length\n\n      while (indexOutput > 0) {\n        indexOutput -= 1\n\n        if (elements[indexInput] === this.elements[indexOutput]) {\n          this.elements.splice(indexOutput, 1)\n\n          continue // remove only the first occurrence\n        }\n      }\n    }\n\n    // if (elements.length > 0) {\n    //   this.elements = this.elements.filter(\n    //     (element) => !(elements.includes(element)),\n    //   )\n    // }\n  }\n\n  /**\n   * @param {Node[]} elements\n   */\n  replaceElements(elements) {\n    this.elements = elements\n  }\n}\n\nexport { ElementsCollector }\n","class HtmlTemplateParserElement {\n  tagName = '-'\n\n  /** @type {HtmlTemplateParserElement} */\n  parent = this\n\n  /** @type {HtmlTemplateParserElement[]} */\n  children = []\n\n  /** @type {Object<string, any>} */\n  attributes = {}\n\n  /**\n   * Create a new instance of this class, but also put it\n   * into the list of children of the current instance\n   *\n   * @param {HtmlTemplateParserElement} parent\n   * @param {Object<string, any>} attributes\n   * @returns {HtmlTemplateParserElement}\n   */\n  newChild(parent, attributes) {\n    const child = new HtmlTemplateParserElement()\n\n    child.parent = parent\n    child.attributes = attributes\n\n    this.children.push(child)\n\n    return child\n  }\n}\n\nexport { HtmlTemplateParserElement }\n","/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n","import { isWhitespace, stringToBoolean } from '../functions.js'\nimport { HtmlTemplateParserElement } from './HtmlTemplateParserElement.js'\nimport { SELF_CLOSING_TAGS } from './constants.js'\n\n/**\n * This class is used to turn JS template literals (containing HTML code) into\n * properly ordered Template Tree.\n */\nclass HtmlTemplateParser {\n  #attrName = ''\n\n  /**\n   * The quote symbol in <...attr=\"value\"> - a single or a double quote.\n   * When the attribute has no quote, for example <...attr=123...>,\n   * the quote would be an empty space.\n   *\n   * @type {\"'\" | \"\\\"\" | \" \" | ''}\n   */\n  #attrQuote = ''\n\n  /** @type {any} */\n  #attrValue = ''\n\n  /** @type {Object<string, any>} */\n  #attributes = {}\n\n  /**\n   * Usually a string, but it could be function, boolean, number...\n   *\n   * @type {any}\n   */\n  #char\n\n  /** @type {any} */\n  #charPrevious\n\n  /** @type {any[]} */\n  #data = []\n\n  /**\n   * Would be set to the method that is going to be used for the next char iteration\n   *\n   * @type {() => void}\n   */\n  #stage = this.#stageNothing\n\n  #styleAttrName = ''\n\n  /** @type {any} */\n  #styleAttrValue = ''\n\n  /** @type {Object<string, any>} */\n  #styles = {}\n\n  #tagName = ''\n\n  #tagNameClosing = ''\n\n  #textContents = ''\n\n  /** @type {HtmlTemplateParserElement} */\n  #topElement = new HtmlTemplateParserElement()\n\n  /** @type {HtmlTemplateParserElement} */\n  #currentElement = this.#topElement\n\n  /**\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   */\n  constructor(strings, keys) {\n    this.#data = this.#mergeStringsAndKeys(strings, keys)\n\n    this.#rotate()\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @returns {(HTMLElement | Text)[]}\n   */\n  generate(elementsCreator) {\n    if (this.#tagName || this.#tagNameClosing) {\n      throw new Error('Some HTML tag is not closed')\n    }\n\n    const elements = this.#generateChildren(elementsCreator, this.#topElement)\n\n    return elements\n  }\n\n  /**\n   * @param {any} to\n   * @param {any} data\n   * @returns {any}\n   */\n  #appendData(to, data) {\n    if (typeof to === 'function') {\n      // The input is a function. In this case:\n      // If the data to append is also a function, return that function\n      // If the data to append is not a function, return the input\n      return (typeof data === 'function')\n        ? data\n        : to\n    }\n\n    return (\n      typeof to === 'string'\n      && (\n        typeof data === 'string'\n        || typeof data === 'number'\n        || typeof data === 'boolean'\n      )\n    )\n      ? to + data.toString()\n      : data\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @param {HtmlTemplateParserElement} element\n   * @returns {(HTMLElement | Text)[]}\n   */\n  #generateChildren(elementsCreator, element) {\n    /** @type {(HTMLElement | Text)[]} */\n    const output = []\n\n    for (const child of element.children) {\n      let el = null\n\n      if (child.tagName === 'if') {\n        el = elementsCreator.if(\n          stringToBoolean(child.attributes?.condition ?? ''),\n          () => {\n            this.#generateChildren(elementsCreator, child)\n          },\n        )\n      }\n      else if (child.tagName === 'for') {\n        if ('iterations' in child.attributes) {\n          el = elementsCreator.for(\n            0,\n            parseInt(child.attributes?.iterations ?? 0) - 1,\n            () => {\n              this.#generateChildren(elementsCreator, child)\n\n              return undefined\n            },\n          )\n        }\n        else if ('from' in child.attributes || 'to' in child.attributes) {\n          el = elementsCreator.for(\n            parseInt(child.attributes?.from ?? 0),\n            parseInt(child.attributes?.to ?? 0),\n            () => {\n              this.#generateChildren(elementsCreator, child)\n\n              return undefined\n            },\n          )\n        }\n      }\n      else if (child.tagName === 'forEach') {\n        if ('object' in child.attributes) {\n          el = elementsCreator.forEach(\n            child.attributes?.object ?? {},\n            () => {\n              this.#generateChildren(elementsCreator, child)\n\n              return undefined\n            },\n          )\n        }\n      }\n      else {\n        el = elementsCreator.createElement(\n          child.tagName,\n          child.attributes,\n          this.#generateChildren(elementsCreator, child),\n        )\n\n        output.push(el)\n      }\n    }\n\n    return output\n  }\n\n  #makeNewElement() {\n    const parent = this.#currentElement\n    const attributes = this.#attributes\n\n    if (Object.keys(this.#styles).length > 0) {\n      attributes.style = this.#styles\n    }\n\n    const child = this.#currentElement.newChild(parent, attributes)\n\n    child.tagName = this.#tagName\n\n    this.#currentElement = child\n  }\n\n  /**\n   * JS Templates provide two arrays - a string array and keys array.\n   * This function is designed to merge these two into a single array.\n   *\n   * @param {string[]} strings\n   * @param {any[]} [keys]\n   * @returns {any[]}\n   */\n  #mergeStringsAndKeys(strings, keys=[]) {\n    const output = []\n\n    for (let index = 0; index < strings.length; index++) {\n      if (strings[index]) {\n        output.push(strings[index])\n      }\n\n      if (keys[index] !== undefined) {\n        output.push(keys[index])\n      }\n    }\n\n    return output\n  }\n\n  #rotate() {\n    for (\n      let dataIndex = 0;\n      dataIndex < this.#data.length;\n      dataIndex++\n    ) {\n      if (typeof this.#data[dataIndex] === 'string') {\n        for (\n          let charIndex = 0;\n          charIndex < this.#data[dataIndex].length;\n          charIndex++\n        ) {\n          this.#char         = this.#data[dataIndex][charIndex]\n          this.#charPrevious = this.#data[dataIndex][charIndex - 1]\n\n          // this.#char, this.#stage.name)\n\n          this.#stage()\n        }\n      }\n      else {\n        this.#char = this.#data[dataIndex]\n        this.#charPrevious = undefined\n\n        // console.log(this.#char, this.#stage.name)\n\n        this.#stage()\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setAttribute(name, value) {\n    if (!name) return\n\n    this.#attributes[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  /**\n   * @param {() => void} stage\n   */\n  #setStage(stage) {\n    // Actions to do before a given stage is set\n    if (stage === this.#stageAttrName) {\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n    }\n\n    // Set the stage\n    this.#stage = stage\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setStyle(name, value) {\n    if (!name) return\n\n    this.#styles[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  #stageAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '/') {\n      if (SELF_CLOSING_TAGS.includes(this.#tagName)) {\n        this.#makeNewElement()\n      }\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === '=') {\n      this.#setStage(this.#stageAttrOpenQuote)\n    }\n    else {\n      this.#attrName += this.#char\n    }\n  }\n\n  #stageAttrOpenQuote() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '\\'' || this.#char === '\"') {\n      this.#attrQuote = this.#char\n\n      this.#setStage(\n        (this.#attrName === 'style')\n          ? this.#stageStyleAttrName\n          : this.#stageAttrValue,\n      )\n    }\n    else {\n      // Value without quotes.\n      // Whitespaces are allowed before the value, but not after.\n      // For that reason, the quote would be a whitespace here\n\n      this.#attrQuote = ' '\n      this.#attrValue = this.#appendData(this.#attrValue, this.#char)\n\n      this.#setStage(this.#stageAttrValue)\n    }\n  }\n\n  #stageAttrValue() {\n    if (this.#char === '>' && this.#charPrevious !== '/') {\n      // When > is found, but the attribute wasn't closed properly.\n      // Could happen if the quote is an empty space, for example: <...attr=true>\n      // Or even unclosed quote, for example: <...attr=\"value>\n      if (this.#attrQuote && this.#attrName && this.#attrValue) {\n        this.#setAttribute(this.#attrName, this.#attrValue)\n      }\n\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n\n      this.#setStage(this.#stageNothing)\n\n      this.#makeNewElement()\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setAttribute(this.#attrName, this.#attrValue)\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      if (this.#char instanceof Object) {\n        this.#attrValue = this.#char\n      }\n      else {\n        this.#attrValue += this.#char\n      }\n    }\n  }\n\n  #stageNothing() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '<') {\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      // In HTML when there are multiple spaces before or after a text,\n      // only one could be visualized. So if\n      if (this.#charPrevious === ' ') {\n        this.#textContents = this.#charPrevious + this.#char\n      }\n      else {\n        this.#textContents = this.#char\n      }\n\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTextContents)\n    }\n  }\n\n  #stageStyleAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setStage(this.#stageAttrName)\n    }\n    else if (this.#char === ':') {\n      this.#setStage(this.#stageStyleAttrValue)\n    }\n    else {\n      this.#styleAttrName += this.#char\n    }\n  }\n\n  #stageStyleAttrValue() {\n    if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === ';') {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageStyleAttrName)\n    }\n    else if (this.#char === this.#attrQuote) {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#styleAttrValue = this.#appendData(this.#styleAttrValue, this.#char)\n    }\n  }\n\n  /**\n   * In this stage we have just detected \"<\" and we are in HTML tag.\n   * This tag could be a new tag, or it could be the closing tag.\n   *\n   * @returns {void}\n   */\n  #stageTag() {\n    if (isWhitespace(this.#char)) {\n      if (this.#tagName !== '') {\n        this.#setStage(this.#stageAttrName)\n      }\n    }\n    else if (this.#char === '/' && SELF_CLOSING_TAGS.includes(this.#tagName)) {\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      if (!this.#tagName) {\n        throw new Error('Expected tag name, found >')\n      }\n\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#charPrevious === '<' && this.#char === '/') {\n      if (!this.#tagName) {\n        //throw new Error('no tag name')\n      }\n\n      this.#tagNameClosing = ''\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else {\n      this.#tagName += this.#char\n    }\n  }\n\n  #stageTagToClose() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      if (\n        this.#currentElement.tagName // Empty if text node\n        && this.#currentElement.tagName !== '-'\n        && !SELF_CLOSING_TAGS.includes(this.#currentElement.tagName)\n        && this.#currentElement.tagName !== this.#tagNameClosing\n      ) {\n        throw new Error(`Expected ${this.#currentElement.tagName} tag to be closed, but ${this.#tagNameClosing} found`)\n      }\n\n      this.#tagName = ''\n      this.#tagNameClosing = ''\n\n      if (\n        !this.#currentElement.tagName // Text node\n      ) {\n        this.#currentElement = this.#currentElement.parent.parent\n      }\n      else {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#setStage(this.#stageNothing)\n    }\n    else {\n      this.#tagNameClosing += this.#char\n    }\n  }\n\n  #stageTextContents() {\n    if (this.#char === '<') {\n      // Reset what was possibly used for text node\n      this.#attributes = {}\n      this.#currentElement.attributes.textContent = this.#textContents\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      this.#textContents = this.#appendData(this.#textContents, this.#char)\n\n      if (!this.#currentElement.tagName) {\n        this.#currentElement.attributes.textContent = this.#textContents\n      }\n    }\n  }\n}\n\nexport { HtmlTemplateParser }\n","import { Component } from './Component.js'\nimport { EnumStateAction, HTML_TAGS, symState, symTemplateFunction } from './constants.js'\nimport { ElementsCollector } from './ElementsCollector.js'\nimport { setSuggestedItems, unsetSuggestedItems } from './elementsSuggestor.js'\nimport {\n  addChildrenToStack,\n  addChildToStack,\n  addEventListenerIfPossible,\n  appendChildrenToElement,\n  arrayRemoveKey,\n  chainElements,\n  forEachLoop,\n  forLoop,\n  format,\n  getGlobalObject,\n  insertAfter,\n  isEventAttribute,\n  modifyStyleRule,\n  objectLength,\n  setDataSetAttributesToElement,\n  setElementAttrOrProp,\n  stringToHTML,\n} from './functions.js'\nimport { HtmlTemplateParser } from './HtmlTemplateParser/HtmlTemplateParser.js'\nimport { isState } from './state.js'\nimport {\n  hasSubscriptions,\n  moveSubscriptions,\n  removeAllSubscriptions,\n} from './StateProxySubscriptions.js'\n\n/**\n * @typedef {Array<{key: (string | number | symbol | undefined), elements: (Node)[]}>} RenderedElementsMap\n */\n\n/**\n * @typedef {Comment & {renderedElementsMap: RenderedElementsMap}} RenderedElementsCollectorElement\n */\n\nclass ElementsCreator {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the\n   * elements separately. Then, when the IF or FOR statement ends, the\n   * collected elements are moved to the upper level and that new level\n   * is deleted.\n   *\n   * @type {ElementsCollector[]}\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {Element | ShadowRoot | null}\n   */\n  #containerElement\n\n  /** @type {Document} */\n  #document\n\n  /**\n   * Is String-Rendering mode\n   *\n   * @type {boolean}\n   */\n  #isSr = true\n\n  /**\n   * Used only for Browser rendering.\n   * This element is used by html(), in its simple mode.\n   *\n   * @type {HTMLTemplateElement | null}\n   */\n  #reusableTemplateElement = null\n\n  /**\n   * The type TemplateTree is the \"face\" of this class.\n   * Both have the same parts, but are made differently.\n   * Sometimes this class must be passed as an argument\n   * to a function for which the type of the argument is\n   * TemplateTree, and putting @ts-ignore is necessary.\n   * So, this \"conversion\" here is to prevent placing\n   * multiple @ts-ignore\n   *\n   * @type {TemplateTree}\n   */\n  // @ts-ignore\n  #templateTree = this\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /** @type {Window} */\n  #window\n\n  /**\n   * @param {Window} window\n   * @param {HTMLElement | Element | ShadowRoot | null} containerElement\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} [translations]\n   */\n  constructor(window, containerElement, templates, translations = []) {\n    this.#window           = window\n    this.#document         = window.document\n    this.#isSr             = this.#document.baseURI === ''\n    this.#containerElement = containerElement\n    this.#templates        = templates\n    this.#translations     = translations\n\n    // HTML_TAGS.forEach((tagName) => {\n    //   // @ts-ignore\n    //   this[tagName] = this[tagName].bind(this)\n    // })\n  }\n\n  /**\n   * Create a DOM element (or multiple elements) and put it into the elements collector\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * @returns {HTMLElement | Text}\n   */\n  createElement(tagName, ...args) {\n    const element = (tagName)\n      ? this.#document.createElement(tagName)\n      : this.#document.createTextNode('')\n\n    /** @type {any[]} */\n    let children   = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string') {\n        // In case of a string, create a new text node.\n        // This way, multiple text nodes can be put into the element,\n        // mixed with http elements.\n\n        const textNode = this.#document.createTextNode(\n          this.#translate(argument),\n        )\n\n        addChildToStack(textNode, children)\n      }\n      else if (typeof argument === 'number') {\n        // The number is converted into a string\n\n        const textNode = this.#document.createTextNode(\n          argument.toString(),\n        )\n\n        addChildToStack(textNode, children)\n      }\n      // @ts-ignore\n      else if (argument instanceof this.#window.Node) {\n        // This is a child, created by this function, to be appended to its parent\n        addChildToStack(argument, children)\n      }\n      else if (argument instanceof Array) {\n        if (argument.length === 0) {\n          continue\n        }\n\n        let isChildrenArray = false\n\n        for (const child of argument) {\n          if (\n            // @ts-ignore\n            child instanceof this.#window.Node // Node includes HTMLElement and Comment\n          ) {\n            isChildrenArray = true\n\n            break\n          }\n        }\n\n        // Case 1) Array, containing at least one child to be added to their parent\n        // In DOM, if some elements are not children, they are turned into strings,\n        // but the same produces error in SSR\n        if (isChildrenArray) {\n          addChildrenToStack(argument, children)\n        }\n        // Case 2) Array, containing string to be formatted\n        else {\n          const textNode = this.#document.createTextNode(\n            this.#arrayTranslateFormatTranslate(argument),\n          )\n\n          addChildToStack(textNode, children)\n        }\n      }\n      else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = this.#translate(argument.message)\n      }\n      else if (argument instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? argument.useTranslations(this.#translations).getElementsSr()\n          : argument.useTranslations(this.#translations).getElements()\n\n        const { length } = generatedChildren\n\n        if (length > 0) {\n          for (const child of generatedChildren[length - 1]) {\n            addChildToStack(child, children)\n          }\n        }\n      }\n      else if (argument instanceof Function) {\n        // Is it a Template function?\n        if (argument[symTemplateFunction]) {\n          const { thisLevel, upperLevel } = this.#beforeStatement()\n\n          argument(this.#templateTree)\n\n          const generatedElements = this.#collectedElements[thisLevel].getElements()\n\n          addChildrenToStack(generatedElements, children)\n\n          this.#afterStatement({ thisLevel, upperLevel })\n        }\n        else {\n          if (this.#isSr) {\n            // @ts-ignore\n            element.innerHTML = `(${argument.toString()})()`\n          }\n          else {\n            if (element instanceof HTMLScriptElement) {\n              const inlineScript = this.#document.createTextNode(`(${argument.toString()})()`)\n              element.appendChild(inlineScript)\n            }\n            else {\n              if (\n                'value' in element\n                && !(element instanceof HTMLLIElement) // <li> has value, but it accepts only numbers\n              ) {\n                this.#setPropertiesToElement(element, { value: argument })\n              }\n              else {\n                // eslint-disable-next-line @typescript-eslint/no-loop-func\n                const callbackOnTemplate = () => {\n                  this.#statementHandlerForFunction(\n                    'nest',\n                    argument,\n                    true,\n                    // eslint-disable-next-line @typescript-eslint/no-loop-func\n                    (\n                      value,\n                      isInitialRun,\n                      commentElementBegin, // Should be Comment element on the first run only\n                      commentElementEnd, // Should be Comment element on the first run only\n                    ) => {\n                      if (value instanceof Function || value instanceof Component) {\n                        if (value instanceof Component) {\n                          const generatedChildren = (this.#isSr)\n                            ? value.useTranslations(this.#translations).getElementsSr()\n                            : value.useTranslations(this.#translations).getElements()\n\n                          if (isInitialRun) {\n                            addChildToStack(commentElementBegin, children)\n                            addChildrenToStack(generatedChildren[0], children)\n                            addChildToStack(commentElementEnd, children)\n                          }\n                          else {\n                            this.#collectedElements[0].addElements(generatedChildren[0])\n                          }\n                        }\n                        else if (symTemplateFunction in value) {\n                          value(this.#templateTree)\n\n                          if (isInitialRun) {\n                            const level = this.#collectedElements.length - 1\n\n                            const generatedElements = this.#collectedElements[level].getElements()\n\n                            addChildToStack(commentElementBegin, children)\n                            addChildrenToStack(generatedElements, children)\n                            addChildToStack(commentElementEnd, children)\n                          }\n                          else {\n                            children.length = 0 // maybe not necessary\n                          }\n                        }\n                      }\n                      else {\n                        if (isInitialRun && commentElementBegin) {\n                          this.#unsubscribeElementAndItsChildren(commentElementBegin)\n                          this.#setPropertiesToElement(element, { textContent: value })\n                        }\n                      }\n                    })\n                }\n\n                this.#setPropertiesToElement(\n                  element, { textNode: argument }, callbackOnTemplate,\n                )\n              }\n            }\n          }\n        }\n      }\n      else if (\n        argument instanceof Object\n        && !(argument instanceof Function)\n        && argumentID === 1\n      ) {\n        // If Object, and the first argument, this is a property.\n        // This condition needs to be at the end of the 'if' chain.\n\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    const level = this.#collectedElements.length - 1\n\n    /**\n     * Along with the known children, there might be unknown children,\n     * created from a function call such as templateCall($). These unknown\n     * children would be placed after the first known child.\n     *\n     * @example\n     * $.div($.span(), templateCall($))\n     *\n     * However, the scenario when the function call is the first argument is\n     * not covered:\n     * @example\n     * $.div(templateCall($), $.span())\n     */\n    if (children.length > 0) {\n      const collectedElements      = this.#collectedElements[level].getElements()\n      const indexOfFirstKnownChild = collectedElements.indexOf(children[0])\n\n      if (indexOfFirstKnownChild > -1) {\n        if (children.length < collectedElements.length - indexOfFirstKnownChild) {\n          // Replace the children with all collected elements, starting from the first known child\n          children = collectedElements.slice(indexOfFirstKnownChild)\n        }\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    this.#collectedElements[level].removeTheseElements(children)\n    this.#collectedElements[level].addElement(element)\n\n    return element\n  }\n\n  /**\n   * For loop with from-to numbers\n   *\n   * @param {number} from\n   * @param {number} to\n   * @param {ForLoopIterableCallback} handler\n   * @returns {Node[] | Error}\n   */\n  for(from, to, handler) {\n    const callback = () => {\n      const result = forLoop(from, to, handler)\n\n      if (result instanceof Error) console.error(result)\n    }\n\n    return this.#statementHandler('for', null, callback)\n  }\n\n  /**\n   * \"for\" loop for objects, arrays, maps and sets\n   *\n   * @template T\n   * @param {T | function() : T} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forEach(input, handler) {\n    return this.#forEachLoop(1, input, handler)\n  }\n\n  /**\n   * \"for\" loop for states\n   *\n   * @template T\n   * @param {State} input\n   * @param {ForLoopCallback<T>} handler\n   * @param {ForLoopCallbackOnEmpty} handlerOnEmpty\n   * @returns {Node[] | Error}\n   */\n  forState(input, handler, handlerOnEmpty) {\n    return this.#forEachLoop(2, input, handler, handlerOnEmpty)\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  getCreatedElements() {\n    return this.#collectedElements[0].getElements()\n  }\n\n  /**\n   * - Browser mode: Returns an empty string\n   * - Server mode: Generate HTML code of the elements at level 0\n   *\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent]\n   * @returns {string}\n   * - Browser mode: Empty string\n   * - Server mode: The final HTML code\n   */\n  getHtmlCode(htmlOptions) {\n    let htmlCode = ''\n\n    if (this.#isSr) {\n      const containerElement = this.#containerElement\n\n      if (containerElement) {\n        // @ts-ignore\n        htmlCode = containerElement.paintChildren(htmlOptions)\n      }\n    }\n\n    return htmlCode\n  }\n\n  /**\n   * @param {string[] | string} strings\n   * A string when html is used as a function, or an array of strings when used as template\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  html(strings, ...keys) {\n    const elements = (\n      keys.length === 0\n      && this.#translations.length === 0 // the faster method doesn't translate anything\n    )\n      ? this.#htmlForSimpleString((strings instanceof Array) ? strings[0] : strings)\n      : this.#htmlForTemplateLiteral((strings instanceof Array) ? strings : [strings], ...keys)\n\n    for (const element of elements) {\n      if (\n        // Dummy tag (virtual mode) when simple string, or text node when template literal\n        // In both cases the tag name is an empty string\n        // @ts-ignore\n        element.tagName === ''\n      ) {\n        element.textContent = this.#translate(element.textContent)\n      }\n    }\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   *\n   * @param {boolean | StatementBindFunction} condition\n   * @param {(function():(void | Template)) | Template} handler\n   * @param {(function():(void | Template)) | Template} [elseHandler]\n   * @returns {Node[]}\n   */\n  if(condition, handler, elseHandler) {\n    /**\n     * If the condition is a value (true or false), the elements\n     * are either created or not.\n     *\n     * If the condition is a function, two helper Comment elements\n     * are created - one in the beginning and another at the end.\n     * All normal elements are placed in between.\n     */\n\n    /**\n     * @param {any} data\n     */\n    const callbackForFunction = (data) => {\n      const isTruthy = Boolean(data)\n\n      if (isTruthy) {\n        if (handler) {\n          this.#statementHandlerResolver(handler)\n        }\n      }\n      else {\n        if (elseHandler) {\n          this.#statementHandlerResolver(elseHandler)\n        }\n      }\n    }\n\n    return (condition instanceof Function)\n      ? this.#statementHandlerForFunction(\n        'if', condition, true, callbackForFunction,\n      )\n      : this.#statementHandler(\n        'if', condition, callbackForFunction,\n      )\n  }\n\n  async render() {\n    this.#collectedElements = [new ElementsCollector()] // Reset\n\n    for (const template of this.#templates) {\n      if (template instanceof Function) {\n        let returnedValue = template(this.#templateTree)\n\n        if (returnedValue instanceof Promise) {\n          returnedValue = await returnedValue\n        }\n\n        if (returnedValue && typeof returnedValue === 'string') {\n          this.html(returnedValue)\n        }\n        else if (returnedValue instanceof Component) {\n          this.#applyComponent(returnedValue, 0)\n        }\n        else if (returnedValue instanceof Function) {\n          returnedValue(this.#templateTree)\n        }\n        else if (returnedValue instanceof Array) {\n          let allComponents = true\n          let allFunctions  = true\n\n          for (const value of returnedValue) {\n            if (!(value instanceof Component)) {\n              allComponents = false\n\n              break\n            }\n\n            if (!(value instanceof Function)) {\n              allFunctions = false\n\n              break\n            }\n          }\n\n          if (allComponents) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Component)) break\n\n              this.#applyComponent(value, 0)\n            }\n          }\n          else if (allFunctions) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Function)) break\n\n              value(this.#templateTree)\n            }\n          }\n        }\n      }\n      else if (template instanceof Component) {\n        this.#applyComponent(template, 0)\n      }\n    }\n\n    this.#appendChildrenToContainer()\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler.\n   *\n   * @param {object} input\n   * @param {number} input.thisLevel\n   * @param {number} input.upperLevel\n   * @returns {Node[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n\n    // ... and clean this level\n    this.#collectedElements[thisLevel].replaceElements([]) // to keep reference\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  #appendChildrenToContainer() {\n    const containerElement = this.#containerElement\n\n    if (containerElement) {\n      appendChildrenToElement(containerElement, this.getCreatedElements())\n    }\n  }\n\n  /**\n   * @param {Component} component\n   * @param {number} [collectAtLevel]\n   */\n  #applyComponent(component, collectAtLevel = -1) {\n    const generatedChildren = (this.#isSr)\n      ? component.useTranslations(this.#translations).getElementsSr()\n      : component.useTranslations(this.#translations).getElements()\n\n    const level = (collectAtLevel < 0)\n      ? this.#collectedElements.length - 1\n      : collectAtLevel\n\n    for (const childrenGroup of generatedChildren) {\n      this.#collectedElements[level].addElements(childrenGroup)\n    }\n  }\n\n  /**\n   * @template T\n   * @param {T[]} array\n   * @returns {(string | T)[]}\n   */\n  #arrayTranslate(array) {\n    const needsTranslation = Boolean(this.#translations)\n\n    return (needsTranslation)\n      ? array.map((value) => this.#translate(value))\n      : array\n  }\n\n  /**\n   * This function first translations each part of the input array,\n   * then formats it, then translations the result.\n   *\n   * @template T\n   * @param {T[]} array\n   * The input array is supposed to be what would format() arguments be\n   * (format string plus multiple arguments), but as an array.\n   * @returns {string}\n   */\n  #arrayTranslateFormatTranslate(array) {\n    return this.#translate(\n      format.apply(\n        null,\n        // @ts-ignore\n        this.#arrayTranslate(array),\n      ),\n    )\n  }\n\n  /**\n   * Prepare the levels to be used in IF or FOR loop, and return them.\n   * This method must be called in the IF or FOR loop, before calling\n   * the handler.\n   *\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    this.#collectedElements.push(new ElementsCollector())\n\n    const thisLevel  = this.#collectedElements.length - 1\n    const upperLevel = thisLevel - 1\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * @template T\n   * @param {ForLoopType} forLoopType\n   * @param {(T | function() : T) | State} input\n   * @param {ForLoopCallback<T>} handler\n   * @param {ForLoopCallbackOnEmpty} [handlerOnEmpty]\n   * @returns {Node[] | Error}\n   */\n  #forEachLoop(forLoopType, input, handler, handlerOnEmpty) {\n    /** @type {Node[] | null} */\n    let renderedElementsMapOnEmpty = null\n\n    /**\n     * @param {any} value\n     * @returns {any}\n     */\n    const beforeIterationCallback = (value) => {\n      return this.#translate(value)\n    }\n\n    if (forLoopType === 2 && isState(input)) {\n      /**\n       * @param {State} state\n       * @param {ElementsCollector} elementsCollector\n       * @param {string | number | symbol} [keyToRender]\n       * @returns {RenderedElementsMap}\n       */\n      const callbackForState = (state, elementsCollector, keyToRender) => {\n        /** @type {RenderedElementsMap} */\n        const renderedElementsMap = []\n\n        /**\n         * Initially there is 1 element - the forEach-begin element.\n         * We want to start after this element.\n         */\n        let index = elementsCollector.getElements().length\n\n        /**\n         * @param {number | string} [key]\n         * @param {Component | null} [component]\n         */\n        const onIteration = (key, component = null) => {\n          /**\n           * When the handler of the loop is a Component,\n           * the component arg is that Component.\n           */\n          if (component) {\n            this.#statementHandlerResolver(component)\n          }\n\n          const elementsFromCollector = elementsCollector.getElements()\n\n          const elements = (index === 0)\n            ? elementsFromCollector\n            : elementsFromCollector.slice(index)\n\n          if (key === undefined) {\n            if (renderedElementsMapOnEmpty) {\n              // Elements are rendered already, stop here\n              return\n            }\n\n            // Save the elements, so then they can be removed\n            renderedElementsMapOnEmpty = elements\n          }\n          else {\n            if (renderedElementsMapOnEmpty) {\n              for (const element of renderedElementsMapOnEmpty) {\n                this.#unsubscribeElementAndItsChildren(element)\n                // @ts-ignore\n                element.remove()\n              }\n\n              renderedElementsMapOnEmpty = null\n            }\n          }\n\n          renderedElementsMap.push({ key, elements })\n\n          index = elementsFromCollector.length\n        }\n\n        forEachLoop(\n          this.#templateTree,\n          forLoopType,\n          state,\n          handler,\n          handlerOnEmpty,\n          beforeIterationCallback,\n          keyToRender,\n          onIteration,\n        )\n\n        return renderedElementsMap\n      }\n\n      return this.#statementHandlerForState(\n        'forState',\n        input,\n        callbackForState,\n        handlerOnEmpty instanceof Function,\n      )\n    }\n\n    /**\n     * @param {State} data\n     */\n    const callbackForFunction = (data) => {\n      forEachLoop(\n        this.#templateTree,\n        forLoopType,\n        data,\n        handler,\n        handlerOnEmpty,\n        beforeIterationCallback,\n      )\n    }\n\n    const type = (forLoopType === 1) ? 'forEach' : 'forState'\n\n    if (input instanceof Function) {\n      return this.#statementHandlerForFunction(\n        type,\n        input,\n        true,\n        // @ts-ignore\n        callbackForFunction,\n      )\n    }\n\n    return this.#statementHandler(type, input, callbackForFunction)\n  }\n\n  /**\n   * Quicker version for the 'html' function that does not use parsing,\n   * because the input is just a single string.\n   *\n   * @param {string} string\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForSimpleString(string) {\n    /** @type {(Element | Node)[]} */\n    let elements = []\n\n    if (this.#isSr) {\n      // We create a new dummy element every time.\n      // An element with no tag name is skipped in the render stage.\n      const element = this.#document.createElement('')\n\n      element.innerHTML = string ?? ''\n\n      elements = [element]\n    }\n    else {\n      if (\n        false\n        && 'DOMParser' in this.#window\n      ) {\n        elements = Array.from(stringToHTML(string.trim() ?? '').childNodes)\n      }\n      else {\n        if (!this.#reusableTemplateElement) {\n          this.#reusableTemplateElement = this.#document.createElement('template')\n        }\n\n        // In DOM, we can reuse the same element\n        const template = this.#reusableTemplateElement\n\n        //element.setHTML(string.trim() ?? '')\n        template.innerHTML = string.trim() ?? ''\n\n        // childNodes also contains the text nodes\n        elements = Array.from(template.content.childNodes)\n\n        template.innerHTML = ''\n      }\n    }\n\n    // Add the newly created elements into the collection\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].addElements(elements)\n\n    return elements\n  }\n\n  /**\n   * @param {string[]} strings\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForTemplateLiteral(strings, ...keys) {\n    const htmlTemplateParser = new HtmlTemplateParser(strings, keys)\n\n    return htmlTemplateParser.generate(this)\n  }\n\n  /**\n   * @param {Comment} beginCommentElement\n   * @param {Node[]} elements\n   * @returns {boolean}\n   * Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginCommentElement, elements) {\n    if (!(this.#containerElement?.contains(beginCommentElement))) {\n      return false\n    }\n\n    /** @type {Node|Comment} */\n    let lastElement = beginCommentElement\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * @param {RenderedElementsCollectorElement} commentElementEnd\n   * @param {string | Symbol} prop\n   * @param {boolean} isArray\n   */\n  #removeRenderedElements(commentElementEnd, prop, isArray) {\n    let index = commentElementEnd.renderedElementsMap.length\n\n    while (index > 0) {\n      index -= 1\n\n      if (!commentElementEnd.renderedElementsMap[index]) continue\n\n      if (prop === '*' || commentElementEnd.renderedElementsMap[index].key === prop) {\n        for (const element of commentElementEnd.renderedElementsMap[index].elements) {\n          // @ts-ignore\n          if (element.renderedElementsMap) { // inner end element\n            // @ts-ignore\n            this.#removeRenderedElements(element, '*', true)\n          }\n\n          // Delete all subscriptions for this element\n          this.#unsubscribeElementAndItsChildren(element)\n\n          // Delete the element itself\n          // @ts-ignore\n          element.remove()\n        }\n\n        if (isArray) {\n          commentElementEnd.renderedElementsMap[index].elements.length = 0\n\n          delete commentElementEnd.renderedElementsMap[index]\n\n          // if (index === updatedObject.length - 1) {\n          //   commentElementEnd.renderedElementsMap.length = updatedObject.length\n          // }\n        }\n        else {\n          commentElementEnd.renderedElementsMap\n            = arrayRemoveKey(commentElementEnd.renderedElementsMap, index)\n        }\n\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement | Text} element\n   * @param {Object<string, string|number|Object<*,*>|function(*):*|BindFunction|HTMLElement>} properties\n   * @param {Function} [callbackOnTemplate]\n   */\n  #setPropertiesToElement(element, properties, callbackOnTemplate) {\n    for (let propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#isSr) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function) {\n          setElementAttrOrProp(element, propertyName, property)\n\n          continue\n        }\n      }\n      else if (property instanceof Function) {\n        // If the property name is an event (for example onClick),\n        // then the property is a function. This function should not\n        // be immediately called to get a value from it. Instead, it\n        // should be added as a listener.\n        if (addEventListenerIfPossible(element, propertyName, property)) {\n          continue\n        }\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        /** @type {BindFunction} */\n        const bindFunction = property\n\n        setSuggestedItems(\n          element,\n          propertyName,\n          '',\n          bindFunction,\n          null,\n        )\n\n        let value = bindFunction(element)\n\n        if (\n          (value instanceof Function && Object.hasOwn(value, symTemplateFunction))\n          || value instanceof Component\n        ) {\n          unsetSuggestedItems()\n\n          if (callbackOnTemplate) {\n            callbackOnTemplate()\n          }\n\n          continue\n        }\n        else if (value instanceof Function) {\n          /**\n           * Remark \"() => value\"\n           *\n           * In forEach the value is provided as a function, so it is not necessary\n           * to use it like this () => value. However, when used like this, the function\n           * returns a function. Resolve the returned function here.\n           */\n          value = value()\n        }\n        else {\n          if (propertyName === 'textNode') {\n            unsetSuggestedItems()\n\n            const textNode = this.#document.createTextNode(value)\n\n            element.appendChild(textNode)\n\n            moveSubscriptions(\n              element, textNode, bindFunction, { propertyName: 'textContent' },\n            )\n\n            continue\n          }\n        }\n\n        unsetSuggestedItems()\n\n        if (value instanceof Array) {\n          value = this.#arrayTranslateFormatTranslate(value)\n        }\n        else if (typeof value === 'string') {\n          value = this.#translate(value)\n        }\n\n        if (propertyName) {\n          setElementAttrOrProp(element, propertyName, value)\n        }\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'style'\n        && property instanceof Object\n      ) {\n        // @ts-ignore\n        this.#setStylesToElement(element, property)\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'data'\n      ) {\n        if (property instanceof Object) {\n          // @ts-ignore\n          setDataSetAttributesToElement(element, property)\n        }\n      }\n      else if (propertyName === 'textContent') {\n        if (property instanceof Array) {\n          element[propertyName] = this.#arrayTranslateFormatTranslate(property)\n        }\n        else {\n          element[propertyName] = this.#translate(property)\n        }\n      }\n      else {\n        if (\n          propertyName === 'innerText'\n          || (\n            propertyName === 'value'\n            && (\n              // Can't use HTMLInputElement here, because it does not exist in SrDOM\n              // @ts-ignore\n              element.tagName === 'INPUT'\n              // @ts-ignore\n              && (element.getAttribute('type') ?? '').toLowerCase() === 'button'\n            )\n          )\n        ) {\n          property = this.#translate(property)\n        }\n\n        setElementAttrOrProp(element, propertyName, property)\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<keyof CSSStyleDeclaration, (string | BindFunction)>} styleRules\n   */\n  #setStylesToElement(element, styleRules) {\n    for (const ruleName in styleRules) {\n      const ruleValue = styleRules[ruleName]\n      let finalValue  = ''\n\n      if (ruleValue instanceof Function) {\n        const propertyName = 'style'\n        const bindFunction = ruleValue\n\n        setSuggestedItems(\n          element,\n          propertyName,\n          ruleName,\n          bindFunction,\n          null,\n        )\n\n        finalValue = bindFunction(element)\n\n        unsetSuggestedItems()\n      }\n      else {\n        finalValue = ruleValue\n      }\n\n      if (typeof ruleName === 'string') {\n        // @ts-ignore\n        element.style[ruleName] = modifyStyleRule(ruleName, finalValue)\n      }\n    }\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach' | 'forState'} type\n   * @param {any} data\n   * @param {function(any): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandler(type, data, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    callback(data)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach' | 'forState' | 'nest'} type\n   * @param {function(): any} bindFunction\n   * @param {boolean} autoAddCommentElements\n   * @param {function((boolean | State | Template | Component), boolean, Comment?, Comment?): void} callbackForFunction\n   * @returns {Node[]}\n   */\n  #statementHandlerForFunction(type, bindFunction, autoAddCommentElements, callbackForFunction) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n    const isFunction                = bindFunction instanceof Function\n\n    if (isFunction) {\n      const commentElementBegin = this.#document.createComment(`${type}-begin`)\n      const commentElementEnd   = this.#document.createComment(`${type}-end`)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementBegin)\n      }\n\n      /**\n       * @type {StatementRepaintFunctionForFunction}\n       */\n      const statementRepaintFunction = (bindFunctionResult) => {\n        if (this.#isSr) {\n          return\n        }\n\n        const level = this.#collectedElements.length - 1\n\n        // Clean all contents.\n        this.#collectedElements[level].removeAllElements()\n        //this.#removeStatementElements(commentElementBegin)\n\n        // Create the new elements\n        callbackForFunction(bindFunctionResult, false, null, null)\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[level].getElements(),\n        )\n\n        if (!success) {\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n        }\n      }\n\n      const element      = commentElementBegin\n      const propertyName = `--${type}` // --if or --for\n\n      setSuggestedItems(\n        element,\n        propertyName,\n        '',\n        bindFunction,\n        statementRepaintFunction,\n      )\n\n      const bindFunctionResult = bindFunction()\n\n      unsetSuggestedItems()\n\n      // Run the handler function\n      callbackForFunction(bindFunctionResult, true, commentElementBegin, commentElementEnd)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementEnd)\n      }\n    }\n    else {\n      const resolved = bindFunction\n\n      // Run the handler function\n      callbackForFunction(resolved, false, null, null)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'forState'} type\n   * @param {any} state\n   * @param {function(\n   *   State, ElementsCollector, (string | number | symbol)=\n   * ): RenderedElementsMap} callbackForState\n   * @param {boolean} hasHandlerOnEmpty\n   * @returns {Node[]}\n   */\n  #statementHandlerForState(type, state, callbackForState, hasHandlerOnEmpty) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    const commentElementBegin = this.#document.createComment(`${type}-begin`)\n    /**\n     * Use the 'end' comment element as a storage for the rendered elements.\n     * It's easier this way, and if the element is being deleted along with\n     * the rendered elements, no references to these elements remains.\n     *\n     * @type {RenderedElementsCollectorElement}\n     */\n    // @ts-ignore\n    const commentElementEnd = this.#document.createComment(`${type}-end`)\n\n    this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n    /**\n     * @param {State} updatedState\n     * @param {State} updatedObject\n     * @param {Node} lastElement\n     * @param {string | symbol | undefined} prop\n     */\n    const createElements = (updatedState, updatedObject, lastElement, prop) => {\n      let isTemporaryLevel = false\n\n      if (commentElementBegin.parentElement) {\n        // When the loop is in inner level, make a new temporary collector,\n        // which will be deleted after that. Otherwise, the new elements are\n        // placed on level 0\n        this.#collectedElements.push(new ElementsCollector())\n        isTemporaryLevel = true\n      }\n\n      const level   = this.#collectedElements.length - 1\n      const added   = callbackForState(updatedState, this.#collectedElements[level], prop)\n      const isArray = updatedObject instanceof Array\n\n      for (const item of added) {\n        // prop would be undefined when using the state is empty, so don't add this item in the map\n        if (prop !== undefined) {\n          if (isArray) {\n            // @ts-ignore\n            commentElementEnd.renderedElementsMap[prop] = item\n          }\n          else {\n            commentElementEnd.renderedElementsMap.push(item)\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        for (const element of item.elements) {\n          if (level === 0) {\n            /**\n             * Parent element is needed in order to apply 'after'.\n             * But if for example there is a for loop (for a state) at top level and\n             * immediately after that a new element is added to the state, that new\n             * element can't be properly added after the previous one, because of the\n             * lack of parent element.\n             * Because of this, let's reorder the collected elements.\n             */\n\n            this.#collectedElements[level].moveElementAfterAnother(element, lastElement)\n          }\n\n          // @ts-ignore\n          lastElement.after(element)\n          lastElement = element\n        }\n      }\n\n      if (isTemporaryLevel) {\n        this.#collectedElements.pop()\n      }\n    }\n\n    /**\n     * TODO Refactor this function, because it's too long\n     *\n     * @type {StatementRepaintFunctionForState}\n     */\n    const statementRepaintFunction = (action, updatedState, prop, arrayFunctionArgs) => {\n      // @ts-ignore\n      const stateParams   = updatedState[symState]\n      const updatedObject = stateParams.target\n\n      if (!(updatedObject instanceof Object)) {\n        return\n      }\n\n      if (this.#isSr) {\n        return\n      }\n\n      if (action === EnumStateAction.CREATE) {\n        /** @type {null | string} */\n        let prevKey = null\n\n        const iterator = (\n          updatedObject instanceof Map\n          || updatedObject instanceof Set\n        )\n          ? updatedObject.keys()\n          : Object.keys(updatedObject)\n\n        for (let i of iterator) {\n          if (i === prop) {\n            break\n          }\n\n          prevKey = i\n        }\n\n        /**\n         * @type {Node}\n         */\n        let lastElement = commentElementBegin\n\n        if (prevKey !== null) {\n          for (const item of commentElementEnd.renderedElementsMap) {\n            if (!item) continue\n\n            if (item.key === prevKey) {\n              const { elements } = item\n\n              lastElement = (elements.length > 0)\n                ? elements[elements.length - 1]\n                : lastElement\n\n              break\n            }\n          }\n        }\n\n        createElements(updatedObject, updatedObject, lastElement, prop)\n      }\n      /**\n       * Element has been deleted from the state?\n       * - Remove the DOM elements\n       * - Remove these same elements from .renderedElementsMap\n       */\n      if (action === EnumStateAction.DELETE) {\n        const isArray = updatedObject instanceof Array\n\n        this.#removeRenderedElements(commentElementEnd, prop, isArray)\n      }\n      else if (action === EnumStateAction.UPDATE) {\n        statementRepaintFunction(EnumStateAction.DELETE, updatedState, prop, undefined)\n        statementRepaintFunction(EnumStateAction.CREATE, updatedState, prop, undefined)\n      }\n      else if (action === EnumStateAction.ARRAY_SPLICE) {\n        if (updatedObject instanceof Array) {\n          /**\n           * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n           */\n          // @ts-ignore\n          let [start, deleteCount, ...newItems] = arrayFunctionArgs\n\n          if (deleteCount === Infinity) {\n            deleteCount = updatedObject.length - start\n          }\n          else if (deleteCount < 0) {\n            deleteCount = 0\n          }\n\n          if (deleteCount > 0) {\n            for (\n              let i = start,\n                length = start + deleteCount;\n              i < length;\n              i++\n            ) {\n              statementRepaintFunction(\n                EnumStateAction.DELETE, updatedState, i.toString(), undefined,\n              )\n              delete commentElementEnd.renderedElementsMap[i]\n            }\n          }\n\n          const oldSize  = commentElementEnd.renderedElementsMap.length\n          const newSize  = updatedObject.length\n          const sizeDiff = newSize - oldSize\n\n          // The array needs to be enlarged?\n          if (sizeDiff > 0) {\n            commentElementEnd.renderedElementsMap.length = newSize\n\n            // Update keys in the map\n            for (\n              let index = newSize - 1;\n              index >= start + newItems.length;\n              index--\n            ) {\n              const oldIndex = index - sizeDiff\n\n              if (oldIndex < 0) break\n\n              commentElementEnd.renderedElementsMap[index]     = commentElementEnd.renderedElementsMap[oldIndex]\n              commentElementEnd.renderedElementsMap[index].key = index.toString()\n              delete commentElementEnd.renderedElementsMap[oldIndex]\n            }\n          }\n          else if (sizeDiff < 0) {\n            commentElementEnd.renderedElementsMap.splice(start, deleteCount)\n\n            // Update keys in the map\n            for (\n              let index = newSize - 1;\n              index >= start + newItems.length;\n              index--\n            ) {\n              commentElementEnd.renderedElementsMap[index].key = index.toString()\n            }\n          }\n\n          if (newItems.length > 0) {\n            for (\n              let index = start;\n              index < start + newItems.length;\n              index++\n            ) {\n              statementRepaintFunction(\n                EnumStateAction.CREATE, updatedState, index.toString(), undefined,\n              )\n            }\n          }\n        }\n\n        commentElementEnd.renderedElementsMap.length = updatedObject.length\n      }\n      else if (action === EnumStateAction.ARRAY_SWAP) {\n        const [key1, key2] = arrayFunctionArgs\n\n        // change siblings\n        // swap elements objects by reference\n        const tmp                                            = commentElementEnd.renderedElementsMap[key2].elements\n        commentElementEnd.renderedElementsMap[key2].elements = commentElementEnd.renderedElementsMap[key1].elements\n        commentElementEnd.renderedElementsMap[key1].elements = tmp\n\n        for (let i = 1; i < commentElementEnd.renderedElementsMap.length; i++) {\n          chainElements(\n            // @ts-ignore\n            ...commentElementEnd.renderedElementsMap[i - 1].elements,\n            ...commentElementEnd.renderedElementsMap[i].elements,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_COPY_WITHIN) {\n        let [target, start, end] = arrayFunctionArgs\n\n        for (\n          let fromIndex = start,\n            toIndex = target;\n          fromIndex < end;\n          fromIndex++, toIndex++\n        ) {\n          statementRepaintFunction(\n            EnumStateAction.DELETE, updatedState, toIndex.toString(), undefined,\n          )\n          statementRepaintFunction(\n            EnumStateAction.CREATE, updatedState, toIndex.toString(), undefined,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_SORT) {\n        for (\n          let index = 0,\n            length = updatedObject.length;\n          index < length;\n          index++\n        ) {\n          statementRepaintFunction(\n            EnumStateAction.DELETE, updatedState, index.toString(), undefined,\n          )\n          statementRepaintFunction(\n            EnumStateAction.CREATE, updatedState, index.toString(), undefined,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_PUSH) {\n        const length = updatedObject.length\n\n        let mapIndex    = commentElementEnd.renderedElementsMap.length\n        let lastElement = commentElementBegin\n\n        while (mapIndex > 0) {\n          mapIndex -= 1\n\n          const item = commentElementEnd.renderedElementsMap[mapIndex]\n\n          if (!item) continue\n\n          const elementsLength = item.elements.length\n\n          if (elementsLength > 0) {\n            // @ts-ignore\n            lastElement = item.elements[elementsLength - 1]\n\n            break\n          }\n        }\n\n        prop = (length - 1).toString()\n\n        createElements(updatedObject, updatedObject, lastElement, prop)\n      }\n      else if (action === EnumStateAction.ARRAY_LENGTH) {\n        const newLength = arrayFunctionArgs?.[0] ?? 0\n\n        if (newLength < commentElementEnd.renderedElementsMap.length) {\n          let index = commentElementEnd.renderedElementsMap.length\n\n          while (index > 0) {\n            index -= 1\n\n            if (index < newLength) break\n\n            // Skip if already deleted.\n            if (commentElementEnd.renderedElementsMap[index] === undefined) {\n              continue\n            }\n\n            statementRepaintFunction(EnumStateAction.DELETE, updatedState, index.toString(), undefined)\n          }\n        }\n\n        if (updatedObject instanceof Array) {\n          commentElementEnd.renderedElementsMap.length = updatedObject.length\n        }\n      }\n\n      if (\n        hasHandlerOnEmpty\n        // it's empty string when array function callback event is fired\n        && (!(updatedObject instanceof Array) || prop === '')\n        && objectLength(updatedObject) === 0\n      ) {\n        createElements(updatedState, updatedObject, commentElementBegin, undefined)\n      }\n    }\n\n    const propertyName = `-s-${type}` // --if or --for\n    const bindFunction = () => state\n\n    setSuggestedItems(\n      commentElementEnd,\n      propertyName,\n      '',\n      bindFunction,\n      statementRepaintFunction,\n    )\n\n    // In this callback the 'for' loop is called\n    const added = callbackForState(state, this.#collectedElements[thisLevel])\n\n    if (added.length === 1 && added[0].key === undefined) {\n      // Initial draw on empty state. We don't want the result from it,\n      // because then it interferes.\n      added.splice(0, 1)\n    }\n\n    commentElementEnd.renderedElementsMap = added\n\n    unsetSuggestedItems()\n\n    this.#collectedElements[thisLevel].addElement(commentElementEnd)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {(function():(void | Template)) | Template | Component} handler\n   */\n  #statementHandlerResolver(handler) {\n    // 1) Component\n    if (handler instanceof Component) {\n      this.#applyComponent(handler)\n\n      return\n    }\n\n    // 2) Template Function\n    if (\n      handler instanceof Function\n      // @ts-ignore\n      && handler[symTemplateFunction]\n    ) {\n      handler(this.#templateTree)\n\n      return\n    }\n\n    // 3) Normal Function\n    if (handler instanceof Function) {\n      // @ts-ignore\n      let ret = handler()\n\n      // 3.1) Normal Function returns Component or Template\n      if (ret instanceof Component || ret instanceof Function) {\n        this.#statementHandlerResolver(ret)\n      }\n\n      return\n    }\n  }\n\n  /**\n   * @param {any} input\n   * @returns {string}\n   */\n  #translate(input) {\n    if (typeof input === 'string') {\n      const translated = this.#translateString(input, this.#translations)\n\n      if (typeof translated === 'string') {\n        return translated\n      }\n\n      // Use the global translation\n      const globalObject = getGlobalObject()\n\n      const globallyTranslated = this.#translateString(\n        input,\n        // @ts-ignore\n        globalObject?.paintorTranslations,\n      )\n\n      if (typeof globallyTranslated === 'string') {\n        return globallyTranslated\n      }\n    }\n\n    return input\n  }\n\n  /**\n   * @param {string} str\n   * @param {Translation[]} [translations]\n   * @returns {string | boolean}\n   */\n  #translateString(str, translations) {\n    if (translations instanceof Array && translations.length > 0) {\n      for (const translateObject of translations) {\n        if (str in translateObject) {\n          return translateObject[str]\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Recursively search in an element's child nodes for\n   * elements, who are used in state subscriptions, and\n   * unsubscribe them. Also unsubscribe the initial element.\n   *\n   * Note: This function works only on the browser!\n   *\n   * @param {Node} element\n   */\n  #unsubscribeElementAndItsChildren(element) {\n    if (hasSubscriptions(element)) {\n      Object.assign(element, { '--deleted': true })\n      removeAllSubscriptions(element)\n    }\n\n    /**\n     * Unsubscribe each child element recursively.\n     *\n     * Performance Notes:\n     * - This loop is reached too often for its performance to be ignored\n     * - Used .forEach() before, but while loop is more than 30% faster\n     */\n\n    let index = element.childNodes.length\n\n    while (index > 0) {\n      index -= 1\n\n      this.#unsubscribeElementAndItsChildren(element.childNodes[index])\n    }\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\n\n/**\n * @see https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n * @param {...any} boundArgs\n * @returns {function(...[*]):*}\n * @this {any}\n */\nfunction bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  /**\n   * @param {...any} args\n   * @returns {any}\n   * @this {any}\n   */\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\nconst { prototype } = ElementsCreator\n\n// prototype.createElement.bindArgs = bindArgs\nObject.assign(prototype.createElement, { bindArgs })\n\nHTML_TAGS.forEach((tagName) => {\n  // @ts-ignore\n  prototype[tagName] = prototype.createElement.bindArgs(tagName)\n})\n\nexport { ElementsCreator }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @enum {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = Object.freeze([\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n])\n\n/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from\n * each other, such as elements, text and comments.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const EnumNodeTypes = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n})\n","export class DOMException extends Error {\n  /**\n   * @param {string} message\n   * @param {string} [name]\n   */\n  constructor(message, name) {\n    super(message)\n    this.name = name ?? 'DOMException'\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { paint } from './functions.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\nclass Node {\n  /** @type {Node | null} */\n  nextSibling = null\n\n  /** @type {Node | null} */\n  previousSibling = null\n\n  /** @type {string} */\n  textContent = ''\n\n  /** @type {Node[]} */\n  #childNodes = []\n\n  /**\n   * @type {string}\n   */\n  #nodeName = ''\n\n  /** @type {number} */\n  #nodeType = 1\n\n  /** @type {Node | null} */\n  #parentNode = null\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} nodeName\n   */\n  constructor(nodeType, nodeName) {\n    this.#nodeType = nodeType\n    this.#nodeName = nodeName\n  }\n\n  /**\n   * @returns {string}\n   */\n  get baseURI() {\n    return ''\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  get childNodes() {\n    return this.#childNodes\n  }\n\n  /**\n   * @returns {Node | null}\n   */\n  get firstChild() {\n    return this.#childNodes[0] ?? null\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @returns {string}\n   */\n  get nodeName() {\n    return this.#nodeName\n  }\n\n  /**\n   * @returns {number}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentnode.asp\n   * @returns {Node | null}\n   */\n  get parentNode() {\n    return this.#parentNode\n  }\n\n  /**\n   * Not in DOM\n   *\n   * @param {Node | null} parentNode\n   */\n  set parentNode(parentNode) {\n    this.#parentNode = parentNode\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\n   *\n   * @param {Node} aChild\n   * @throws {DOMException | TypeError}\n   */\n  appendChild(aChild) {\n    // If the parent of aChild is not a Document, DocumentFragment, or an Element.\n    if (\n      this.nodeType !== EnumNodeTypes.DOCUMENT_NODE\n      && this.nodeType !== EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n      && this.nodeType !== EnumNodeTypes.ELEMENT_NODE\n    ) {\n      throw new DOMException('This node type does not support this method.')\n    }\n\n    // If the insertion of aChild would lead to Document with more than one Element as child.\n    // (document should contain body here, which is an Element)\n    if (\n      this.nodeType === EnumNodeTypes.DOCUMENT_NODE\n    ) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': Only one element on document allowed.')\n    }\n\n    // If aChild is not a DocumentFragment, a DocumentType, an Element, or a CharacterData.\n    if (!(aChild instanceof Node)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Node\\''\n        + ': parameter 1 is not of type \\'Node\\'.'\n\n      throw new TypeError(errorMessage)\n    }\n\n    // If the node already exists, do not append it\n    if (this.#childNodes.includes(aChild)) {\n      return\n    }\n\n    if (aChild === this) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': The new child element contains the parent.')\n    }\n\n    this.#childNodes.push(aChild)\n    aChild.parentNode = this\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#childNodes.length - 2\n\n    if (prevKey >= 0) {\n      this.#childNodes[prevKey].nextSibling = aChild\n      aChild.previousSibling = this.#childNodes[prevKey] ?? null\n    }\n  }\n\n  /**\n   * TODO Make this function do whatever it has to do\n   *\n   * @returns {boolean}\n   */\n  contains() {\n    return false\n  }\n\n  /**\n   * TODO Check whether this function works correctly\n   *\n   * @param {Node} newElement\n   * @param {Node} referenceElement\n   * @returns {Node}\n   */\n  insertBefore(newElement, referenceElement) {\n    /** @type {Node[]} */\n    const newChildren = []\n\n    for (const child of this.#childNodes) {\n      if (child === referenceElement) {\n        newChildren.push(newElement)\n      }\n\n      newChildren.push(child)\n    }\n\n    this.#childNodes = newChildren\n\n    return newElement\n  }\n\n  /**\n   * Removes a child node and returns the removed node.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n   * @param {Node} childNode\n   * @returns {Node}\n   */\n  removeChild(childNode) {\n    if (!childNode) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'parameter 1 is not of type \\'HTMLElement\\'.',\n      )\n    }\n\n    if (!this.#childNodes.includes(childNode)) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'The node to be removed is not a child of this node.',\n      )\n    }\n\n    this.#childNodes = this.#childNodes.filter((node) => node !== childNode)\n\n    return childNode\n  }\n\n  /**\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   */\n  paintChildren({ indent = '' }) {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.childNodes) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += paint(child, indent, '', isChild)\n    }\n\n    return children\n  }\n}\n\nexport { Node }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Comment extends Node {\n  constructor() {\n    super(EnumNodeTypes.COMMENT_NODE, '#comment')\n  }\n}\n\nexport default Comment\n\nexport { Comment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Text extends Node {\n  constructor() {\n    super(EnumNodeTypes.TEXT_NODE, '#text')\n  }\n}\n\nexport { Text }\n","import { Comment } from './Comment.js'\nimport { BOOLEAN_ATTRIBUTES, SELF_CLOSING_TAGS } from './constants.js'\nimport { HTMLElement } from './HTMLElement.js'\nimport { Text } from './Text.js'\nimport { Node } from './Node.js'\n\n/**\n * @param {number} count\n * @param {string} [chars='\\t']\n * @returns {string}\n */\nfunction generateIndents(count, chars = '\\t') {\n  let output = ''\n\n  for (let i = 0; i < count; i++) {\n    output += chars\n  }\n\n  return output\n}\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {SrAttr[]} attributes\n * @returns {string}\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      ) {\n        output += ` ${name}`\n      }\n    }\n    else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else if (value instanceof Function) value = `return(${value.toString()}).call(this,window.event)`\n      else value = value.toString()\n\n      value = value.replace(/\\\"/g, '\\\\\"')\n      value = escapeHTML(value)\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @returns {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * @param {Node} node\n * @param {string} indentWith\n * @param {string} indentCurrent\n * @param {boolean} isChild If true, a new row is put in the beginning\n * @returns {string}\n */\nfunction paint(node, indentWith, indentCurrent, isChild = false) {\n  let output = ''\n  let indent = ''\n  let newRow = ''\n\n  if (indentWith) {\n    indent = indentCurrent\n    newRow = '\\n'\n  }\n\n  if (node instanceof Comment) {\n    output += `${newRow}${indent}<!--${node.textContent}-->`\n  }\n  else if (node instanceof Text) {\n    output += `${newRow}${indent}${node.textContent}`\n  }\n  else if (node instanceof HTMLElement) {\n    const selfClosingTag = (SELF_CLOSING_TAGS.includes(node.tagName))\n    const attributes = generateAttributesString(node.attributes)\n\n    let style = ''\n\n    if (Object.keys(node.style).length > 0) {\n      style = ` style=\"${getStyleStringFromObject(node.style)}\"`\n    }\n\n    // Paint the opening tag (including attributes)\n    if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n    output += indent\n\n    // Paint the opening tag\n    if (node.tagName) {\n      output += `<${node.tagName.toLowerCase()}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n    }\n\n    // Paint the text in the element\n    output += node.textContent\n\n    // Paint the children\n    let children = ''\n\n    for (const child of node.childNodes) {\n      children += paint(child, indentWith, indentCurrent + indentWith, true)\n    }\n\n    if (children) {\n      output += children + newRow + indent\n    }\n\n    // Paint the closing tag\n    if (\n      node.tagName !== ''\n    ) {\n      output += (selfClosingTag) ? '/>' : `</${node.tagName.toLowerCase()}>`\n    }\n  }\n\n  return output\n}\n\nexport { paint, escapeHTML }\n","import { EnumNodeTypes } from './constants.js'\nimport { escapeHTML } from './functions.js'\nimport { Node } from './Node.js'\n\nexport class Element extends Node {\n  /** @type {SrAttr[]} */\n  #attributes = []\n\n  /** @type {string} */\n  #tagName = ''\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} tagName\n   */\n  constructor(nodeType, tagName) {\n    super(nodeType, tagName.toUpperCase())\n\n    this.#tagName = tagName.toUpperCase()\n  }\n\n  /**\n   * @returns {SrAttr[]}\n   */\n  get attributes() {\n    return this.#attributes\n  }\n\n  /**\n   * Includes only Element nodes\n   *\n   * @returns {Element[]}\n   */\n  get children() {\n    // @ts-ignore\n    return this.childNodes.filter((node) => node instanceof Element)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @returns {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @returns {string}\n   */\n  get innerHTML() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @returns {string}\n   */\n  get tagName() {\n    return this.#tagName\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   *\n   * @param {Node | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof Node) {\n      this.appendChild(childElement)\n    }\n    else {\n      this.textContent = escapeHTML(childElement.toString())\n    }\n  }\n\n  /**\n   * @param {string} attributeName\n   * @returns {string | null}\n   */\n  getAttribute(attributeName) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return null\n    }\n\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      return null\n    }\n    else {\n      return this.#attributes[index].value\n    }\n  }\n\n  /**\n   * Removes the element from the children list of its parent.\n   *\n   * @returns {void}\n   */\n  remove() {\n    this.parentNode?.removeChild(this)\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   *\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return\n    }\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      this.#attributes.push({ name, value })\n    }\n    else {\n      this.#attributes[index] = { name, value }\n    }\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { Element } from './Element.js'\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n *\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringToCamelCase(str) {\n  const split = str.split('-')\n\n  if (split.length === 1) return split[0]\n\n  return (\n    split[0]\n    + split.slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @returns {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  /** @type {StylesObject} */\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass HTMLElement extends Element {\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {string} tagName\n   */\n  constructor(tagName) {\n    super(EnumNodeTypes.ELEMENT_NODE, tagName)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @returns {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @returns {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | StylesObject} input\n   */\n  set style(input) {\n    // In the browser there are few ways to set the style:\n    // - By setting each individual property (.style.color = red)\n    // - By setting '.style.cssText' to a string (.style.cssText = 'color:red')\n    // - By setting '.style' itself to a string (.style = 'color:red')\n\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style) {\n        this.#style[key] = style[key].toString()\n      }\n    }\n  }\n}\n\nexport { HTMLElement }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass DocumentFragment extends Node {\n  constructor() {\n    super(EnumNodeTypes.DOCUMENT_FRAGMENT_NODE, '#document-fragment')\n  }\n}\n\nexport { DocumentFragment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Comment, DocumentFragment, HTMLElement, Element, Node, Text } from './orderedExports.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass Document extends Node {\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ELEMENT_NODE = EnumNodeTypes.ELEMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ATTRIBUTE_NODE = EnumNodeTypes.ATTRIBUTE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  TEXT_NODE = EnumNodeTypes.TEXT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  CDATA_SECTION_NODE = EnumNodeTypes.CDATA_SECTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  PROCESSING_INSTRUCTION_NODE = EnumNodeTypes.PROCESSING_INSTRUCTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  COMMENT_NODE = EnumNodeTypes.COMMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_NODE = EnumNodeTypes.DOCUMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_TYPE_NODE = EnumNodeTypes.DOCUMENT_TYPE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_FRAGMENT_NODE = EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n\n  /** @type {HTMLElement} */\n  #body\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @type {Element[]}\n   */\n  #children = []\n\n  constructor() {\n    super(/* DOCUMENT_NODE */ 9, '#document')\n\n    const html = new HTMLElement('html')\n    const head = new HTMLElement('head')\n    const body = new HTMLElement('body')\n\n    html.appendChild(head)\n    html.appendChild(body)\n\n    this.#children.push(html)\n\n    this.#body = body\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get body() {\n    return this.#body\n  }\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/children\n   * @returns {Element[]}\n   */\n  get children() {\n    return this.#children\n  }\n\n  /**\n   * @returns {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment() {\n    return new DocumentFragment()\n  }\n\n  /**\n   * @param {string} [text]\n   * @returns {Comment}\n   */\n  createComment(text = '') {\n    const element = new Comment()\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   * @returns {HTMLElement}\n   */\n  createElement(tagName) {\n    return new HTMLElement(tagName)\n  }\n\n  /**\n   * @param {string} text\n   * @returns {Text}\n   */\n  createTextNode(text) {\n    const element = new Text()\n\n    element.textContent = text\n\n    return element\n  }\n\n  // /**\n  //  * @param {boolean} [prettyPrint]\n  //  * @returns {string}\n  //  */\n  // paint(prettyPrint = true) {\n  //   const tabsCount = (prettyPrint) ? 0 : -1\n  //\n  //   return this.body.paint(tabsCount)\n  // }\n}\n\nexport { Document, HTMLElement }\n","import { Comment, Document, DocumentFragment, Element, HTMLElement, Node, Text } from './orderedExports.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\n/**\n * String-Rendering DOM\n */\nclass Window {\n  /** @type {typeof Comment} */\n  Comment = Comment\n\n  /** @type {typeof DocumentFragment} */\n  DocumentFragment = DocumentFragment\n\n  /** @type {typeof Element} */\n  Element = Element\n\n  /** @type {typeof HTMLElement} */\n  HTMLElement = HTMLElement\n\n  /** @type {typeof Node} */\n  Node = Node\n\n  /** @type {typeof Text} */\n  Text = Text\n\n  /** @type {typeof DOMException} */\n  DOMException = DOMException\n\n  /** @type {typeof Error} */\n  Error = Error\n\n  /** @type {typeof TypeError} */\n  TypeError = TypeError\n\n  /** @type {Document} */\n  document\n\n  constructor() {\n    this.document = new Document()\n  }\n}\n\nexport { Window }\n","import { ElementsCreator } from './ElementsCreator.js'\nimport {\n  isBrowserEnvironment,\n  isValidCustomElementName,\n  selectorEndsWithId,\n} from './functions.js'\nimport { Window as SrWindow } from './SrDOM/Window.js'\nimport { state } from './state.js'\nimport { removeAllSubscriptions } from './StateProxySubscriptions.js'\n\n\nconst isBrowserEnv = isBrowserEnvironment()\nconst srWindow = new SrWindow()\n\nclass Component {\n  state = null\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {(Node | Element | HTMLElement)[]}\n   */\n  #containerDOMElements = []\n\n  /** @type {Node[][]} */\n  #finalElements = []\n\n  /**\n   * In server mode this will hold the final WebApi code\n   *\n   * @type {string}\n   */\n  #finalHtmlCode = ''\n\n  /** @type {boolean} */\n  #isStatic = false\n\n  /** @type {boolean} */\n  #renderCustomElements = false\n\n  /** @type {string} */\n  #selector = ''\n\n  /** @type {string} */\n  #selectorNonId = ''\n\n  /** @type {Map<Translation | null, Node[][]>} */\n  #staticFinalElements = new Map()\n\n  /** @type {Map<Translation | null, string>} */\n  #staticHtmlCodes = new Map()\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  #initialized = false\n\n  /**\n   * Clear the elements created by this Component\n   */\n  clear() {\n    for (const elements of this.#finalElements) {\n      for (const element of elements) {\n        removeAllSubscriptions(element)\n        // @ts-ignore\n        element.remove()\n      }\n    }\n\n    this.#finalElements.length = 0\n    this.#finalHtmlCode = ''\n\n    this.#staticFinalElements.clear()\n    this.#staticHtmlCodes.clear()\n  }\n\n  /**\n   * Clear the elements created by this Component, but only for particular container\n   *\n   * @param {Node} containerElement\n   */\n  #clearForContainer(containerElement) {\n    let indexFound = -1\n    let i = -1\n\n    for (const container of this.#containerDOMElements) {\n      i += 1\n\n      if (containerElement === container) {\n        indexFound = i\n      }\n    }\n\n    if (indexFound === -1) {\n      return\n    }\n\n    delete this.#containerDOMElements[indexFound]\n\n    for (const element of this.#finalElements[indexFound]) {\n      removeAllSubscriptions(element)\n      // @ts-ignore\n      element.remove()\n    }\n\n    delete this.#finalElements[indexFound]\n    this.#finalHtmlCode = ''\n\n    for (const [translation, elements] of this.#staticFinalElements) {\n      delete elements[indexFound]\n    }\n\n    this.#staticHtmlCodes.clear()\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElements() {\n    if (this.#isStatic) {\n      return this.#getElementsAsStatic(null)\n    }\n\n    this.#render(null, window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElementsSr() {\n    if (this.#isStatic) {\n      return this.#getElementsAsStatic('')\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * Renders the components into an HTML code and returns it\n   *\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  html(options) {\n    if (this.#isStatic) {\n      return this.staticHtml(options)\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true, options)\n\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection} container\n   * @returns {void}\n   */\n  paint(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only use this function in browser environment')\n    }\n\n    if (!container) {\n      throw new Error('No container selected.')\n    }\n\n    if (\n      typeof container !== 'string'\n      && !(container instanceof HTMLElement)\n      && !(container instanceof NodeList)\n      && !(container instanceof Array)\n      && !(container instanceof HTMLCollection)\n    ) {\n      throw new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof container}>`,\n      )\n    }\n\n    this.#render(container, window, true)\n  }\n\n  /**\n   * @param {boolean} [on=true]\n   * @returns {Component}\n   */\n  static(on = true) {\n    this.#isStatic = on\n\n    return this\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  staticHtml(options) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticHtmlCodes.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render('', window, true, options)\n      this.#staticHtmlCodes.set(\n        key,\n        this.#finalHtmlCode,\n      )\n    }\n\n    return this.#staticHtmlCodes.get(key) ?? ''\n  }\n\n  /**\n   * @param {TemplateTree} tree\n   * @returns {void\n   *   | string\n   *   | HTMLElement | HTMLElement[]\n   *   | Component | Component[]\n   *   | Template | Template[]\n   * }\n   */\n  template(tree) {\n  }\n\n  /**\n   * @param {...(Template | Template[] | Component | Component[])} from\n   * @returns {Component}\n   */\n  useTemplates(...from) {\n    if (from instanceof Array) {\n      for (const item of from) {\n        if (item instanceof Array) {\n          for (const template of item) {\n            this.#templates.push(template)\n          }\n        }\n        else {\n          this.#templates.push(item)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * @param {...Translation} translations\n   * @returns {Component}\n   */\n  useTranslations(...translations) {\n    // Reset translations here, because the whole api chain (containing this function)\n    // can be executed multiple times, but with different translations every time.\n    // EDIT: Commented out, so that translations can be used in Components\n    // this.#translations = []\n\n    translations.map((item) => {\n      if (item instanceof Array) {\n        item.forEach((subItem) => {\n          if (!this.#translations.includes(subItem)) {\n            this.#translations = [...this.#translations, subItem]\n          }\n        })\n      }\n      else if (item instanceof Object) {\n        if (!this.#translations.includes(item)) {\n          this.#translations = [...this.#translations, item]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElements() {\n    if (this.#containerDOMElements) {\n      for (const el of this.#containerDOMElements) {\n        while (el?.firstChild) {\n          el.removeChild(el.firstChild)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {string | null} container\n   * @returns {Node[][]}\n   */\n  #getElementsAsStatic(container) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticFinalElements.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render(container, window, true)\n      this.#staticFinalElements.set(\n        key,\n        this.#finalElements,\n      )\n    }\n\n    return this.#staticFinalElements.get(key) ?? []\n  }\n\n  /**\n   * This method is for tricking TS that the string-rendering DOM's Window\n   * has the same type of the browser DOM's window\n   *\n   * @returns {Window}\n   */\n  #getSrWindow() {\n    // @ts-ignore\n    return srWindow\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {Translation[]} translations\n   * @param {(Template | Component)[]} templates\n   * @throws {Error}\n   */\n  #init(container, window, translations, templates) {\n    if (this.#initialized) return\n\n    this.#initialized = true\n\n    this.#finalElements.length = 0\n    this.#finalHtmlCode = ''\n\n    this.#initContainer(container, window)\n    this.#initTranslations(translations)\n    this.#initTemplates(templates)\n  }\n\n  /**\n   * @param {string | HTMLElement| HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @returns {boolean}\n   */\n  #initContainer(container, window) {\n    const isSr = window.document.baseURI === ''\n\n    if (typeof container === 'string') {\n      this.#selector = container\n      this.#renderCustomElements = false\n\n      if (isValidCustomElementName(container)) {\n        this.#renderCustomElements = true\n      }\n      else {\n        if (!selectorEndsWithId(container)) {\n          this.#selectorNonId = container\n        }\n\n        const nodeList = (isSr)\n          ? [window.document.createElement('#container')]\n          : window.document.querySelectorAll(container)\n\n        this.#containerDOMElements = Array.from(nodeList)\n\n        if (!this.#containerDOMElements) {\n          throw new Error(`Could not find an element by the following query: ${container}`)\n        }\n      }\n    }\n    else if (container instanceof HTMLElement) {\n      this.#containerDOMElements = [container]\n    }\n    else if (\n      container instanceof NodeList\n      || container instanceof HTMLCollection\n    ) {\n      this.#containerDOMElements = Array.from(container)\n    }\n    else if (container instanceof Array) {\n      for (const element of container) {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('All elements in the input array must be DOM elements')\n        }\n      }\n\n      this.#containerDOMElements = container\n    }\n\n    return true\n  }\n\n  /**\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTemplates(templates) {\n    if (this.template instanceof Function) {\n      this.state = (this.state)\n        ? state(this.state)\n        : this.state\n\n      this.#templates.push(this.template.bind(this))\n    }\n\n    for (let template of templates) {\n      if (\n        !(template instanceof Function)\n        && !(template instanceof Component)\n      ) {\n        throw new Error('The template must be a function')\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Translation[]} translations\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTranslations(translations) {\n    if (!(translations instanceof Array)) {\n      throw new Error('The argument \\'translations\\' must be an Array')\n    }\n\n    this.#translations = translations\n\n    return true\n  }\n\n  /**\n   * @param { string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {boolean} clearContainers\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #render(container, window, clearContainers = true, htmlOptions = {}) {\n    this.#init(container, window, this.#translations, this.#templates)\n\n    if (clearContainers) {\n      this.#clearContainerElements()\n    }\n\n    const templates = this.#templates\n    const translations = this.#translations\n\n    if (!window) {\n      throw new Error('Missing window element')\n    }\n\n    if (this.#renderCustomElements) {\n      // Custom Elements\n\n      // Already defined?\n      if (customElements.get(this.#selector)) {\n        // Re-render all custom element\n        const customElements = document.getElementsByTagName(this.#selector)\n\n        for (const customElement of customElements) {\n          this.#renderElements(window, customElement.shadowRoot, templates, translations, htmlOptions)\n        }\n\n        return\n      }\n\n      /**\n       * @param {Component} component\n       * @returns {CustomElementConstructor}\n       */\n      const getCustomElementConstructor = (component) => {\n        return class extends HTMLElement {\n          constructor() {\n            super()\n            this.attachShadow({ mode: 'open' })\n          }\n\n          connectedCallback() {\n            if (!this.shadowRoot) {\n              throw new Error('Missing shadow root')\n            }\n\n            component.#renderElements(window, this.shadowRoot, templates, translations, htmlOptions)\n          }\n\n          disconnectedCallback() {\n            component.clear()\n          }\n        }\n      }\n\n      customElements.define(\n        this.#selector,\n        getCustomElementConstructor(this),\n      )\n    }\n    else {\n      // DOM or SrDOM\n\n      if (this.#selectorNonId) {\n        const domObserver = new MutationObserver((mutationList) => {\n          for (const mutation of mutationList) {\n            const addedNodes = mutation.addedNodes\n\n            for (let node of addedNodes) {\n              // we track only elements, skip other nodes (e.g. text nodes)\n              if (!(node instanceof HTMLElement)) continue\n\n              // check the inserted element for being a code snippet\n              if (node.matches(this.#selectorNonId)) {\n                this.#renderElements(window, node, templates, translations, htmlOptions)\n              }\n\n              // or maybe there's a code snippet somewhere in its subtree?\n              // for (let containerElement of node.querySelectorAll(this.#selectorNonId)) {\n              //   this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n              // }\n            }\n\n            const removedNodes = mutation.removedNodes\n\n            for (let node of removedNodes) {\n              this.#clearForContainer(node)\n            }\n          }\n        })\n\n        domObserver.observe(\n          document.body,\n          { attributes: false, childList: true, characterData: false, subtree: true },\n        )\n      }\n\n      if (this.#containerDOMElements.length === 0) {\n        this.#renderElements(window, null, templates, translations, htmlOptions)\n      }\n      else {\n        for (const containerElement of this.#containerDOMElements) {\n          // @ts-ignore\n          this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Window} window\n   * @param {Element | ShadowRoot | null} container\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} translations\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #renderElements(window, container, templates, translations, htmlOptions = {}) {\n    const creator = new ElementsCreator(\n      window, container, templates, translations,\n    )\n    creator.render()\n\n    this.#finalHtmlCode = creator.getHtmlCode(htmlOptions)\n    this.#finalElements.push(creator.getCreatedElements())\n  }\n}\n\nexport { Component }\n","import { isBrowserEnvironment } from './functions.js'\n\n/**\n * TODO make it work for server environment\n *\n * @returns {string}\n */\nconst getLocale = function () {\n  let locale = 'en'\n\n  if (isBrowserEnvironment()) {\n    const html = document.getElementById('html')\n\n    locale = html?.getAttribute('lang') ?? locale\n  }\n\n  return locale\n}\n\n/**\n * @param {string} defaultPath\n * @param {string} locale\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createSingleTranslation = async function (defaultPath, locale) {\n  if (typeof defaultPath !== 'string') {\n    throw new Error('Translation path must be a string')\n  }\n\n  let translation = null\n\n  /**\n   * Matches on /path/to/filename.ext\n   * [1] /path/to/\n   * [2] filename\n   * [3] .ext\n   *\n   * @type {RegExpMatchArray | null}\n   */\n  const match = defaultPath.match(/^(.*?)([^.\\/\\\\]+)(.\\w+)$/m)\n\n  if (match === null) {\n    throw new TypeError(`Incorrect path: ${defaultPath}`)\n  }\n\n  const filePath = match[1] + locale + match[3]\n\n  try {\n    translation = (await import(/* @vite-ignore */ filePath)).default\n  }\n  catch (e) {\n    if (filePath !== defaultPath) {\n      translation = (await import(/* @vite-ignore */ defaultPath)).default\n    }\n  }\n\n  if (!(translation instanceof Object)) {\n    throw new TypeError(`Translation at ${filePath} must export an object`)\n  }\n\n  return translation\n}\n\n/**\n * @param {...string} defaultPaths\n * @returns {Promise<Translation[]>}\n * @throws\n */\nconst fetchTranslations = async function (...defaultPaths) {\n  const locale = getLocale()\n\n  const promises = []\n\n  for (let path of defaultPaths) {\n    promises.push(createSingleTranslation(path, locale))\n  }\n\n  return Promise.all(promises)\n}\n\nexport { fetchTranslations }\n","import { Component } from './Component.js'\nimport { state } from './state.js'\nimport { fetchTranslations } from './Translation.js'\nimport { symTemplateFunction } from './constants.js'\n\n/**\n * @param {...(Template | Template[] | Component | Component[])} from\n * @returns {Component}\n */\nfunction component(...from) {\n  return new Component().useTemplates(...from)\n}\n\n/**\n * Returns the input function, but marked to be used easily in Paintor\n *\n * @param {Template} from\n * @returns {Template}\n */\nfunction template(from) {\n  /**\n   * Mark the function, so it can be recognized later\n   * as a Template function\n   */\n  // @ts-ignore\n  from[symTemplateFunction] = true\n\n  return from\n}\n\n/**\n * @param {Function} func\n * @returns {boolean}\n */\nfunction isTemplate(func) {\n  return (func instanceof Function) && (symTemplateFunction in func)\n}\n\nconst paintor = { component, state, isTemplate, template, fetchTranslations, Component }\n\nexport default paintor\nexport { paintor, component, state, isTemplate, template, fetchTranslations, Component }\n"],"file":"paintor.js"}