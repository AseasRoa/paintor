{"version":3,"file":"paintor.js","sources":["../src/ElementsCollector.js","../src/symbols.js","../src/StateSubscriptions.js","../src/State.js","../src/functions.js","../src/htmlTags.js","../src/HtmlTemplateParser/HtmlTemplateParserElement.js","../src/HtmlTemplateParser/constants.js","../src/HtmlTemplateParser/HtmlTemplateParser.js","../src/ElementsCreator.js","../src/SrDOM/constants.js","../src/SrDOM/exceptions/DOMException.js","../src/SrDOM/Node.js","../src/SrDOM/Comment.js","../src/SrDOM/Text.js","../src/SrDOM/functions.js","../src/SrDOM/Element.js","../src/SrDOM/HTMLElement.js","../src/SrDOM/DocumentFragment.js","../src/SrDOM/Document.js","../src/SrDOM/Window.js","../src/Paintor.js","../src/Translation.js","../src/index.js"],"sourcesContent":["/**\n * This class has an array where HTML elements are stored.\n * The class methods provide an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type {Node[]} */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   *\n   * @param {Node} element\n   */\n  addElement(element) {\n    if (element) this.elements.push(element)\n  }\n\n  /**\n   * Add multiple elements to the array of collected elements\n   *\n   * @param {Node[]} elements\n   */\n  addElements(elements) {\n    for (let element of elements) {\n      this.elements.push(element)\n    }\n  }\n\n  /**\n   * Returns the array of collected elements\n   *\n   * @returns {Node[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   *\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements) {\n      this.addElement(element)\n    }\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements = []\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   *\n   * @param {Node[]} elements\n   */\n  removeTheseElements(elements) {\n    if (elements.length > 0) {\n      this.elements = this.elements.filter(\n        (element) => !(elements.includes(element)),\n      )\n    }\n  }\n}\n\nexport { ElementsCollector }\n","export const symSubscribe = Symbol('symSubscribe')\nexport const symSubscribed = Symbol('symSubscribed')\n\nexport const symStateId    = Symbol('symStateId')\n\nexport const symArrayAccess  = Symbol('symArrayAccess')\nexport const symObjectAccess = Symbol('symObjectAccess')\n","import { setElementAttrOrProp, modifyStyleRule } from './functions.js'\nimport { symArrayAccess, symObjectAccess } from './symbols.js'\n\n/** @typedef {Object<*,*>} StateProxy */\n\n/**\n * @type {{\n *   element: null | Element | Comment,\n *   propertyName: string,\n *   subPropertyName: string,\n *   bindFunction: null | BindFunction,\n *   statementRepaintFunction: null | StatementRepaintFunction\n * }}\n */\nlet suggestedItems = {\n  element: null,\n  propertyName: '',\n  subPropertyName: '',\n  bindFunction: null,\n  statementRepaintFunction: null,\n}\n\n/**\n * This function should be called just before calling the bindFunction. The idea is\n * that the bindFunction, along with its html element and property name are suggested\n * here to the proxy handler. When the bindFunction is called, any state used in it\n * would trigger the proxy get event, which means that it will be added to the subscriptions.\n *\n * @param {Element | Comment} element\n * @param {string} propertyName\n * @param {string} subPropertyName\n * @param {BindFunction} bindFunction\n * @param {StatementRepaintFunction | null} statementRepaintFunction\n */\nfunction setSuggestItems(\n  element,\n  propertyName,\n  subPropertyName,\n  bindFunction,\n  statementRepaintFunction,\n) {\n  suggestedItems.element = element\n  suggestedItems.propertyName = propertyName\n  suggestedItems.subPropertyName = subPropertyName\n  suggestedItems.bindFunction = bindFunction\n  suggestedItems.statementRepaintFunction = statementRepaintFunction\n}\n\n/**\n * Reset the suggested items\n *\n * @returns {void}\n */\nfunction unsetSuggestedItems() {\n  suggestedItems = {\n    element: null,\n    propertyName: '',\n    subPropertyName: '',\n    bindFunction: null,\n    statementRepaintFunction: null,\n  }\n}\n\nclass StateSubscriptions {\n  /** @type {Map<string | symbol, Subscription[]>} */\n  #subscriptions = new Map()\n\n  /** @type {State} */\n  #state = {}\n\n  /**\n   * @param {State} state\n   * @param {string | symbol} stateProp\n   * @param {Element | Comment} element\n   * The HTML element for which the other parameters apply.\n   * @param {string} propertyName\n   * The name of the property of the HTML element, for\n   * which the subscription is going to be created.\n   * For example: 'style', 'value', 'textContent', 'innerHTML'.\n   * Also, '--if' for IF statement.\n   * @param {string} subPropertyName\n   * If the property name is 'style', the sub-property could be\n   * any style property.\n   * For example: 'fontSize'\n   * @param {BindFunction} bindFunction\n   * The function that is used instead of a fixed value.\n   * For example: () => (state.clicks)\n   * @param {StatementRepaintFunction | null} statementRepaintFunction\n   * This is only used in the if() function. It's a function that\n   * is used to repaint the elements in case the condition is changed\n   * from false to true or vice versa.\n   */\n  subscribe(\n    state,\n    stateProp,\n    element,\n    propertyName,\n    subPropertyName,\n    bindFunction,\n    statementRepaintFunction,\n  ) {\n    if (propertyName === '-s-if' || propertyName === '-s-forEach') {\n      stateProp = propertyName\n    }\n\n    if (!this.#subscriptions.has(stateProp)) {\n      this.#subscriptions.set(stateProp, [])\n    }\n\n    const subscriptions\n            = this.#subscriptions.get(stateProp) ?? []\n\n    // Search for a subscription with the same parameters.\n    // If such already exists, just don't create a new one.\n    for (const item of subscriptions) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementRepaintFunction === statementRepaintFunction\n      ) return\n    }\n\n    subscriptions.push({\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementRepaintFunction,\n    })\n\n    // Put a mark on the element itself, telling that it\n    // has a subscription\n    Object.assign(element, { '--subscribed': true })\n  }\n\n  /**\n   * Remove any subscriptions that the element is subscribed to\n   *\n   * @param {Node} element\n   */\n  unsubscribe(element) {\n    this.#subscriptions.forEach((subscription, key) => {\n      this.#subscriptions.set(key, subscription.filter((item) => (item.element !== element)))\n    })\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * The input object that will be used to create\n   * a proxy object with the same keys and values.\n   * @param {string} [statePath]\n   * The path to the state:\n   * <br>\n   * - If the state is the parent state, this is an empty string.\n   * <br>\n   * - If the state is a child state, this is the path to it (dot notated).\n   * @returns {T}\n   */\n  createProxy(object, statePath = '') {\n    const handler = this.#createProxyHandler()\n    const proxy = new Proxy(object, handler)\n\n    // Store the path to the state in a special value in the\n    // proxy object, but make that value invisible for \"for\"\n    // (and similar) statements.\n    // Object.defineProperty(proxy, '--state-path', {\n    //   enumerable: false,\n    //   configurable: false,\n    //   writable: false,\n    //   value: statePath,\n    // })\n\n    // Recursive proxy. To find all inner objects\n    // and turn them into child states.\n    for (const key in proxy) {\n      if (!(proxy[key] instanceof Object)) {\n        continue\n      }\n\n      const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n      proxy[key] = this.createProxy(proxy[key], innerStatePath)\n    }\n\n    this.#state = proxy\n\n    return proxy\n  }\n\n  /**\n   * This is called when \"length\" of an array is changed, which\n   * happens when elements are being added or popped from the end\n   * of the array. Not when delete is being used!\n   *\n   * @param {any[]} updatedState\n   */\n  #onArrayLengthChange(updatedState) {\n    const subscription = this.#subscriptions.get('-s-forEach')\n\n    if (subscription) {\n      subscription.forEach((listItem) => {\n        const { statementRepaintFunction } = listItem\n\n        if (statementRepaintFunction instanceof Function) {\n          statementRepaintFunction(updatedState)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreateOrDelete(updatedState, prop) {\n    const subscription = this.#subscriptions.get('-s-forEach')\n\n    if (subscription) {\n      subscription.forEach((listItem) => {\n        const { statementRepaintFunction } = listItem\n\n        if (statementRepaintFunction instanceof Function) {\n          statementRepaintFunction(updatedState)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreate(updatedState, prop) {\n    this.#onPropCreateOrDelete(updatedState, prop)\n  }\n\n  /**\n   * @param {State} target\n   * @param {string | symbol} prop\n   */\n  #onPropUpdate(target, prop) {\n    if (this.#subscriptions.has(prop)) {\n      const list = this.#subscriptions.get(prop) ?? []\n\n      list.forEach((listItem) => {\n        const {\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementRepaintFunction,\n        } = listItem\n\n        if (Object.hasOwn(element, '--deleted')) {\n          this.unsubscribe(element)\n\n          return\n        }\n\n        let result = bindFunction.call(element, element)\n\n        if (propertyName === 'style' && subPropertyName) {\n          // @ts-ignore\n          element.style[subPropertyName]\n              = modifyStyleRule(subPropertyName, result)\n        }\n        else if (\n          propertyName === '--if'\n          || propertyName === '--for'\n        ) {\n          if (statementRepaintFunction instanceof Function) {\n            statementRepaintFunction(result)\n          }\n        }\n        else {\n          /**\n           * @see Remark \"() => value\"\n           */\n          if (result instanceof Function) {\n            result = result()\n          }\n\n          // @ts-ignore\n          setElementAttrOrProp(element, propertyName, result)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropDelete(updatedState, prop) {\n    this.#onPropCreateOrDelete(updatedState, prop)\n  }\n\n  /**\n   * @returns {ProxyHandler<StateProxy>}\n   */\n  #createProxyHandler() {\n    /** @type {ProxyHandler<StateProxy>} */\n    const handler = {}\n\n    handler.get = (target, prop, receiver) => {\n      /**\n       * Why is hasOwn() needed?\n       * If the state is for example an array and its whole value is read,\n       * then JS tries to read few extra properties first - map, length, constructor\n       */\n      if (\n        Object.hasOwn(target, prop)\n        || prop === symObjectAccess\n        || prop === symArrayAccess\n      ) {\n        /**\n         * In the if below it would be enough to check just one element,\n         * but because of TS more than one is checked\n         */\n        if (\n          suggestedItems.element\n          && suggestedItems.bindFunction\n        ) {\n          this.subscribe(\n            target,\n            prop,\n            suggestedItems.element,\n            suggestedItems.propertyName,\n            suggestedItems.subPropertyName,\n            suggestedItems.bindFunction,\n            suggestedItems.statementRepaintFunction,\n          )\n        }\n      }\n      // Internal functions of Set() and Map()\n      else if (\n        (target instanceof Map || target instanceof Set)\n        // @ts-ignore\n        && target[prop] instanceof Function\n      ) {\n        /**\n         * @see https://stackoverflow.com/questions/48452885/observe-changes-to-a-map-using-a-proxy\n         */\n\n        // @ts-ignore\n        const fn = target[prop]\n\n        /**\n         * @param {any[]} args\n         * @returns {*}\n         */\n        const boundFunction = (...args) => {\n          const result = fn.apply(target, args)\n\n          if (target instanceof Set) {\n            if (prop === 'add') {\n              this.#onPropCreate(target, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(target, prop)\n            }\n          }\n          else if (target instanceof Map) {\n            if (prop === 'set') {\n              this.#onPropCreate(target, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(target, prop)\n            }\n          }\n\n          return result\n        }\n\n        return boundFunction\n      }\n\n      return target[prop]\n    }\n\n    handler.set = (target, prop, value) => {\n      // Array's length is set every time after\n      // adding or removing elements\n      if (target instanceof Array && prop === 'length') {\n        target[prop] = value\n\n        this.#onArrayLengthChange(target)\n      }\n      else if (Object.hasOwn(target, prop)) {\n        target[prop] = value\n\n        this.#onPropUpdate(target, prop)\n      }\n      else {\n        target[prop] = value\n\n        this.#onPropCreate(target, prop)\n      }\n\n      return true\n    }\n\n    /**\n     * Trap for the delete operator. This trap can intercept these operations:\n     *  - delete proxy[foo] and delete proxy.foo\n     *  - Reflect.deleteProperty()\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty\n     * @param {StateProxy} target\n     * @param {string | symbol} prop\n     * @returns {boolean}\n     * A Boolean indicating whether the property has been successfully deleted.\n     */\n    handler.deleteProperty = (target, prop) => {\n      delete target[prop]\n\n      this.#onPropDelete(target, prop)\n\n      return true\n    }\n\n    return handler\n  }\n}\n\nexport { StateSubscriptions, setSuggestItems, unsetSuggestedItems }\n","import { StateSubscriptions } from './StateSubscriptions.js'\nimport { symStateId } from './symbols.js'\n\nlet stateIdCounter = 0\n\n/**\n * @template T\n * @param {T} object\n * Your input object or array\n * @returns {T}\n * A proxy object/array that looks the same as the input object/array\n */\nconst createState = function createState(object) {\n  if (!(object instanceof Object)) {\n    throw new Error('createState() only accepts Object, Array, Set or Map as input value.')\n  }\n\n  const stateSubscriptions = new StateSubscriptions()\n  const proxy = stateSubscriptions.createProxy(object)\n\n  stateIdCounter += 1\n  // @ts-ignore\n  proxy[symStateId] = stateIdCounter\n\n  return proxy\n}\n\n/**\n * @param {Object<*,*>} object\n * @returns {boolean}\n */\nconst isState = function (object) {\n  return (object instanceof Object) && (symStateId in object)\n}\n\nexport { createState, isState }\n","import { isState } from './State.js'\nimport { symArrayAccess, symObjectAccess } from './symbols.js'\n\n/**\n * @see https://github.com/purposeindustries/window-or-global/blob/master/lib/index.js\n * @returns {Window | any}\n */\nexport function getGlobalObject() {\n  return (typeof self === 'object' && self.self === self && self)\n    || (typeof global === 'object' && global.global === global && global)\n    // @ts-ignore\n    || this\n}\n\n/**\n * @see https://github.com/tmpfs/format-util/blob/master/format.js\n * @param {string} fmt\n * @param {...any[]} args\n * @returns {string}\n */\nexport function format(fmt, ...args) {\n  const re = /(%?)(%([ojdsif]))/g\n\n  if (args.length > 0) {\n    /**\n     * @param {string} match\n     * @param {string} escaped % (for %%) or null (for anything else)\n     * @param {string} ptn %o or %s or whatever\n     * @param {string} flag The s from %s\n     * @returns {string}\n     */\n    const replacer = (match, escaped, ptn, flag) => {\n      let arg = args.shift()\n      let out = ''\n\n      switch (flag) {\n        case 'o':\n          if (Array.isArray(arg)) {\n            out = JSON.stringify(arg)\n          }\n          break\n        case 's':\n          out = '' + arg\n          break\n        case 'd':\n          out = '' + Number(arg)\n          break\n        case 'j':\n          out = JSON.stringify(arg)\n          break\n        case 'i':\n          out = '' + parseInt('' + arg, 10)\n          break\n        case 'f':\n          out = '' + parseFloat('' + arg)\n          break\n      }\n\n      if (!escaped) {\n        return out\n      }\n\n      // @ts-ignore\n      args.unshift(out)\n\n      return match\n    }\n\n    fmt = fmt.replace(re, replacer)\n  }\n\n  // arguments, remained after the formatting\n  if (args.length > 0) {\n    fmt += ' ' + args.join(' ')\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%')\n\n  return '' + fmt\n}\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @returns {boolean}\n */\nexport function isBrowserEnvironment() {\n  if (isBrowserEnvironment.isIt === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n    isBrowserEnvironment.isIt = isBrowser()\n  }\n\n  return isBrowserEnvironment.isIt ?? false\n}\n\n/**\n * The environment doesn't change over time, so it's enough\n * to determine it once. This variable is used to store the\n * environment, it's a cache.\n *\n * @type {undefined | boolean}\n */\nisBrowserEnvironment.isIt = undefined\n\n/**\n * @template T\n * @param {T} inputChild\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildToStack(inputChild, childrenStack) {\n  childrenStack.push(inputChild)\n\n  return childrenStack\n}\n\n/**\n * @template T\n * @param {T[]} inputChildren\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren) {\n    childrenStack.push(child)\n  }\n\n  return childrenStack\n}\n\n/**\n * @param {string} attributeName\n * @returns {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {string} char\n * @returns {boolean}\n */\nexport function isWhitespace(char) {\n  return (\n    char === ' '\n    || char === '\\t'\n    || char === '\\r'\n    || char === '\\n'\n  )\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function isValidCustomElementName(name) {\n  return /^[a-z][a-z0-9-]+$/.test(name) && name.includes('-')\n}\n\n/**\n * Turns a string into boolean.\n * Covers the cases when the string is 'true', 'false' or a number.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexport function stringToBoolean(string) {\n  if (string === 'true') return true\n\n  if (string === 'false') return false\n\n  const int = parseInt(string)\n\n  return (isNaN(int)) ? Boolean(string) : Boolean(int)\n}\n\n/**\n * @param {Element} element\n * @param {string} attributeName\n * @param {EventListenerOrEventListenerObject} callback\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof window.Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  const eventSmallName = attributeName.toLowerCase().substring(2)\n\n  element.addEventListener(eventSmallName, callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n *\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  }\n  else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child) {\n        fragment.append(child)\n      }\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child) {\n      element.appendChild(child)\n    }\n  }\n}\n\n/**\n * @param {Node | null} element\n * The element in which to append the children\n * @param {Node[]} children\n * The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (!element) return\n\n  if (isBrowserEnvironment() && element instanceof window.Node) {\n    appendDOMChildrenToElement(element, children)\n  }\n  else {\n    appendVirtualChildrenToElement(element, children)\n  }\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values\n * and the \"handler\" function is looped once for each pair.\n * The loop breaks if \"false\" is returned by the \"handler\"\n * function.\n *\n * @template T\n * @param {Array<T> | Object<string | number, T> | Map<string | number, T>} data\n * @param {ForLoopCallback<T>} handler\n * @param {(key: number | string) => void} [beforeIterationCallback]\n * @param {string | number | symbol} [keyToRender]\n * @param {(key: number | string) => void} [iterationCallback]\n * @returns {boolean}\n * @throws {TypeError}\n */\nexport function forEachLoop(\n  data,\n  handler,\n  beforeIterationCallback,\n  keyToRender,\n  iterationCallback,\n) {\n  if (\n    !(data instanceof Object)\n    && !(data instanceof Array)\n    && !(data instanceof Map)\n    && !(data instanceof Set)\n  ) {\n    throw new TypeError('\"data\" argument should be an Object or an Array')\n  }\n\n  if (!(handler instanceof Function)) {\n    throw new TypeError('\"handler\" argument should be a Function')\n  }\n\n  const isProxy = isState(data)\n\n  if (\n    data instanceof Map\n    || data instanceof Set\n  ) {\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const [key, value] of data.entries()) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let val = isProxy ? () => value : value\n\n      if (beforeIterationCallback) {\n        val = beforeIterationCallback?.(val)\n      }\n\n      const ret = handler(val, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Array) {\n    /**\n     * for-in doesn't work properly in this case,\n     * because the numeric index turns into string.\n     * That's why use the classic for loop is used.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    const nothing = isProxy ? data[symArrayAccess] : undefined\n\n    for (let key = 0; key < data.length; key++) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Object) {\n    /**\n     * The Object loop must be at the end,\n     * because Array, Set and Map are also Object.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const key in data) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {ForLoopIterableCallback} handler\n * @returns {boolean | Error}\n */\nexport function forLoop(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number') {\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n  }\n\n  if (!(handler instanceof Function)) {\n    return new Error('\"handler\" argument should be a Function')\n  }\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} key\n * @returns {T[]}\n */\nexport function arrayRemoveKey(arr, key) {\n  return arr.filter(function (el, index) {\n    return index !== key\n  })\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {T} value\n * @returns {T[]}\n */\nexport function arrayRemoveValue(arr, value) {\n  return arr.filter(function (el) {\n    return el !== value\n  })\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n *\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  if (!existingNode) return\n\n  const { nextSibling, parentNode } = existingNode\n\n  if (parentNode) {\n    parentNode.insertBefore(newNode, nextSibling)\n  }\n}\n\n/**\n *\n * @param {HTMLElement} element\n * @param {Object<string, (string | number | boolean)>}dataSet\n */\nexport function setDataSetAttributesToElement(element, dataSet) {\n  if (dataSet instanceof Object) {\n    for (const key in dataSet) {\n      const value = dataSet[key].toString()\n\n      element.setAttribute(`data-${key}`, value)\n    }\n  }\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends on the name of the attribute or property.\n *\n * @param {Element} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    if (value instanceof Array) {\n      // @ts-ignore\n      element[attrOrPropName] = format.apply(null, value)\n    }\n    else {\n      // @ts-ignore\n      element[attrOrPropName] = value\n    }\n  }\n  else {\n    element.setAttribute(attrOrPropName, value)\n  }\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n *\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function modifyStyleRule(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {HTMLElement}\n */\nexport function stringToHTML(str) {\n  const parser = new DOMParser()\n  const doc    = parser.parseFromString(str, 'text/html')\n\n  return doc.body\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {boolean}\n */\nexport function objectHasKey(object, key) {\n  if (object instanceof Map || object instanceof Set) {\n    return object.has(key)\n  }\n  else {\n    return (key in object)\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {any}\n */\nexport function objectGetValue(object, key) {\n  if (object instanceof Map) {\n    return object.get(key)\n  }\n  else if (object instanceof Set) {\n    return object.has(key) ? key : undefined\n  }\n  else {\n    return object[key]\n  }\n}\n\n// /**\n//  * @template K, T\n//  * @param {T[] | Object<K, T> | Map<K, T> | Set<T>} input\n//  * @param {(value: T, key: K) => boolean} callback\n//  */\n// export function forEach(input, callback) {\n//   if (input instanceof Set) {\n//     for (const value of input) {\n//       if (callback(value, value) === false) break\n//     }\n//   }\n// }\n//\n// const set = new Set(['One', 'Two', 'Three'])\n//\n// forEach(set, (value, key) => {\n//   console.log(key, value)\n// })\n//\n// const obj = { a: 'a' }\n//\n// for (const o of obj) {\n//   console.log(o)\n// }\n","/**\n * For each of the following tags a method will be created in the class below\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n * @see https://www.w3schools.com/tags/\n * @type {string[]}\n */\nconst htmlTags = [\n  'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', // 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n]\n\nexport { htmlTags }\n","class HtmlTemplateParserElement {\n  tagName = '-'\n\n  /** @type {HtmlTemplateParserElement} */\n  parent = this\n\n  /** @type {HtmlTemplateParserElement[]} */\n  children = []\n\n  /** @type {Object<string, any>} */\n  attributes = {}\n\n  /**\n   * Create a new instance of this class, but also put it\n   * into the list of children of the current instance\n   *\n   * @param {HtmlTemplateParserElement} parent\n   * @param {Object<string, any>} attributes\n   * @returns {HtmlTemplateParserElement}\n   */\n  newChild(parent, attributes) {\n    const child = new HtmlTemplateParserElement()\n\n    child.parent = parent\n    child.attributes = attributes\n\n    this.children.push(child)\n\n    return child\n  }\n}\n\nexport { HtmlTemplateParserElement }\n","/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n","import { isWhitespace, stringToBoolean } from '../functions.js'\nimport { HtmlTemplateParserElement } from './HtmlTemplateParserElement.js'\nimport { SELF_CLOSING_TAGS } from './constants.js'\n\n/**\n * This class is used to turn JS templates (containing HTML code) into\n * properly ordered Paintor functions.\n */\nclass HtmlTemplateParser {\n  #attrName = ''\n\n  /**\n   * The quote symbol in <...attr=\"value\"> - a single or a double quote.\n   * When the attribute has no quote, for example <...attr=123...>,\n   * the quote would be an empty space.\n   *\n   * @type {\"'\" | \"\\\"\" | \" \" | ''}\n   */\n  #attrQuote = ''\n\n  /** @type {any} */\n  #attrValue = ''\n\n  /** @type {Object<string, any>} */\n  #attributes = {}\n\n  /**\n   * Usually a string, but it could be function, boolean, number...\n   *\n   * @type {any}\n   */\n  #char\n\n  /** @type {any} */\n  #charPrevious\n\n  /** @type {any[]} */\n  #data = []\n\n  /**\n   * Would be set to the method that is going to be used for the next char iteration\n   *\n   * @type {() => void}\n   */\n  #stage = this.#stageNothing\n\n  #styleAttrName = ''\n\n  /** @type {any} */\n  #styleAttrValue = ''\n\n  /** @type {Object<string, any>} */\n  #styles = {}\n\n  #tagName = ''\n\n  #tagNameClosing = ''\n\n  #textContents = ''\n\n  /** @type {HtmlTemplateParserElement} */\n  #topElement = new HtmlTemplateParserElement()\n\n  /** @type {HtmlTemplateParserElement} */\n  #currentElement = this.#topElement\n\n  /**\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   */\n  constructor(strings, keys) {\n    this.#data = this.#mergeStringsAndKeys(strings, keys)\n\n    this.#rotate()\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @returns {(HTMLElement | Text)[]}\n   */\n  generate(elementsCreator) {\n    if (this.#tagName || this.#tagNameClosing) {\n      throw new Error('Some HTML tag is not closed')\n    }\n\n    const elements = this.#generateChildren(elementsCreator, this.#topElement)\n\n    return elements\n  }\n\n  /**\n   * @param {any} to\n   * @param {any} data\n   * @returns {any}\n   */\n  #appendData(to, data) {\n    if (typeof to === 'function') {\n      // The input is a function. In this case:\n      // If the data to append is also a function, return that function\n      // If the data to append is not a function, return the input\n      return (typeof data === 'function')\n        ? data\n        : to\n    }\n\n    return (\n      typeof to === 'string'\n      && (\n        typeof data === 'string'\n        || typeof data === 'number'\n        || typeof data === 'boolean'\n      )\n    )\n      ? to + data.toString()\n      : data\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @param {HtmlTemplateParserElement} element\n   * @returns {(HTMLElement | Text)[]}\n   */\n  #generateChildren(elementsCreator, element) {\n    /** @type {(HTMLElement | Text)[]} */\n    const output = []\n\n    for (const child of element.children) {\n      let el = null\n\n      if (child.tagName === 'if') {\n        el = elementsCreator.if(\n          stringToBoolean(child.attributes?.condition ?? ''),\n          () => this.#generateChildren(elementsCreator, child),\n        )\n      }\n      else if (child.tagName === 'for') {\n        if ('iterations' in child.attributes) {\n          el = elementsCreator.for(\n            0,\n            parseInt(child.attributes?.iterations ?? 0) - 1,\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n        else if ('from' in child.attributes || 'to' in child.attributes) {\n          el = elementsCreator.for(\n            parseInt(child.attributes?.from ?? 0),\n            parseInt(child.attributes?.to ?? 0),\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else if (child.tagName === 'forEach') {\n        if ('object' in child.attributes) {\n          el = elementsCreator.forEach(\n            child.attributes?.object ?? {},\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else {\n        el = elementsCreator.createElement(\n          child.tagName,\n          child.attributes,\n          this.#generateChildren(elementsCreator, child),\n        )\n\n        output.push(el)\n      }\n    }\n\n    return output\n  }\n\n  #makeNewElement() {\n    const parent = this.#currentElement\n    const attributes = this.#attributes\n\n    if (Object.keys(this.#styles).length > 0) {\n      attributes.style = this.#styles\n    }\n\n    const child = this.#currentElement.newChild(parent, attributes)\n\n    child.tagName = this.#tagName\n\n    this.#currentElement = child\n  }\n\n  /**\n   * JS Templates provide two arrays - a string array and keys array.\n   * This function is designed to merge these two into a single array.\n   *\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   * @returns {any[]}\n   */\n  #mergeStringsAndKeys(strings, keys=[]) {\n    const output = []\n\n    for (let index = 0; index < strings.length; index++) {\n      if (strings[index]) {\n        output.push(strings[index])\n      }\n\n      if (keys[index] !== undefined) {\n        output.push(keys[index])\n      }\n    }\n\n    return output\n  }\n\n  #rotate() {\n    for (\n      let dataIndex = 0;\n      dataIndex < this.#data.length;\n      dataIndex++\n    ) {\n      if (typeof this.#data[dataIndex] === 'string') {\n        for (\n          let charIndex = 0;\n          charIndex < this.#data[dataIndex].length;\n          charIndex++\n        ) {\n          this.#char         = this.#data[dataIndex][charIndex]\n          this.#charPrevious = this.#data[dataIndex][charIndex - 1]\n\n          // this.#char, this.#stage.name)\n\n          this.#stage()\n        }\n      }\n      else {\n        this.#char = this.#data[dataIndex]\n        this.#charPrevious = undefined\n\n        // console.log(this.#char, this.#stage.name)\n\n        this.#stage()\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setAttribute(name, value) {\n    if (!name) return\n\n    this.#attributes[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  /**\n   * @param {() => void} stage\n   */\n  #setStage(stage) {\n    // Actions to do before a given stage is set\n    if (stage === this.#stageAttrName) {\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n    }\n\n    // Set the stage\n    this.#stage = stage\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setStyle(name, value) {\n    if (!name) return\n\n    this.#styles[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  #stageAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '/') {\n      if (SELF_CLOSING_TAGS.includes(this.#tagName)) {\n        this.#makeNewElement()\n      }\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === '=') {\n      this.#setStage(this.#stageAttrOpenQuote)\n    }\n    else {\n      this.#attrName += this.#char\n    }\n  }\n\n  #stageAttrOpenQuote() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '\\'' || this.#char === '\"') {\n      this.#attrQuote = this.#char\n\n      this.#setStage(\n        (this.#attrName === 'style')\n          ? this.#stageStyleAttrName\n          : this.#stageAttrValue,\n      )\n    }\n    else {\n      // Value without quotes.\n      // Whitespaces are allowed before the value, but not after.\n      // For that reason, the quote would be a whitespace here\n\n      this.#attrQuote = ' '\n      this.#attrValue = this.#appendData(this.#attrValue, this.#char)\n\n      this.#setStage(this.#stageAttrValue)\n    }\n  }\n\n  #stageAttrValue() {\n    if (this.#char === '>' && this.#charPrevious !== '/') {\n      // When > is found, but the attribute wasn't closed properly.\n      // Could happen if the quote is an empty space, for example: <...attr=true>\n      // Or even unclosed quote, for example: <...attr=\"value>\n      if (this.#attrQuote && this.#attrName && this.#attrValue) {\n        this.#setAttribute(this.#attrName, this.#attrValue)\n      }\n\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n\n      this.#setStage(this.#stageNothing)\n\n      this.#makeNewElement()\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setAttribute(this.#attrName, this.#attrValue)\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#attrValue += this.#char\n    }\n  }\n\n  #stageNothing() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '<') {\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      // In HTML when there are multiple spaces before or after a text,\n      // only one could be visualized. So if\n      if (this.#charPrevious === ' ') {\n        this.#textContents = this.#charPrevious + this.#char\n      }\n      else {\n        this.#textContents = this.#char\n      }\n\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTextContents)\n    }\n  }\n\n  #stageStyleAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setStage(this.#stageAttrName)\n    }\n    else if (this.#char === ':') {\n      this.#setStage(this.#stageStyleAttrValue)\n    }\n    else {\n      this.#styleAttrName += this.#char\n    }\n  }\n\n  #stageStyleAttrValue() {\n    if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === ';') {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageStyleAttrName)\n    }\n    else if (this.#char === this.#attrQuote) {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#styleAttrValue = this.#appendData(this.#styleAttrValue, this.#char)\n    }\n  }\n\n  /**\n   * In this stage we have just detected \"<\" and we are in HTML tag.\n   * This tag could be a new tag, or it could be the closing tag.\n   *\n   * @returns {void}\n   */\n  #stageTag() {\n    if (isWhitespace(this.#char)) {\n      if (this.#tagName !== '') {\n        this.#setStage(this.#stageAttrName)\n      }\n    }\n    else if (this.#char === '/' && SELF_CLOSING_TAGS.includes(this.#tagName)) {\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      if (!this.#tagName) {\n        throw new Error('Expected tag name, found >')\n      }\n\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#charPrevious === '<' && this.#char === '/') {\n      if (!this.#tagName) {\n        //throw new Error('no tag name')\n      }\n\n      this.#tagNameClosing = ''\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else {\n      this.#tagName += this.#char\n    }\n  }\n\n  #stageTagToClose() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      if (\n        this.#currentElement.tagName // Empty if text node\n        && this.#currentElement.tagName !== '-'\n        && !SELF_CLOSING_TAGS.includes(this.#currentElement.tagName)\n        && this.#currentElement.tagName !== this.#tagNameClosing\n      ) {\n        throw new Error(`Expected ${this.#currentElement.tagName} tag to be closed, but ${this.#tagNameClosing} found`)\n      }\n\n      this.#tagName = ''\n      this.#tagNameClosing = ''\n\n      if (\n        !this.#currentElement.tagName // Text node\n      ) {\n        this.#currentElement = this.#currentElement.parent.parent\n      }\n      else {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#setStage(this.#stageNothing)\n    }\n    else {\n      this.#tagNameClosing += this.#char\n    }\n  }\n\n  #stageTextContents() {\n    if (this.#char === '<') {\n      // Reset what was possibly used for text node\n      this.#attributes = {}\n      this.#currentElement.attributes.textContent = this.#textContents\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      this.#textContents = this.#appendData(this.#textContents, this.#char)\n\n      if (!this.#currentElement.tagName) {\n        this.#currentElement.attributes.textContent = this.#textContents\n      }\n    }\n  }\n}\n\nexport { HtmlTemplateParser }\n","import { ElementsCollector } from './ElementsCollector.js'\nimport {\n  addChildrenToStack,\n  addChildToStack,\n  addEventListenerIfPossible,\n  appendChildrenToElement,\n  arrayRemoveKey,\n  forEachLoop,\n  forLoop,\n  format,\n  getGlobalObject,\n  insertAfter,\n  isEventAttribute,\n  modifyStyleRule,\n  objectHasKey,\n  setDataSetAttributesToElement,\n  setElementAttrOrProp,\n  stringToHTML,\n} from './functions.js'\nimport { htmlTags } from './htmlTags.js'\nimport { HtmlTemplateParser } from './HtmlTemplateParser/HtmlTemplateParser.js'\nimport { Paintor } from './Paintor.js'\nimport { isState } from './State.js'\nimport { setSuggestItems, unsetSuggestedItems } from './StateSubscriptions.js'\n\n/**\n * @typedef {Array<{key: (string | number | symbol), elements: (Node)[]}>} RenderedElementsMap\n */\n\nclass ElementsCreator {\n  /** @type {HTMLElement[]} */\n  finalElements = []\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {HTMLElement | ShadowRoot}\n   */\n  #containerElement\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the\n   * elements separately. Then, when the IF or FOR statement ends, the\n   * collected elements are moved to the upper level and that new level\n   * is deleted.\n   *\n   * @type {ElementsCollector[]}\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /** @type {HTMLTemplateElement} */\n  #dummyHtmlElement\n\n  /** @type {Document} */\n  #document\n\n  /** @type {Window} */\n  #window\n\n  /**\n   * Is String-Rendering mode\n   *\n   * @type {boolean}\n   */\n  #isSr = true\n\n  /** @type {Template[]} */\n  #templates = []\n\n  /**\n   * @param {Window} window\n   * @param {HTMLElement | ShadowRoot} containerElement\n   * @param {Template[]} templates\n   * @param {Translation[]} [translations=[]]\n   */\n  constructor(window, containerElement, templates, translations = []) {\n    this.#window = window\n    this.#document = window.document\n    this.#isSr = this.#document.baseURI === ''\n    this.#containerElement = containerElement\n    this.#templates = templates\n    this.#translations = translations\n\n    this.#dummyHtmlElement = this.#document.createElement('template')\n\n    for (const template of this.#templates) {\n      // @ts-ignore\n      const returnedValue = template(this)\n\n      if (returnedValue && typeof returnedValue === 'string') {\n        this.html(returnedValue)\n      }\n      else if (returnedValue instanceof Paintor) {\n        const generatedChildren = (this.#isSr)\n          ? returnedValue.getElementsSr()\n          : returnedValue.getElements()\n\n        this.#collectedElements[0].addElements(generatedChildren)\n      }\n      else if (returnedValue instanceof Function) {\n        // @ts-ignore\n        returnedValue(this)\n      }\n      else if (returnedValue instanceof Array) {\n        // Check if all elements are Paintor\n        let allPaintor = true\n\n        for (const value of returnedValue) {\n          if (!(value instanceof Paintor)) {\n            allPaintor = false\n\n            break\n          }\n        }\n\n        if (allPaintor) {\n          for (const value of returnedValue) {\n            if (!(value instanceof Paintor)) break\n\n            const generatedChildren = (this.#isSr)\n              ? value.getElementsSr()\n              : value.getElements()\n\n            this.#collectedElements[0].addElements(generatedChildren)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create HTML element\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * Different variants are possible:<br>\n   * - String value - It will be textContent of the element. Use this in div tags and similar.\n   * - Object value - For all the properties of the element, like \"id\", \"class\" and so on...\n   * - Element (multiple arguments) - For other calls of this same function (creating children)\n   * - Array - Alternative for creating children\n   * @returns {HTMLElement | Text}\n   */\n  createElement(tagName, ...args) {\n    const element = (tagName)\n      ? this.#document.createElement(tagName)\n      : this.#document.createTextNode('')\n\n    /** @type {any[]} */\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string') {\n        // In case of a string, create a new text node.\n        // This way, multiple text nodes can be put into the element,\n        // mixed with http elements.\n\n        const textNode = this.#document.createTextNode(\n          this.#translate(argument),\n        )\n\n        children = addChildToStack(textNode, children)\n      }\n      else if (typeof argument === 'number') {\n        // The number is converted into a string\n\n        const textNode = this.#document.createTextNode(argument.toString())\n\n        children = addChildToStack(textNode, children)\n      }\n      // @ts-ignore\n      else if (argument instanceof this.#window.Node) {\n        // This is a child, created by this function, to be appended to its parent\n        children = addChildToStack(argument, children)\n      }\n      else if (argument instanceof Array) {\n        if (argument.length === 0) {\n          continue\n        }\n\n        let isChildrenArray = false\n\n        for (const child of argument) {\n          if (\n            // @ts-ignore\n            child instanceof this.#window.Node // Node includes HTMLElement and Comment\n          ) {\n            isChildrenArray = true\n\n            break\n          }\n        }\n\n        // Case 1) Array, containing at least one child to be added to their parent\n        // In DOM, if some elements are not children, they are turned into strings,\n        // but the same produces error in SSR\n        if (isChildrenArray) {\n          children = addChildrenToStack(argument, children)\n        }\n        // Case 2) Array, containing string to be formatted\n        else {\n          const textNode = this.#document.createTextNode(\n            this.#arrayTranslateFormatTranslate(argument),\n          )\n\n          children = addChildToStack(textNode, children)\n        }\n      }\n      else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = this.#translate(argument.message)\n      }\n      else if (argument instanceof Paintor) {\n        if (0 && this.#isSr) {\n          //element.innerHTML = argument.getHtml()\n        }\n        else {\n          const generatedChildren = (this.#isSr)\n            ? argument.getElementsSr()\n            : argument.getElements()\n\n          for (const child of generatedChildren) {\n            children.push(child)\n          }\n        }\n      }\n      else if (argument instanceof Function) {\n        if (this.#isSr) {\n          // @ts-ignore\n          element.innerHTML = `(${argument.toString()})()`\n        }\n        else {\n          if (element instanceof HTMLScriptElement) {\n            const inlineScript = this.#document.createTextNode(`(${argument.toString()})()`)\n            element.appendChild(inlineScript)\n          }\n          else if (argumentID === 1) {\n            // It's the first argument and it's a function\n\n            const propsObject = ('value' in element)\n              ? { value: argument }\n              : { textContent: argument }\n\n            // @ts-ignore\n            this.#setPropertiesToElement(element, propsObject)\n          }\n        }\n      }\n      else if (\n        argument instanceof Object\n        && !(argument instanceof Function)\n        && argumentID === 1\n      ) {\n        // If Object and first argument, this is a property\n        // ! This condition needs to be at the end of the 'if' chain\n\n        // @ts-ignore\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].removeTheseElements(children)\n    this.#collectedElements[level].addElement(element)\n\n    return element\n  }\n\n  /**\n   * - Browser mode: Append the DOM elements at level 0 to the container element\n   * - Server mode: Generate HTML code of the elements at level 0\n   *\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   * - Browser mode: Empty string\n   * - Server mode: The final HTML code\n   */\n  finalPaint(htmlOptions) {\n    let finalHtmlCode = ''\n\n    const children = this.getCreatedElements()\n    const containerElement = this.#containerElement\n\n    if (containerElement) {\n      appendChildrenToElement(containerElement, children)\n    }\n\n    // @ts-ignore\n    this.finalElements = children\n\n    if (this.#isSr) {\n      const virtualContainer = containerElement\n\n      if (virtualContainer) {\n        // @ts-ignore\n        finalHtmlCode = virtualContainer.paintChildren(htmlOptions)\n      }\n    }\n\n    return finalHtmlCode\n  }\n\n  /**\n   * For loop with from-to numbers\n   *\n   * @param {number} from\n   * @param {number} to\n   * @param {ForLoopIterableCallback} handler\n   * @returns {Node[] | Error}\n   */\n  for(from, to, handler) {\n    const callback = () => {\n      const result = forLoop(from, to, handler)\n\n      if (result instanceof Error) console.error(result)\n    }\n\n    return this.#statementHandler('for', null, callback)\n  }\n\n  /**\n   * For loop for objects, arrays, maps and sets\n   *\n   * @template T\n   * @param {T | function() : T} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forEach(input, handler) {\n    /**\n     * @param {any} value\n     * @returns {any}\n     */\n    const beforeIterationCallback = (value) => {\n      return this.#translate(value)\n    }\n\n    if (isState(input)) {\n      /**\n       * @param {State} data\n       * @param {ElementsCollector} elementsCollector\n       * @param {string | number | symbol} [keyToRender]\n       * @returns {RenderedElementsMap}\n       */\n      const callbackForState = (data, elementsCollector, keyToRender) => {\n        /** @type {RenderedElementsMap} */\n        const renderedElementsMap = []\n\n        /**\n         * Initially there is 1 element - the forEach-begin element.\n         * We want to start after this element.\n         */\n        let index = elementsCollector.getElements().length\n\n        /**\n         * @param {number | string} key\n         */\n        const onIteration = (key) => {\n          const elementsFromCollector = elementsCollector.getElements()\n          const elements = elementsFromCollector.slice(index)\n\n          renderedElementsMap.push({ key, elements })\n\n          index = elementsFromCollector.length\n        }\n\n        forEachLoop(data, handler, beforeIterationCallback, keyToRender, onIteration)\n\n        return renderedElementsMap\n      }\n\n      return this.#statementHandlerForState('forEach', input, callbackForState)\n    }\n\n    /**\n     * @param {State} data\n     */\n    const callback = (data) => {\n      forEachLoop(data, handler, beforeIterationCallback)\n    }\n\n    if (input instanceof Function) {\n      // @ts-ignore\n      return this.#statementHandlerForFunction('forEach', input, callback)\n    }\n\n    return this.#statementHandler('forEach', input, callback)\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  getCreatedElements() {\n    const elements = this.#collectedElements[0].getElements()\n\n    // Reset\n    this.#collectedElements = [new ElementsCollector()]\n\n    return elements\n  }\n\n  /**\n   * @param {string[] | string} strings\n   * A string when html is used as a function, or an array of strings when used as template\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  html(strings, ...keys) {\n    const elements = (\n      keys.length === 0\n      && this.#translations.length === 0 // the faster method doesn't translate anything\n    )\n      ? this.#htmlForSimpleString((strings instanceof Array) ? strings[0] : strings)\n      : this.#htmlForTemplateLiteral((strings instanceof Array) ? strings : [strings], ...keys)\n\n    for (const element of elements) {\n      if (\n        // Dummy tag (virtual mode) when simple string, or text node when template literal\n        // In both cases the tag name is an empty string\n        // @ts-ignore\n        element.tagName === ''\n      ) {\n        element.textContent = this.#translate(element.textContent)\n      }\n    }\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   *\n   * @param {boolean | StatementBindFunction} condition\n   * @param {function():void} handler\n   * @param {function():void} [elseHandler]\n   * @returns {Node[]}\n   */\n  if(condition, handler, elseHandler) {\n    /**\n     * If the condition is a value (true or false), the elements\n     * are either created or not.\n     *\n     * If the condition is a function, two helper Comment elements\n     * are created - one in the beginning and another at the end.\n     * All normal elements are placed in between.\n     */\n\n    /**\n     * @param {any} data\n     */\n    const callback = (data) => {\n      if (Boolean(data)) {\n        if (typeof handler === 'function') {\n          handler()\n        }\n      }\n      else {\n        if (typeof elseHandler === 'function') {\n          elseHandler()\n        }\n      }\n    }\n\n    return (condition instanceof Function)\n      ? this.#statementHandlerForFunction('if', condition, callback)\n      : this.#statementHandler('if', condition, callback)\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler.\n   *\n   * @param {object} input\n   * @param {number} input.thisLevel\n   * @param {number} input.upperLevel\n   * @returns {Node[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n    this.#collectedElements[thisLevel].removeAllElements()\n\n    // ... and clean this level\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  /**\n   * @template T\n   * @param {T[]} array\n   * @returns {(string | T)[]}\n   */\n  #arrayTranslate(array) {\n    const needsTranslation = Boolean(this.#translations)\n\n    return (needsTranslation)\n      ? array.map((value) => this.#translate(value))\n      : array\n  }\n\n  /**\n   * This function first translations each part of the input array,\n   * then formats it, then translations the result.\n   *\n   * @template T\n   * @param {T[]} array\n   * The input array is supposed to be what would format() arguments be\n   * (format string plus multiple arguments), but as an array.\n   * @returns {string}\n   */\n  #arrayTranslateFormatTranslate(array) {\n    return this.#translate(\n      format.apply(\n        null,\n        // @ts-ignore\n        this.#arrayTranslate(array),\n      ),\n    )\n  }\n\n  /**\n   * Prepare the levels to be used in IF or FOR loop, and return them.\n   * This method must be called in the IF or FOR loop, before calling\n   * the handler.\n   *\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    const thisLevel = this.#collectedElements.length\n    const upperLevel = thisLevel - 1\n\n    this.#collectedElements.push(new ElementsCollector())\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * Quicker version for the 'html' function that does not use parsing,\n   * because the input is just a single string.\n   *\n   * @param {string} string\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForSimpleString(string) {\n    /** @type {(Element | Node)[]} */\n    let elements = []\n\n    if (this.#isSr) {\n      // We create a new dummy element every time.\n      // An element with no tag name is skipped in the render stage.\n      const element = this.#document.createElement('')\n\n      element.innerHTML = string ?? ''\n\n      elements = [element]\n    }\n    else {\n      if (false && 'DOMParser' in this.#document) {\n        // @ts-ignore\n        elements = stringToHTML(string.trim() ?? '').childNodes\n      }\n      else {\n        // In DOM, we can reuse the same element\n        const template = this.#dummyHtmlElement\n\n        //element.setHTML(string.trim() ?? '')\n        template.innerHTML = string.trim() ?? ''\n\n        // childNodes also contains the text nodes\n        elements = Array.from(template.content.childNodes)\n\n        template.innerHTML = ''\n      }\n    }\n\n    // Add the newly created elements into the collection\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].addElements(elements)\n\n    return elements\n  }\n\n  /**\n   * @param {string[]} strings\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForTemplateLiteral(strings, ...keys) {\n    const htmlTemplateParser = new HtmlTemplateParser(strings, keys)\n\n    // @ts-ignore\n    return htmlTemplateParser.generate(this)\n  }\n\n  /**\n   * @param {Comment} beginCommentElement\n   * @param {Node[]} elements\n   * @returns {boolean}\n   * Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginCommentElement, elements) {\n    if (!(this.#containerElement?.contains(beginCommentElement))) {\n      return false\n    }\n\n    /** @type {Node|Comment} */\n    let lastElement = beginCommentElement\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are a pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   *\n   * @param {Comment} beginCommentElement\n   * - The 'begin' Comment element\n   * @returns {number}\n   * - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginCommentElement) {\n    /**\n     * @type {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n     */\n    const COMMENT_NODE = 8 // Node.COMMENT_NODE\n\n    if (beginCommentElement.nodeType !== COMMENT_NODE) {\n      return -1\n    }\n\n    // Decide what will be the text content of the end element\n    const beginCommentElementText = beginCommentElement.textContent\n    let endElementText = ''\n\n    if (beginCommentElementText) {\n      endElementText = beginCommentElementText.slice(0, -6) + '-end'\n    }\n    else {\n      return -1\n    }\n\n    /**\n     * Delete elements between the 'begin' and 'end' element,\n     * including inner 'begin' and 'end' elements\n     */\n\n    let currentElement = beginCommentElement.nextSibling\n    let statementsCounter = 0\n    let deletedElementsCount = 0\n\n    while (true) {\n      if (currentElement === null) {\n        break\n      }\n\n      if (currentElement.nodeType === COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginCommentElementText) { // inner 'begin' element\n          statementsCounter += 1\n        }\n        else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0) {\n            break\n          }\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      this.#unsubscribeElementAndItsChildren(currentElement)\n\n      currentElement.remove()\n      deletedElementsCount += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElementsCount\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<string, string|number|Object<*,*>|function(*):*|BindFunction>} properties\n   */\n  #setPropertiesToElement(element, properties) {\n    for (const propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#isSr) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function) {\n          setElementAttrOrProp(element, propertyName, property)\n\n          continue\n        }\n      }\n      else if (property instanceof Function) {\n        // If the property name is an event (for example onClick),\n        // then the property is a function. This function should not\n        // be immediately called to get a value from it. Instead, it\n        // should be added as a listener.\n        if (addEventListenerIfPossible(element, propertyName, property)) {\n          continue\n        }\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        /** @type {BindFunction} */\n        const bindFunction = property\n\n        // this.#subscribeToBindings({\n        //   element,\n        //   propertyName,\n        //   bindFunction,\n        // })\n\n        setSuggestItems(\n          element,\n          propertyName,\n          '',\n          bindFunction,\n          null,\n        )\n\n        let value = bindFunction(element)\n\n        if (value instanceof Function) {\n          /**\n           * Remark \"() => value\"\n           *\n           * In forEach the value is provided as a function, so it is not necessary\n           * to use it like this () => value. However, when used like this, the function\n           * returns a function. Resolve the returned function here.\n           */\n          value = value()\n        }\n\n        unsetSuggestedItems()\n\n        if (value instanceof Array) {\n          value = this.#arrayTranslateFormatTranslate(value)\n        }\n        else if (typeof value === 'string') {\n          value = this.#translate(value)\n        }\n\n        setElementAttrOrProp(element, propertyName, value)\n      }\n      else if (propertyName === 'style' && property instanceof Object) {\n        this.#setStylesToElement(element, property)\n      }\n      else if (propertyName === 'data') {\n        if (property instanceof Object) {\n          setDataSetAttributesToElement(element, property)\n        }\n      }\n      else if (propertyName === 'textContent') {\n        if (property instanceof Array) {\n          element[propertyName] = this.#arrayTranslateFormatTranslate(property)\n        }\n        else {\n          element[propertyName] = this.#translate(property)\n        }\n      }\n      else {\n        setElementAttrOrProp(element, propertyName, this.#translate(property))\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<keyof CSSStyleDeclaration, (string | BindFunction)>} styleRules\n   */\n  #setStylesToElement(element, styleRules) {\n    for (const ruleName in styleRules) {\n      const ruleValue = styleRules[ruleName]\n      let finalValue  = ''\n\n      if (ruleValue instanceof Function) {\n        const propertyName = 'style'\n        const bindFunction = ruleValue\n\n        // this.#subscribeToBindings({\n        //   element,\n        //   propertyName,\n        //   subPropertyName: ruleName,\n        //   bindFunction,\n        // })\n\n        setSuggestItems(\n          element,\n          propertyName,\n          ruleName,\n          bindFunction,\n          null,\n        )\n\n        finalValue = bindFunction(element)\n\n        unsetSuggestedItems()\n      }\n      else {\n        finalValue = ruleValue\n      }\n\n      if (typeof ruleName === 'string') {\n        // @ts-ignore\n        element.style[ruleName] = modifyStyleRule(ruleName, finalValue)\n      }\n    }\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach'} type\n   * @param {any} data\n   * @param {function(any): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandler(type, data, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    callback(data)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach'} type\n   * @param {function(): any} bindFunction\n   * @param {function(boolean | State): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForFunction(type, bindFunction, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n    const isFunction = bindFunction instanceof Function\n\n    if (isFunction) {\n      const commentElementBegin = this.#document.createComment(`${type}-begin`)\n      const commentElementEnd   = this.#document.createComment(`${type}-end`)\n\n      this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n      /**\n       * @type {StatementRepaintFunction}\n       */\n      const statementRepaintFunction = (bindFunctionResult) => {\n        // Clean all contents.\n        this.#collectedElements[0].removeAllElements()\n        this.#removeStatementElements(commentElementBegin)\n\n        // Create the new elements\n        callback(bindFunctionResult)\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[0].getElements(),\n        )\n\n        if (!success) {\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n        }\n      }\n\n      const element = commentElementBegin\n      const propertyName = `--${type}` // --if or --for\n\n      setSuggestItems(\n        element,\n        propertyName,\n        '',\n        bindFunction,\n        statementRepaintFunction,\n      )\n\n      const resolved = bindFunction()\n\n      // TODO maybe this one should be below the callback below?\n      unsetSuggestedItems()\n\n      // Run the handler function\n      callback(resolved)\n\n      this.#collectedElements[thisLevel].addElement(commentElementEnd)\n    }\n    else {\n      const resolved = bindFunction\n\n      // Run the handler function\n      callback(resolved)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'forEach'} type\n   * @param {any} state\n   * @param {function(\n   *   State, ElementsCollector, (string | number | symbol)=\n   * ): RenderedElementsMap} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForState(type, state, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    const commentElementBegin = this.#document.createComment(`${type}-begin`)\n    /**\n     * Use the 'end' comment element as a storage for the rendered elements.\n     * It's easier this way, and if the element is being deleted along with\n     * the rendered elements, no references to these elements would remain.\n     *\n     * @type {Comment & {renderedElementsMap: RenderedElementsMap}}\n     */\n    // @ts-ignore\n    const commentElementEnd = this.#document.createComment(`${type}-end`)\n\n    this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n    /**\n     * TODO Refactor this function, because it's too long\n     *\n     * @type {StatementRepaintFunction} updatedState\n     */\n    const statementRepaintFunction = (updatedState) => {\n      if (!(updatedState instanceof Object)) {\n        return\n      }\n\n      // Remove what is not in the updated state\n      for (let i = commentElementEnd.renderedElementsMap.length - 1; i >= 0; i--) {\n        const item = commentElementEnd.renderedElementsMap[i]\n\n        if (!(objectHasKey(updatedState, item.key))) {\n          item.elements.forEach((element) => {\n            // @ts-ignore\n            element.remove()\n          })\n\n          commentElementEnd.renderedElementsMap\n            = arrayRemoveKey(commentElementEnd.renderedElementsMap, i)\n        }\n      }\n\n      /**\n       * @type {Node}\n       */\n      let lastElement = commentElementBegin\n\n      // Add what is not in the updated state\n      const renderedElementsMapNew = []\n\n      const keys = (\n        updatedState instanceof Map\n        || updatedState instanceof Set\n        || updatedState instanceof Array\n      )\n        ? updatedState.keys()\n        : Object.keys(updatedState)\n\n      for (let i of keys) {\n        /**\n         * When Array, if an element is deleted, the key remains and the\n         * value is undefined. But also, the array iterates differently\n         * when 'of' or 'in' is used. With 'of', the deleted value is iterated,\n         * while with 'if' it's not. That's why this 'in' is here, to prevent\n         * iteration of deleted array elements.\n         */\n        if (!(i in updatedState)) {\n          continue\n        }\n\n        let isKeyInRenderedElementsMap = false\n\n        for (const item of commentElementEnd.renderedElementsMap) {\n          if (item.key === i) {\n            const elements = item.elements\n\n            lastElement = (elements.length > 0)\n              ? elements[elements.length - 1]\n              : lastElement\n            renderedElementsMapNew.push(item)\n            isKeyInRenderedElementsMap = true\n\n            break\n          }\n        }\n\n        if (!isKeyInRenderedElementsMap) {\n          const added = callback(\n            updatedState,\n            this.#collectedElements[0],\n            i,\n          )\n\n          for (const item of added) {\n            renderedElementsMapNew.push(item)\n\n            // eslint-disable-next-line @typescript-eslint/no-loop-func\n            item.elements.forEach((element) => {\n              // @ts-ignore\n              lastElement.after(element)\n            })\n          }\n        }\n      }\n\n      commentElementEnd.renderedElementsMap = renderedElementsMapNew\n    }\n\n    const propertyName = `-s-${type}` // --if or --for\n    const bindFunction = () => state\n\n    setSuggestItems(\n      commentElementEnd,\n      propertyName,\n      '',\n      bindFunction,\n      statementRepaintFunction,\n    )\n\n    // In this callback the for loop is called\n    commentElementEnd.renderedElementsMap = callback(\n      state,\n      this.#collectedElements[thisLevel],\n    )\n\n    unsetSuggestedItems()\n\n    this.#collectedElements[thisLevel].addElement(commentElementEnd)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {any} input\n   * @returns {string}\n   */\n  #translate(input) {\n    if (typeof input === 'string') {\n      const translated = this.#translateString(input, this.#translations)\n\n      if (typeof translated === 'string') {\n        return translated\n      }\n\n      // Use the global translation\n      const globalObject = getGlobalObject()\n\n      const globallyTranslated = this.#translateString(\n        input,\n        // @ts-ignore\n        globalObject?.paintorTranslations,\n      )\n\n      if (typeof globallyTranslated === 'string') {\n        return globallyTranslated\n      }\n    }\n\n    return input\n  }\n\n  /**\n   * @param {string} str\n   * @param {Translation[]} [translations]\n   * @returns {string | boolean}\n   */\n  #translateString(str, translations) {\n    if (translations instanceof Array && translations.length > 0) {\n      for (const translateObject of translations) {\n        if (str in translateObject) {\n          return translateObject[str]\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Recursively search in an element's child nodes for\n   * elements, who are used in state subscriptions, and\n   * unsubscribe them. Also unsubscribe the initial element.\n   *\n   * Note: This function works only on the browser!\n   *\n   * @param {Node} element\n   */\n  #unsubscribeElementAndItsChildren(element) {\n    if (Object.hasOwn(element, '--subscribed')) {\n      Object.assign(element, { '--deleted': true })\n    }\n\n    element.childNodes.forEach(\n      (child) => this.#unsubscribeElementAndItsChildren(child),\n    )\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\n\n/**\n * @see https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n * @param {...any} boundArgs\n * @returns {function(...[*]):*}\n * @this {any}\n */\nfunction bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  /**\n   * @param {...any} args\n   * @returns {any}\n   * @this {any}\n   */\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\nconst { prototype } = ElementsCreator\n\n// prototype.createElement.bindArgs = bindArgs\nObject.assign(prototype.createElement, { bindArgs })\n\nhtmlTags.forEach((tagName) => {\n  // @ts-ignore\n  prototype[tagName] = prototype.createElement.bindArgs(tagName)\n})\n\nexport { ElementsCreator }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @enum {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = Object.freeze([\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n])\n\n/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from\n * each other, such as elements, text and comments.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const EnumNodeTypes = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n})\n","export class DOMException extends Error {\n  /**\n   * @param {string} message\n   * @param {string} [name]\n   */\n  constructor(message, name) {\n    super(message)\n    this.name = name ?? 'DOMException'\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { paint } from './functions.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\nclass Node {\n  /** @type {Node | null} */\n  nextSibling = null\n\n  /** @type {Node | null} */\n  previousSibling = null\n\n  /** @type {string} */\n  textContent = ''\n\n  /** @type {Node[]} */\n  #childNodes = []\n\n  /**\n   * @type {string}\n   */\n  #nodeName = ''\n\n  /** @type {number} */\n  #nodeType = 1\n\n  /** @type {Node | null} */\n  #parentNode = null\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} nodeName\n   */\n  constructor(nodeType, nodeName) {\n    this.#nodeType = nodeType\n    this.#nodeName = nodeName\n  }\n\n  /**\n   * @returns {string}\n   */\n  get baseURI() {\n    return ''\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  get childNodes() {\n    return this.#childNodes\n  }\n\n  /**\n   * @returns {Node | null}\n   */\n  get firstChild() {\n    return this.#childNodes[0] ?? null\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @returns {string}\n   */\n  get nodeName() {\n    return this.#nodeName\n  }\n\n  /**\n   * @returns {number}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentnode.asp\n   * @returns {Node | null}\n   */\n  get parentNode() {\n    return this.#parentNode\n  }\n\n  /**\n   * Not in DOM\n   *\n   * @param {Node | null} parentNode\n   */\n  set parentNode(parentNode) {\n    this.#parentNode = parentNode\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\n   *\n   * @param {Node} aChild\n   * @throws {DOMException | TypeError}\n   */\n  appendChild(aChild) {\n    // If the parent of aChild is not a Document, DocumentFragment, or an Element.\n    if (\n      this.nodeType !== EnumNodeTypes.DOCUMENT_NODE\n      && this.nodeType !== EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n      && this.nodeType !== EnumNodeTypes.ELEMENT_NODE\n    ) {\n      throw new DOMException('This node type does not support this method.')\n    }\n\n    // If the insertion of aChild would lead to Document with more than one Element as child.\n    // (document should contain body here, which is an Element)\n    if (\n      this.nodeType === EnumNodeTypes.DOCUMENT_NODE\n    ) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': Only one element on document allowed.')\n    }\n\n    // If aChild is not a DocumentFragment, a DocumentType, an Element, or a CharacterData.\n    if (!(aChild instanceof Node)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Node\\''\n        + ': parameter 1 is not of type \\'Node\\'.'\n\n      throw new TypeError(errorMessage)\n    }\n\n    // If the node already exists, do not append it\n    if (this.#childNodes.includes(aChild)) {\n      return\n    }\n\n    if (aChild === this) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': The new child element contains the parent.')\n    }\n\n    this.#childNodes.push(aChild)\n    aChild.parentNode = this\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#childNodes.length - 2\n\n    if (prevKey >= 0) {\n      this.#childNodes[prevKey].nextSibling = aChild\n      aChild.previousSibling = this.#childNodes[prevKey] ?? null\n    }\n  }\n\n  /**\n   * TODO Make this function do whatever it has to do\n   *\n   * @returns {boolean}\n   */\n  contains() {\n    return false\n  }\n\n  /**\n   * TODO Check whether this function works correctly\n   *\n   * @param {Node} newElement\n   * @param {Node} referenceElement\n   * @returns {Node}\n   */\n  insertBefore(newElement, referenceElement) {\n    /** @type {Node[]} */\n    const newChildren = []\n\n    for (const child of this.#childNodes) {\n      if (child === referenceElement) {\n        newChildren.push(newElement)\n      }\n\n      newChildren.push(child)\n    }\n\n    this.#childNodes = newChildren\n\n    return newElement\n  }\n\n  /**\n   * Removes a child node and returns the removed node.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n   * @param {Node} childNode\n   * @returns {Node}\n   */\n  removeChild(childNode) {\n    if (!childNode) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'parameter 1 is not of type \\'HTMLElement\\'.',\n      )\n    }\n\n    if (!this.#childNodes.includes(childNode)) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'The node to be removed is not a child of this node.',\n      )\n    }\n\n    this.#childNodes = this.#childNodes.filter((node) => node !== childNode)\n\n    return childNode\n  }\n\n  /**\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   */\n  paintChildren({ indent = '' }) {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.childNodes) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += paint(child, indent, '', isChild)\n    }\n\n    return children\n  }\n}\n\nexport { Node }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Comment extends Node {\n  constructor() {\n    super(EnumNodeTypes.COMMENT_NODE, '#comment')\n  }\n}\n\nexport default Comment\n\nexport { Comment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Text extends Node {\n  constructor() {\n    super(EnumNodeTypes.TEXT_NODE, '#text')\n  }\n}\n\nexport { Text }\n","import { Comment } from './Comment.js'\nimport { BOOLEAN_ATTRIBUTES, SELF_CLOSING_TAGS } from './constants.js'\nimport { HTMLElement } from './HTMLElement.js'\nimport { Text } from './Text.js'\nimport { Node } from './Node.js'\n\n/**\n * @param {number} count\n * @param {string} [chars='\\t']\n * @returns {string}\n */\nfunction generateIndents(count, chars = '\\t') {\n  let output = ''\n\n  for (let i = 0; i < count; i++) {\n    output += chars\n  }\n\n  return output\n}\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {SrAttr[]} attributes\n * @returns {string}\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      ) {\n        output += ` ${name}`\n      }\n    }\n    else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else if (value instanceof Function) value = `return(${value.toString()}).call(this,window.event)`\n      else value = value.toString()\n\n      value = value.replace(/\\\"/g, '\\\\\"')\n      value = escapeHTML(value)\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @returns {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * @param {Node} node\n * @param {string} indentWith\n * @param {string} indentCurrent\n * @param {boolean} isChild If true, a new row is put in the beginning\n * @returns {string}\n */\nfunction paint(node, indentWith, indentCurrent, isChild = false) {\n  let output = ''\n  let indent = ''\n  let newRow = ''\n\n  if (indentWith) {\n    indent = indentCurrent\n    newRow = '\\n'\n  }\n\n  if (node instanceof Comment) {\n    output += `${newRow}${indent}<!--${node.textContent}-->`\n  }\n  else if (node instanceof Text) {\n    output += `${newRow}${indent}${node.textContent}`\n  }\n  else if (node instanceof HTMLElement) {\n    const selfClosingTag = (SELF_CLOSING_TAGS.includes(node.tagName))\n    const attributes = generateAttributesString(node.attributes)\n\n    let style = ''\n\n    if (Object.keys(node.style).length > 0) {\n      style = ` style=\"${getStyleStringFromObject(node.style)}\"`\n    }\n\n    // Paint the opening tag (including attributes)\n    if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n    output += indent\n\n    // Paint the opening tag\n    if (node.tagName) {\n      output += `<${node.tagName.toLowerCase()}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n    }\n\n    // Paint the text in the element\n    output += node.textContent\n\n    // Paint the children\n    let children = ''\n\n    for (const child of node.childNodes) {\n      children += paint(child, indentWith, indentCurrent + indentWith, true)\n    }\n\n    if (children) {\n      output += children + newRow + indent\n    }\n\n    // Paint the closing tag\n    if (\n      node.tagName !== ''\n    ) {\n      output += (selfClosingTag) ? '/>' : `</${node.tagName.toLowerCase()}>`\n    }\n  }\n\n  return output\n}\n\nexport { paint, escapeHTML }\n","import { EnumNodeTypes } from './constants.js'\nimport { escapeHTML } from './functions.js'\nimport { Node } from './Node.js'\n\nexport class Element extends Node {\n  /** @type {SrAttr[]} */\n  #attributes = []\n\n  /** @type {string} */\n  #tagName = ''\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} tagName\n   */\n  constructor(nodeType, tagName) {\n    super(nodeType, tagName.toUpperCase())\n\n    this.#tagName = tagName.toUpperCase()\n  }\n\n  /**\n   * @returns {SrAttr[]}\n   */\n  get attributes() {\n    return this.#attributes\n  }\n\n  /**\n   * Includes only Element nodes\n   *\n   * @returns {Element[]}\n   */\n  get children() {\n    // @ts-ignore\n    return this.childNodes.filter((node) => node instanceof Element)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @returns {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @returns {string}\n   */\n  get innerHTML() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @returns {string}\n   */\n  get tagName() {\n    return this.#tagName\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   *\n   * @param {Node | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof Node) {\n      this.appendChild(childElement)\n    }\n    else {\n      this.textContent = escapeHTML(childElement.toString())\n    }\n  }\n\n  /**\n   * Removes the element from the children list of its parent.\n   *\n   * @returns {void}\n   */\n  remove() {\n    this.parentNode?.removeChild(this)\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   *\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return\n    }\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      this.#attributes.push({ name, value })\n    }\n    else {\n      this.#attributes[index] = { name, value }\n    }\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { Element } from './Element.js'\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n *\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringToCamelCase(str) {\n  const split = str.split('-')\n\n  if (split.length === 1) return split[0]\n\n  return (\n    split[0]\n    + split.slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @returns {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  /** @type {StylesObject} */\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass HTMLElement extends Element {\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {string} tagName\n   */\n  constructor(tagName) {\n    super(EnumNodeTypes.ELEMENT_NODE, tagName)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @returns {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @returns {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | StylesObject} input\n   */\n  set style(input) {\n    // In the browser there are few ways to set the style:\n    // - By setting each individual property (.style.color = red)\n    // - By setting '.style.cssText' to a string (.style.cssText = 'color:red')\n    // - By setting '.style' itself to a string (.style = 'color:red')\n\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style) {\n        this.#style[key] = style[key].toString()\n      }\n    }\n  }\n}\n\nexport { HTMLElement }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass DocumentFragment extends Node {\n  constructor() {\n    super(EnumNodeTypes.DOCUMENT_FRAGMENT_NODE, '#document-fragment')\n  }\n}\n\nexport { DocumentFragment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Comment, DocumentFragment, HTMLElement, Element, Node, Text } from './orderedExports.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass Document extends Node {\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ELEMENT_NODE = EnumNodeTypes.ELEMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ATTRIBUTE_NODE = EnumNodeTypes.ATTRIBUTE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  TEXT_NODE = EnumNodeTypes.TEXT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  CDATA_SECTION_NODE = EnumNodeTypes.CDATA_SECTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  PROCESSING_INSTRUCTION_NODE = EnumNodeTypes.PROCESSING_INSTRUCTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  COMMENT_NODE = EnumNodeTypes.COMMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_NODE = EnumNodeTypes.DOCUMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_TYPE_NODE = EnumNodeTypes.DOCUMENT_TYPE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_FRAGMENT_NODE = EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n\n  /** @type {HTMLElement} */\n  #body\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @type {Element[]}\n   */\n  #children = []\n\n  constructor() {\n    super(/* DOCUMENT_NODE */ 9, '#document')\n\n    const html = new HTMLElement('html')\n    const head = new HTMLElement('head')\n    const body = new HTMLElement('body')\n\n    html.appendChild(head)\n    html.appendChild(body)\n\n    this.#children.push(html)\n\n    this.#body = body\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get body() {\n    return this.#body\n  }\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/children\n   * @returns {Element[]}\n   */\n  get children() {\n    return this.#children\n  }\n\n  /**\n   * @returns {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment() {\n    return new DocumentFragment()\n  }\n\n  /**\n   * @param {string} [text]\n   * @returns {Comment}\n   */\n  createComment(text = '') {\n    const element = new Comment()\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   * @returns {HTMLElement}\n   */\n  createElement(tagName) {\n    return new HTMLElement(tagName)\n  }\n\n  /**\n   * @param {string} text\n   * @returns {Text}\n   */\n  createTextNode(text) {\n    const element = new Text()\n\n    element.textContent = text\n\n    return element\n  }\n\n  // /**\n  //  * @param {boolean} [prettyPrint]\n  //  * @returns {string}\n  //  */\n  // paint(prettyPrint = true) {\n  //   const tabsCount = (prettyPrint) ? 0 : -1\n  //\n  //   return this.body.paint(tabsCount)\n  // }\n}\n\nexport { Document, HTMLElement }\n","import { Comment, Document, DocumentFragment, Element, HTMLElement, Node, Text } from './orderedExports.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\n/**\n * String-Rendering DOM\n */\nclass Window {\n  /** @type {typeof Comment} */\n  Comment = Comment\n\n  /** @type {typeof DocumentFragment} */\n  DocumentFragment = DocumentFragment\n\n  /** @type {typeof Element} */\n  Element = Element\n\n  /** @type {typeof HTMLElement} */\n  HTMLElement = HTMLElement\n\n  /** @type {typeof Node} */\n  Node = Node\n\n  /** @type {typeof Text} */\n  Text = Text\n\n  /** @type {typeof DOMException} */\n  DOMException = DOMException\n\n  /** @type {typeof Error} */\n  Error = Error\n\n  /** @type {typeof TypeError} */\n  TypeError = TypeError\n\n  /** @type {Document} */\n  document\n\n  constructor() {\n    this.document = new Document()\n  }\n}\n\nexport { Window }\n","import { ElementsCreator } from './ElementsCreator.js'\nimport {\n  appendChildrenToElement,\n  isBrowserEnvironment,\n  isValidCustomElementName,\n} from './functions.js'\nimport { Window as SrWindow } from './SrDOM/Window.js'\n\nconst isBrowserEnv = isBrowserEnvironment()\nconst srWindow = new SrWindow()\n\nclass Paintor {\n  /** @type {string} */\n  #containerCustomElementName = ''\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {HTMLElement | ShadowRoot | null}\n   */\n  #containerElement = null\n\n  /** @type {HTMLElement[]} */\n  #finalElements = []\n\n  /**\n   * In server mode this will hold the final WebApi code\n   *\n   * @type {string}\n   */\n  #finalHtmlCode = ''\n\n  /** @type {boolean} */\n  #isStatic = false\n\n  /** @type {Template[]} */\n  #templates = []\n\n  /** @type {Map<Translation | null, string>} */\n  #staticHtmlCodes = new Map()\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /**\n   * @param {string | HTMLElement} container\n   * @returns {void}\n   */\n  appendTo(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only do this in browser environment')\n    }\n\n    this.#render(container, window, false)\n  }\n\n  /**\n   * @param {...Template} templates\n   * @returns {Paintor}\n   */\n  compose(...templates) {\n    if (templates instanceof Array) {\n      for (const template of templates) {\n        if (template instanceof Array) {\n          this.#templates = [...this.#templates, () => template]\n        }\n        else {\n          this.#templates.push(template)\n        }\n      }\n    }\n\n    return this\n  }\n\n  getElements() {\n    this.#render(null, window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  getHtml(options) {\n    if (this.#isStatic) {\n      return this.getStaticHtml(options)\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true, options)\n\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  getStaticHtml(options) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticHtmlCodes.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render('', window, true, options)\n      this.#staticHtmlCodes.set(\n        key,\n        this.#finalHtmlCode,\n      )\n    }\n\n    return this.#staticHtmlCodes.get(key) ?? ''\n  }\n\n  getElementsSr() {\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @param {string | HTMLElement} container\n   * @returns {void}\n   */\n  paint(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only use this function in browser environment')\n    }\n\n    if (typeof container !== 'string' && !(container instanceof HTMLElement)) {\n      throw new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof container}>`,\n      )\n    }\n\n    this.#render(container, window, true)\n  }\n\n  /**\n   * @param {boolean} [on=true]\n   * @returns {Paintor}\n   */\n  static(on = true) {\n    this.#isStatic = on\n\n    return this\n  }\n\n  /**\n   * @param {...Translation} translations\n   * @returns {Paintor}\n   */\n  useTranslations(...translations) {\n    // Reset translations here, because the whole api chain (containing this function)\n    // can be executed multiple times, but with different translations every time.\n    this.#translations = []\n\n    translations.map((item) => {\n      if (item instanceof Array) {\n        item.forEach((subItem) => {\n          if (!this.#translations.includes(subItem)) {\n            this.#translations = [...this.#translations, subItem]\n          }\n        })\n      }\n      else if (item instanceof Object) {\n        if (!this.#translations.includes(item)) {\n          this.#translations = [...this.#translations, item]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElement() {\n    const el = this.#containerElement\n\n    while (el?.firstChild) {\n      el.removeChild(el.firstChild)\n    }\n  }\n\n  /**\n   * This method is for tricking TS that the string-rendering DOM's Window\n   * has the same type of the browser DOM's window\n   *\n   * @returns {Window}\n   */\n  #getSrWindow() {\n    // @ts-ignore\n    return srWindow\n  }\n\n  /**\n   * @param {string | HTMLElement | null} container\n   * @param {Window} window\n   * @param {Translation[]} translations\n   * @param {Template[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #init(container, window, translations, templates) {\n    this.#initContainer(container, window)\n    this.#initTranslations(translations)\n    this.#initTemplates(templates)\n\n    return true\n  }\n\n  /**\n   * @param {string | HTMLElement | null} container\n   * @param {Window} window\n   * @returns {boolean}\n   */\n  #initContainer(container, window) {\n    const isSr = window.document.baseURI === ''\n\n    if (typeof container === 'string') {\n      if (isValidCustomElementName(container)) {\n        this.#containerCustomElementName = container\n      }\n      else {\n        // @ts-ignore\n        this.#containerElement = (isSr)\n          ? window.document.createElement('#container')\n          : window.document.querySelector(container)\n\n        if (!this.#containerElement) {\n          throw new Error(`Could not find an element by the following query: ${container}`)\n        }\n      }\n    }\n    else {\n      this.#containerElement = container\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Template[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTemplates(templates) {\n    for (let template of templates) {\n      if (typeof template !== 'function') {\n        throw new Error('The template must be a function')\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Translation[]} translations\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTranslations(translations) {\n    if (!(translations instanceof Array)) {\n      throw new Error('The argument \\'translations\\' must be an Array')\n    }\n\n    this.#translations = translations\n\n    return true\n  }\n\n  /**\n   * @param {HTMLElement | string | null} container\n   * @param {Window} window\n   * @param {boolean} clearContainer\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #render(container, window, clearContainer = true, htmlOptions = {}) {\n    this.#init(container, window, this.#translations, this.#templates)\n\n    if (clearContainer) {\n      this.#clearContainerElement()\n    }\n\n    const templates = this.#templates\n    const translations = this.#translations\n\n    if (!window) {\n      throw new Error('Missing window element')\n    }\n\n    if (\n      !this.#containerElement\n      && this.#containerCustomElementName\n    ) {\n      // Custom Elements\n\n      /**\n       * @param {Paintor} paintor\n       * @returns {CustomElementConstructor}\n       */\n      const getCustomElementConstructor = (paintor) => {\n        return class extends HTMLElement {\n          constructor() {\n            super()\n            this.attachShadow({ mode: 'open' })\n          }\n\n          connectedCallback() {\n            if (!this.shadowRoot) {\n              throw new Error('Missing shadow root')\n            }\n\n            paintor.#containerElement = this.shadowRoot\n\n            const creator = new ElementsCreator(\n              window, paintor.#containerElement, templates, translations,\n            )\n            const children = creator.getCreatedElements()\n\n            appendChildrenToElement(paintor.#containerElement, children)\n          }\n        }\n      }\n\n      customElements.define(\n        this.#containerCustomElementName,\n        getCustomElementConstructor(this),\n      )\n    }\n    else {\n      if (!this.#containerElement) {\n        throw new Error('Missing containerElement')\n      }\n\n      // DOM or Virtual\n      const creator = new ElementsCreator(\n        window, this.#containerElement, templates, translations,\n      )\n\n      this.#finalHtmlCode = creator.finalPaint(htmlOptions)\n      this.#finalElements = creator.finalElements\n    }\n  }\n}\n\nexport { Paintor }\n","import { isBrowserEnvironment } from './functions.js'\n\n/**\n * TODO make it work for server environment\n *\n * @returns {string}\n */\nconst getLocale = function () {\n  let locale = 'en'\n\n  if (isBrowserEnvironment()) {\n    const html = document.getElementById('html')\n\n    locale = html?.getAttribute('lang') ?? locale\n  }\n\n  return locale\n}\n\n/**\n * @param {string} defaultPath\n * @param {string} locale\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createSingleTranslation = async function (defaultPath, locale) {\n  if (typeof defaultPath !== 'string') {\n    throw new Error('Translation path must be a string')\n  }\n\n  let translation = null\n\n  const match = defaultPath.match(/^(.*?)([^.\\/\\\\]+)(.\\w+)$/m)\n\n  if (match === null) {\n    throw new TypeError(`Incorrect path: ${defaultPath}`)\n  }\n\n  const filePath = match[1] + locale + match[3]\n\n  try {\n    translation = (await import(/* @vite-ignore */ filePath)).default\n  }\n  catch (e) {\n    if (filePath !== defaultPath) {\n      translation = (await import(/* @vite-ignore */ defaultPath)).default\n    }\n  }\n\n  if (!(translation instanceof Object)) {\n    throw new TypeError(`Translation at ${filePath} must export an object`)\n  }\n\n  return translation\n}\n\n/**\n * @param {...string} defaultPaths\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createTranslation = async function (...defaultPaths) {\n  const locale = getLocale()\n\n  const promises = []\n\n  for (let path of defaultPaths) {\n    promises.push(createSingleTranslation(path, locale))\n  }\n\n  let translation = {}\n\n  const translations = await Promise.all(promises)\n\n  translations.forEach((value) => {\n    translation = { ...translation, ...value }\n  })\n\n  return translation\n}\n\nexport { createTranslation }\n","import { Paintor } from './Paintor.js'\nimport { createState } from './State.js'\nimport { createTranslation } from './Translation.js'\n\n/**\n * @param {Template} template\n * @returns {Template}\n */\n// eslint-disable-next-line @typescript-eslint/no-shadow\nconst createTemplate = (template) => {\n  return template\n}\n\n/**\n * @param {string} [container]\n * @returns {void | string}\n */\nconst paintor = function (container = '') {\n  /**\n   * Current version\n   */\n  return new Paintor().paint(container)\n}\n\n/**\n * @param {...Template} templates\n * @returns {Paintor}\n */\npaintor.compose = function (...templates) {\n  return new Paintor().compose(...templates)\n}\n\n/**\n * @param {...Translation} translations\n * @returns {Paintor}\n */\npaintor.useTranslations = function (...translations) {\n  return new Paintor().useTranslations(...translations)\n}\n\npaintor.createTemplate = createTemplate\n\nconst compose = paintor.compose\n\nexport default paintor\nexport { paintor, compose, createState, createTemplate, createTranslation, Paintor }\n"],"names":["ElementsCollector","element","elements","elementsCollector","symStateId","symArrayAccess","symObjectAccess","suggestedItems","setSuggestItems","propertyName","subPropertyName","bindFunction","statementRepaintFunction","unsetSuggestedItems","StateSubscriptions","#subscriptions","#state","state","stateProp","subscriptions","item","subscription","key","object","statePath","handler","#createProxyHandler","proxy","innerStatePath","#onArrayLengthChange","updatedState","listItem","#onPropCreateOrDelete","prop","#onPropCreate","#onPropUpdate","target","result","modifyStyleRule","setElementAttrOrProp","#onPropDelete","receiver","fn","args","value","stateIdCounter","createState","isState","getGlobalObject","format","fmt","re","replacer","match","escaped","ptn","flag","arg","out","isBrowserEnvironment","isBrowser","addChildToStack","inputChild","childrenStack","addChildrenToStack","inputChildren","child","isEventAttribute","attributeName","isWhitespace","char","isValidCustomElementName","name","stringToBoolean","string","int","addEventListenerIfPossible","callback","eventSmallName","appendDOMChildrenToElement","children","fragment","appendVirtualChildrenToElement","appendChildrenToElement","forEachLoop","data","beforeIterationCallback","keyToRender","iterationCallback","isProxy","val","ret","forLoop","start","end","arrayRemoveKey","arr","el","index","insertAfter","newNode","existingNode","nextSibling","parentNode","setDataSetAttributesToElement","dataSet","attrOrPropName","output","objectHasKey","htmlTags","HtmlTemplateParserElement","parent","attributes","SELF_CLOSING_TAGS","HtmlTemplateParser","#attrName","#attrQuote","#attrValue","#attributes","#char","#charPrevious","#data","#stage","#stageNothing","#styleAttrName","#styleAttrValue","#styles","#tagName","#tagNameClosing","#textContents","#topElement","#currentElement","strings","keys","#mergeStringsAndKeys","#rotate","elementsCreator","#generateChildren","#appendData","to","#makeNewElement","dataIndex","charIndex","#setAttribute","#setStage","stage","#stageAttrName","#setStyle","#stageTagToClose","#stageAttrOpenQuote","#stageStyleAttrName","#stageAttrValue","#stageTag","#stageTextContents","#stageStyleAttrValue","ElementsCreator","#containerElement","#translations","#collectedElements","#dummyHtmlElement","#document","#window","#isSr","#templates","window","containerElement","templates","translations","template","returnedValue","Paintor","generatedChildren","allPaintor","tagName","argumentID","argument","textNode","#translate","isChildrenArray","#arrayTranslateFormatTranslate","inlineScript","propsObject","#setPropertiesToElement","level","htmlOptions","finalHtmlCode","virtualContainer","from","#statementHandler","input","callbackForState","renderedElementsMap","elementsFromCollector","#statementHandlerForState","#statementHandlerForFunction","#htmlForSimpleString","#htmlForTemplateLiteral","condition","elseHandler","#afterStatement","thisLevel","upperLevel","#arrayTranslate","array","#beforeStatement","#insertStatementElements","beginCommentElement","lastElement","newElement","#removeStatementElements","beginCommentElementText","endElementText","currentElement","statementsCounter","deletedElementsCount","text","#unsubscribeElementAndItsChildren","properties","property","#setStylesToElement","styleRules","ruleName","ruleValue","finalValue","type","commentElementBegin","commentElementEnd","bindFunctionResult","resolved","i","renderedElementsMapNew","isKeyInRenderedElementsMap","added","translated","#translateString","globalObject","globallyTranslated","str","translateObject","bindArgs","boundArgs","targetFunction","prototype","BOOLEAN_ATTRIBUTES","EnumNodeTypes","DOMException","message","Node","#childNodes","#nodeName","#nodeType","#parentNode","nodeType","nodeName","aChild","errorMessage","prevKey","referenceElement","newChildren","childNode","node","indent","childNumber","isChild","paint","Comment","Text","escapeHTML","html","charsToReplace","tag","generateAttributesString","attribute","formatStringFromCamelCase","all","getStyleStringFromObject","style","indentWith","indentCurrent","newRow","HTMLElement","selfClosingTag","Element","className","childElement","attributeValue","formatStringToCamelCase","split","word","getStyleObjectFromString","formattedProperty","#style","Document","#body","#children","head","body","DocumentFragment","Window","isBrowserEnv","srWindow","SrWindow","#containerCustomElementName","#finalElements","#finalHtmlCode","#isStatic","#staticHtmlCodes","container","#render","options","#getSrWindow","on","subItem","#clearContainerElement","#init","#initContainer","#initTranslations","#initTemplates","isSr","clearContainer","getCustomElementConstructor","paintor","creator","getLocale","locale","createSingleTranslation","defaultPath","translation","filePath","__vitePreload","createTranslation","defaultPaths","promises","path","createTemplate","compose"],"mappings":"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"}