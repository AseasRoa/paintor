{"version":3,"file":"paintor.js","sources":["../src/ElementsCollector.js","../src/symbols.js","../src/StateSubscriptions.js","../src/State.js","../src/functions.js","../src/htmlTags.js","../src/HtmlTemplateParser/HtmlTemplateParserElement.js","../src/HtmlTemplateParser/constants.js","../src/HtmlTemplateParser/HtmlTemplateParser.js","../src/ElementsCreator.js","../src/SrDOM/constants.js","../src/SrDOM/exceptions/DOMException.js","../src/SrDOM/Node.js","../src/SrDOM/Comment.js","../src/SrDOM/Text.js","../src/SrDOM/functions.js","../src/SrDOM/Element.js","../src/SrDOM/HTMLElement.js","../src/SrDOM/DocumentFragment.js","../src/SrDOM/Document.js","../src/SrDOM/Window.js","../src/Component.js","../src/Translation.js","../src/index.js"],"sourcesContent":["/**\n * This class has an array where HTML elements are stored.\n * The class methods provide an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type {Node[]} */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   *\n   * @param {Node} element\n   */\n  addElement(element) {\n    if (element) this.elements.push(element)\n  }\n\n  /**\n   * Add multiple elements to the array of collected elements\n   *\n   * @param {Node[]} elements\n   */\n  addElements(elements) {\n    for (let element of elements) {\n      this.elements.push(element)\n    }\n  }\n\n  /**\n   * Returns the array of collected elements\n   *\n   * @returns {Node[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   *\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements) {\n      this.addElement(element)\n    }\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements = []\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   *\n   * @param {Node[]} elements\n   */\n  removeTheseElements(elements) {\n    if (elements.length > 0) {\n      this.elements = this.elements.filter(\n        (element) => !(elements.includes(element)),\n      )\n    }\n  }\n}\n\nexport { ElementsCollector }\n","export const symSubscribe = Symbol('symSubscribe')\nexport const symSubscribed = Symbol('symSubscribed')\n\nexport const symStateId    = Symbol('symStateId')\n\nexport const symArrayAccess  = Symbol('symArrayAccess')\nexport const symObjectAccess = Symbol('symObjectAccess')\n","import { setElementAttrOrProp, modifyStyleRule } from './functions.js'\nimport { symArrayAccess, symObjectAccess, symStateId } from './symbols.js'\n\n/** @typedef {Object<*,*>} StateProxy */\n\n/**\n * @type {{\n *   element: null | Element | Comment,\n *   propertyName: string,\n *   subPropertyName: string,\n *   bindFunction: null | BindFunction,\n *   statementRepaintFunction: null | StatementRepaintFunction\n * }}\n */\nlet suggestedItems = {\n  element: null,\n  propertyName: '',\n  subPropertyName: '',\n  bindFunction: null,\n  statementRepaintFunction: null,\n}\n\n/**\n * This function should be called just before calling the bindFunction. The idea is\n * that the bindFunction, along with its html element and property name are suggested\n * here to the proxy handler. When the bindFunction is called, any state used in it\n * would trigger the proxy get event, which means that it will be added to the subscriptions.\n *\n * @param {Element | Comment} element\n * @param {string} propertyName\n * @param {string} subPropertyName\n * @param {BindFunction} bindFunction\n * @param {StatementRepaintFunction | null} statementRepaintFunction\n */\nfunction setSuggestItems(\n  element,\n  propertyName,\n  subPropertyName,\n  bindFunction,\n  statementRepaintFunction,\n) {\n  suggestedItems.element = element\n  suggestedItems.propertyName = propertyName\n  suggestedItems.subPropertyName = subPropertyName\n  suggestedItems.bindFunction = bindFunction\n  suggestedItems.statementRepaintFunction = statementRepaintFunction\n}\n\n/**\n * Reset the suggested items\n *\n * @returns {void}\n */\nfunction unsetSuggestedItems() {\n  suggestedItems = {\n    element: null,\n    propertyName: '',\n    subPropertyName: '',\n    bindFunction: null,\n    statementRepaintFunction: null,\n  }\n}\n\nclass StateSubscriptions {\n  /** @type {Map<string | symbol, Subscription[]>} */\n  #subscriptions = new Map()\n\n  /** @type {State} */\n  #state = {}\n\n  /**\n   * @param {State} state\n   * @param {string | symbol} stateProp\n   * @param {Element | Comment} element\n   * The HTML element for which the other parameters apply.\n   * @param {string} propertyName\n   * The name of the property of the HTML element, for\n   * which the subscription is going to be created.\n   * For example: 'style', 'value', 'textContent', 'innerHTML'.\n   * Also, '--if' for IF statement.\n   * @param {string} subPropertyName\n   * If the property name is 'style', the sub-property could be\n   * any style property.\n   * For example: 'fontSize'\n   * @param {BindFunction} bindFunction\n   * The function that is used instead of a fixed value.\n   * For example: () => (state.clicks)\n   * @param {StatementRepaintFunction | null} statementRepaintFunction\n   * This is only used in the if() function. It's a function that\n   * is used to repaint the elements in case the condition is changed\n   * from false to true or vice versa.\n   */\n  subscribe(\n    state,\n    stateProp,\n    element,\n    propertyName,\n    subPropertyName,\n    bindFunction,\n    statementRepaintFunction,\n  ) {\n    if (propertyName === '-s-if' || propertyName === '-s-forEach') {\n      stateProp = propertyName\n    }\n\n    if (!this.#subscriptions.has(stateProp)) {\n      this.#subscriptions.set(stateProp, [])\n    }\n\n    const subscriptions\n            = this.#subscriptions.get(stateProp) ?? []\n\n    // Search for a subscription with the same parameters.\n    // If such already exists, just don't create a new one.\n    for (const item of subscriptions) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementRepaintFunction === statementRepaintFunction\n      ) return\n    }\n\n    subscriptions.push({\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementRepaintFunction,\n    })\n\n    // Put a mark on the element itself, telling that it\n    // has a subscription\n    Object.assign(element, { '--subscribed': true })\n  }\n\n  /**\n   * Remove any subscriptions that the element is subscribed to\n   *\n   * @param {Node} element\n   */\n  unsubscribe(element) {\n    this.#subscriptions.forEach((subscription, key) => {\n      this.#subscriptions.set(key, subscription.filter((item) => (item.element !== element)))\n    })\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * The input object that will be used to create\n   * a proxy object with the same keys and values.\n   * @param {string} [statePath]\n   * The path to the state:\n   * <br>\n   * - If the state is the parent state, this is an empty string.\n   * <br>\n   * - If the state is a child state, this is the path to it (dot notated).\n   * @returns {T}\n   */\n  createProxy(object, statePath = '') {\n    const handler = this.#createProxyHandler()\n    const proxy = new Proxy(object, handler)\n\n    // Store the path to the state in a special value in the\n    // proxy object, but make that value invisible for \"for\"\n    // (and similar) statements.\n    // Object.defineProperty(proxy, '--state-path', {\n    //   enumerable: false,\n    //   configurable: false,\n    //   writable: false,\n    //   value: statePath,\n    // })\n\n    // Recursive proxy. To find all inner objects\n    // and turn them into child states.\n    for (const key in proxy) {\n      if (!(proxy[key] instanceof Object)) {\n        continue\n      }\n\n      const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n      proxy[key] = this.createProxy(proxy[key], innerStatePath)\n    }\n\n    this.#state = proxy\n\n    return proxy\n  }\n\n  /**\n   * This is called when \"length\" of an array is changed, which\n   * happens when elements are being added or popped from the end\n   * of the array. Not when delete is being used!\n   *\n   * @param {any[]} updatedState\n   */\n  #onArrayLengthChange(updatedState) {\n    const subscription = this.#subscriptions.get('-s-forEach')\n\n    if (subscription) {\n      subscription.forEach((listItem) => {\n        const { statementRepaintFunction } = listItem\n\n        if (statementRepaintFunction instanceof Function) {\n          statementRepaintFunction(updatedState)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreateOrDelete(updatedState, prop) {\n    const subscription = this.#subscriptions.get('-s-forEach')\n\n    if (subscription) {\n      subscription.forEach((listItem) => {\n        const { statementRepaintFunction } = listItem\n\n        if (statementRepaintFunction instanceof Function) {\n          statementRepaintFunction(updatedState)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreate(updatedState, prop) {\n    this.#onPropCreateOrDelete(updatedState, prop)\n  }\n\n  /**\n   * @param {State} target\n   * @param {string | symbol} prop\n   */\n  #onPropUpdate(target, prop) {\n    if (this.#subscriptions.has(prop)) {\n      const list = this.#subscriptions.get(prop) ?? []\n\n      list.forEach((listItem) => {\n        const {\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementRepaintFunction,\n        } = listItem\n\n        if (Object.hasOwn(element, '--deleted')) {\n          this.unsubscribe(element)\n\n          return\n        }\n\n        let result = bindFunction.call(element, element)\n\n        if (propertyName === 'style' && subPropertyName) {\n          // @ts-ignore\n          element.style[subPropertyName]\n              = modifyStyleRule(subPropertyName, result)\n        }\n        else if (\n          propertyName === '--if'\n          || propertyName === '--for'\n        ) {\n          if (statementRepaintFunction instanceof Function) {\n            statementRepaintFunction(result)\n          }\n        }\n        else {\n          /**\n           * @see Remark \"() => value\"\n           */\n          if (result instanceof Function) {\n            result = result()\n          }\n\n          // @ts-ignore\n          setElementAttrOrProp(element, propertyName, result)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropDelete(updatedState, prop) {\n    this.#onPropCreateOrDelete(updatedState, prop)\n  }\n\n  /**\n   * @returns {ProxyHandler<StateProxy>}\n   */\n  #createProxyHandler() {\n    /** @type {ProxyHandler<StateProxy>} */\n    const handler = {}\n\n    handler.get = (target, prop, receiver) => {\n      /**\n       * Why is hasOwn() needed?\n       * If the state is for example an array and its whole value is read,\n       * then JS tries to read few extra properties first - map, length, constructor\n       */\n      if (\n        Object.hasOwn(target, prop)\n        || prop === symObjectAccess\n        || prop === symArrayAccess\n      ) {\n        /**\n         * In the if below it would be enough to check just one element,\n         * but because of TS more than one is checked\n         */\n        if (\n          suggestedItems.element\n          && suggestedItems.bindFunction\n        ) {\n          this.subscribe(\n            target,\n            prop,\n            suggestedItems.element,\n            suggestedItems.propertyName,\n            suggestedItems.subPropertyName,\n            suggestedItems.bindFunction,\n            suggestedItems.statementRepaintFunction,\n          )\n        }\n      }\n      // Internal functions of Set() and Map()\n      else if (\n        (target instanceof Map || target instanceof Set)\n        // @ts-ignore\n        && target[prop] instanceof Function\n      ) {\n        /**\n         * @see https://stackoverflow.com/questions/48452885/observe-changes-to-a-map-using-a-proxy\n         */\n\n        // @ts-ignore\n        const fn = target[prop]\n\n        /**\n         * @param {any[]} args\n         * @returns {*}\n         */\n        const boundFunction = (...args) => {\n          const result = fn.apply(target, args)\n\n          if (target instanceof Set) {\n            if (prop === 'add') {\n              this.#onPropCreate(receiver, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(receiver, prop)\n            }\n          }\n          else if (target instanceof Map) {\n            if (prop === 'set') {\n              this.#onPropCreate(receiver, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(receiver, prop)\n            }\n          }\n\n          return result\n        }\n\n        return boundFunction\n      }\n\n      return target[prop]\n    }\n\n    handler.set = (target, prop, value, receiver) => {\n      if (\n        typeof prop === 'symbol'\n        && (\n          prop === symArrayAccess\n          || prop === symObjectAccess\n          || prop === symStateId\n        )\n      ) {\n        target[prop] = value\n      }\n      // Array's length is set every time after\n      // adding or removing elements\n      else if (target instanceof Array && prop === 'length') {\n        target[prop] = value\n\n        this.#onArrayLengthChange(receiver)\n      }\n      else if (Object.hasOwn(target, prop)) {\n        target[prop] = value\n\n        this.#onPropUpdate(receiver, prop)\n      }\n      else {\n        target[prop] = value\n\n        this.#onPropCreate(receiver, prop)\n      }\n\n      return true\n    }\n\n    /**\n     * Trap for the delete operator. This trap can intercept these operations:\n     *  - delete proxy[foo] and delete proxy.foo\n     *  - Reflect.deleteProperty()\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty\n     * @param {StateProxy} target\n     * @param {string | symbol} prop\n     * @returns {boolean}\n     * A Boolean indicating whether the property has been successfully deleted.\n     */\n    handler.deleteProperty = (target, prop) => {\n      delete target[prop]\n\n      this.#onPropDelete(target, prop)\n\n      return true\n    }\n\n    return handler\n  }\n}\n\nexport { StateSubscriptions, setSuggestItems, unsetSuggestedItems }\n","import { StateSubscriptions } from './StateSubscriptions.js'\nimport { symStateId } from './symbols.js'\n\nlet stateIdCounter = 0\n\n/**\n * @template T\n * @param {T} object\n * Your input object or array\n * @returns {T}\n * A proxy object/array that looks the same as the input object/array\n */\nconst createState = function createState(object) {\n  if (!(object instanceof Object)) {\n    throw new Error('createState() only accepts Object, Array, Set or Map as input value.')\n  }\n\n  const stateSubscriptions = new StateSubscriptions()\n  const proxy = stateSubscriptions.createProxy(object)\n\n  stateIdCounter += 1\n  // @ts-ignore\n  proxy[symStateId] = stateIdCounter\n\n  return proxy\n}\n\n/**\n * @param {Object<*,*>} object\n * @returns {boolean}\n */\nconst isState = function (object) {\n  return (object instanceof Object) && (symStateId in object)\n}\n\nexport { createState, isState }\n","import { isState } from './State.js'\nimport { symArrayAccess, symObjectAccess } from './symbols.js'\n\n/**\n * @see https://github.com/purposeindustries/window-or-global/blob/master/lib/index.js\n * @returns {Window | any}\n */\nexport function getGlobalObject() {\n  return (typeof self === 'object' && self.self === self && self)\n    || (typeof global === 'object' && global.global === global && global)\n    // @ts-ignore\n    || this\n}\n\n/**\n * @see https://github.com/tmpfs/format-util/blob/master/format.js\n * @param {string} fmt\n * @param {...any[]} args\n * @returns {string}\n */\nexport function format(fmt, ...args) {\n  const re = /(%?)(%([ojdsif]))/g\n\n  if (args.length > 0) {\n    /**\n     * @param {string} match\n     * @param {string} escaped % (for %%) or null (for anything else)\n     * @param {string} ptn %o or %s or whatever\n     * @param {string} flag The s from %s\n     * @returns {string}\n     */\n    const replacer = (match, escaped, ptn, flag) => {\n      let arg = args.shift()\n      let out = ''\n\n      switch (flag) {\n        case 'o':\n          if (Array.isArray(arg)) {\n            out = JSON.stringify(arg)\n          }\n          break\n        case 's':\n          out = '' + arg\n          break\n        case 'd':\n          out = '' + Number(arg)\n          break\n        case 'j':\n          out = JSON.stringify(arg)\n          break\n        case 'i':\n          out = '' + parseInt('' + arg, 10)\n          break\n        case 'f':\n          out = '' + parseFloat('' + arg)\n          break\n      }\n\n      if (!escaped) {\n        return out\n      }\n\n      // @ts-ignore\n      args.unshift(out)\n\n      return match\n    }\n\n    fmt = fmt.replace(re, replacer)\n  }\n\n  // arguments, remained after the formatting\n  if (args.length > 0) {\n    fmt += ' ' + args.join(' ')\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%')\n\n  return '' + fmt\n}\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @returns {boolean}\n */\nexport function isBrowserEnvironment() {\n  if (isBrowserEnvironment.isIt === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n    isBrowserEnvironment.isIt = isBrowser()\n  }\n\n  return isBrowserEnvironment.isIt ?? false\n}\n\n/**\n * The environment doesn't change over time, so it's enough\n * to determine it once. This variable is used to store the\n * environment, it's a cache.\n *\n * @type {undefined | boolean}\n */\nisBrowserEnvironment.isIt = undefined\n\n/**\n * @template T\n * @param {T} inputChild\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildToStack(inputChild, childrenStack) {\n  childrenStack.push(inputChild)\n\n  return childrenStack\n}\n\n/**\n * @template T\n * @param {T[]} inputChildren\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren) {\n    childrenStack.push(child)\n  }\n\n  return childrenStack\n}\n\n/**\n * @param {string} attributeName\n * @returns {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {string} char\n * @returns {boolean}\n */\nexport function isWhitespace(char) {\n  return (\n    char === ' '\n    || char === '\\t'\n    || char === '\\r'\n    || char === '\\n'\n  )\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function isValidCustomElementName(name) {\n  return /^[a-z][a-z0-9-]+$/.test(name) && name.includes('-')\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function selectorEndsWithId(name) {\n  return /#[a-z0-9-]+\\s*$/.test(name)\n}\n\n/**\n * Turns a string into boolean.\n * Covers the cases when the string is 'true', 'false' or a number.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexport function stringToBoolean(string) {\n  if (string === 'true') return true\n\n  if (string === 'false') return false\n\n  const int = parseInt(string)\n\n  return (isNaN(int)) ? Boolean(string) : Boolean(int)\n}\n\n/**\n * @param {Element | Text} element\n * @param {string} attributeName\n * @param {EventListenerOrEventListenerObject} callback\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof window.Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  const eventSmallName = attributeName.toLowerCase().substring(2)\n\n  element.addEventListener(eventSmallName, callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n *\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  }\n  else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child) {\n        fragment.append(child)\n      }\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child) {\n      element.appendChild(child)\n    }\n  }\n}\n\n/**\n * @param {Node | null} element\n * The element in which to append the children\n * @param {Node[]} children\n * The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (!element) return\n\n  if (isBrowserEnvironment() && element instanceof window.Node) {\n    appendDOMChildrenToElement(element, children)\n  }\n  else {\n    appendVirtualChildrenToElement(element, children)\n  }\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values\n * and the \"handler\" function is looped once for each pair.\n * The loop breaks if \"false\" is returned by the \"handler\"\n * function.\n *\n * @template T\n * @param {1 | 2} forLoopType\n * @param {Array<T> | Object<string | number, T> | Map<string | number, T>} data\n * @param {ForLoopCallback<T>} handler\n * @param {(key: number | string) => void} [beforeIterationCallback]\n * @param {string | number | symbol} [keyToRender]\n * @param {(key: number | string) => void} [iterationCallback]\n * @returns {boolean}\n * @throws {TypeError}\n */\nexport function forEachLoop(\n  forLoopType,\n  data,\n  handler,\n  beforeIterationCallback,\n  keyToRender,\n  iterationCallback,\n) {\n  if (\n    !(data instanceof Object)\n    && !(data instanceof Array)\n    && !(data instanceof Map)\n    && !(data instanceof Set)\n  ) {\n    throw new TypeError('\"data\" argument should be an Object or an Array')\n  }\n\n  if (!(handler instanceof Function)) {\n    throw new TypeError('\"handler\" argument should be a Function')\n  }\n\n  const isProxy = forLoopType === 2 && isState(data)\n\n  if (\n    data instanceof Map\n    || data instanceof Set\n  ) {\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const [key, value] of data.entries()) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let val = isProxy ? () => value : value\n\n      if (beforeIterationCallback) {\n        val = beforeIterationCallback?.(val)\n      }\n\n      const ret = handler(val, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Array) {\n    /**\n     * for-in doesn't work properly in this case,\n     * because the numeric index turns into string.\n     * That's why use the classic for loop is used.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const nothing = isProxy ? data[symArrayAccess] : undefined\n\n    for (let key = 0; key < data.length; key++) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Object) {\n    /**\n     * The Object loop must be at the end,\n     * because Array, Set and Map are also Object.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const key in data) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {ForLoopIterableCallback} handler\n * @returns {boolean | Error}\n */\nexport function forLoop(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number') {\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n  }\n\n  if (!(handler instanceof Function)) {\n    return new Error('\"handler\" argument should be a Function')\n  }\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} key\n * @returns {T[]}\n */\nexport function arrayRemoveKey(arr, key) {\n  return arr.filter(function (el, index) {\n    return index !== key\n  })\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {T} value\n * @returns {T[]}\n */\nexport function arrayRemoveValue(arr, value) {\n  return arr.filter(function (el) {\n    return el !== value\n  })\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n *\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  if (!existingNode) return\n\n  const { nextSibling, parentNode } = existingNode\n\n  if (parentNode) {\n    parentNode.insertBefore(newNode, nextSibling)\n  }\n}\n\n/**\n *\n * @param {HTMLElement} element\n * @param {Object<string, (string | number | boolean)>}dataSet\n */\nexport function setDataSetAttributesToElement(element, dataSet) {\n  if (dataSet instanceof Object) {\n    for (const key in dataSet) {\n      const value = dataSet[key].toString()\n\n      element.setAttribute(`data-${key}`, value)\n    }\n  }\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends on the name of the attribute or property.\n *\n * @param {Element | Text} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    if (value instanceof Array) {\n      // @ts-ignore\n      element[attrOrPropName] = format.apply(null, value)\n    }\n    else {\n      // @ts-ignore\n      element[attrOrPropName] = value\n    }\n  }\n  else {\n    if ('setAttribute' in element) {\n      element.setAttribute(attrOrPropName, value)\n    }\n  }\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n *\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function modifyStyleRule(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {HTMLElement}\n */\nexport function stringToHTML(str) {\n  const parser = new DOMParser()\n  const doc    = parser.parseFromString(str, 'text/html')\n\n  return doc.body\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {boolean}\n */\nexport function objectHasKey(object, key) {\n  if (object instanceof Map || object instanceof Set) {\n    return object.has(key)\n  }\n  else {\n    return (key in object)\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {any}\n */\nexport function objectGetValue(object, key) {\n  if (object instanceof Map) {\n    return object.get(key)\n  }\n  else if (object instanceof Set) {\n    return object.has(key) ? key : undefined\n  }\n  else {\n    return object[key]\n  }\n}\n","/**\n * For each of the following tags a method will be created in the class below\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n * @see https://www.w3schools.com/tags/\n * @type {string[]}\n */\nconst htmlTags = [\n  'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', // 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n]\n\nexport { htmlTags }\n","class HtmlTemplateParserElement {\n  tagName = '-'\n\n  /** @type {HtmlTemplateParserElement} */\n  parent = this\n\n  /** @type {HtmlTemplateParserElement[]} */\n  children = []\n\n  /** @type {Object<string, any>} */\n  attributes = {}\n\n  /**\n   * Create a new instance of this class, but also put it\n   * into the list of children of the current instance\n   *\n   * @param {HtmlTemplateParserElement} parent\n   * @param {Object<string, any>} attributes\n   * @returns {HtmlTemplateParserElement}\n   */\n  newChild(parent, attributes) {\n    const child = new HtmlTemplateParserElement()\n\n    child.parent = parent\n    child.attributes = attributes\n\n    this.children.push(child)\n\n    return child\n  }\n}\n\nexport { HtmlTemplateParserElement }\n","/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n","import { isWhitespace, stringToBoolean } from '../functions.js'\nimport { HtmlTemplateParserElement } from './HtmlTemplateParserElement.js'\nimport { SELF_CLOSING_TAGS } from './constants.js'\n\n/**\n * This class is used to turn JS template literals (containing HTML code) into\n * properly ordered Template Tree.\n */\nclass HtmlTemplateParser {\n  #attrName = ''\n\n  /**\n   * The quote symbol in <...attr=\"value\"> - a single or a double quote.\n   * When the attribute has no quote, for example <...attr=123...>,\n   * the quote would be an empty space.\n   *\n   * @type {\"'\" | \"\\\"\" | \" \" | ''}\n   */\n  #attrQuote = ''\n\n  /** @type {any} */\n  #attrValue = ''\n\n  /** @type {Object<string, any>} */\n  #attributes = {}\n\n  /**\n   * Usually a string, but it could be function, boolean, number...\n   *\n   * @type {any}\n   */\n  #char\n\n  /** @type {any} */\n  #charPrevious\n\n  /** @type {any[]} */\n  #data = []\n\n  /**\n   * Would be set to the method that is going to be used for the next char iteration\n   *\n   * @type {() => void}\n   */\n  #stage = this.#stageNothing\n\n  #styleAttrName = ''\n\n  /** @type {any} */\n  #styleAttrValue = ''\n\n  /** @type {Object<string, any>} */\n  #styles = {}\n\n  #tagName = ''\n\n  #tagNameClosing = ''\n\n  #textContents = ''\n\n  /** @type {HtmlTemplateParserElement} */\n  #topElement = new HtmlTemplateParserElement()\n\n  /** @type {HtmlTemplateParserElement} */\n  #currentElement = this.#topElement\n\n  /**\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   */\n  constructor(strings, keys) {\n    this.#data = this.#mergeStringsAndKeys(strings, keys)\n\n    this.#rotate()\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @returns {(HTMLElement | Text)[]}\n   */\n  generate(elementsCreator) {\n    if (this.#tagName || this.#tagNameClosing) {\n      throw new Error('Some HTML tag is not closed')\n    }\n\n    const elements = this.#generateChildren(elementsCreator, this.#topElement)\n\n    return elements\n  }\n\n  /**\n   * @param {any} to\n   * @param {any} data\n   * @returns {any}\n   */\n  #appendData(to, data) {\n    if (typeof to === 'function') {\n      // The input is a function. In this case:\n      // If the data to append is also a function, return that function\n      // If the data to append is not a function, return the input\n      return (typeof data === 'function')\n        ? data\n        : to\n    }\n\n    return (\n      typeof to === 'string'\n      && (\n        typeof data === 'string'\n        || typeof data === 'number'\n        || typeof data === 'boolean'\n      )\n    )\n      ? to + data.toString()\n      : data\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @param {HtmlTemplateParserElement} element\n   * @returns {(HTMLElement | Text)[]}\n   */\n  #generateChildren(elementsCreator, element) {\n    /** @type {(HTMLElement | Text)[]} */\n    const output = []\n\n    for (const child of element.children) {\n      let el = null\n\n      if (child.tagName === 'if') {\n        el = elementsCreator.if(\n          stringToBoolean(child.attributes?.condition ?? ''),\n          () => this.#generateChildren(elementsCreator, child),\n        )\n      }\n      else if (child.tagName === 'for') {\n        if ('iterations' in child.attributes) {\n          el = elementsCreator.for(\n            0,\n            parseInt(child.attributes?.iterations ?? 0) - 1,\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n        else if ('from' in child.attributes || 'to' in child.attributes) {\n          el = elementsCreator.for(\n            parseInt(child.attributes?.from ?? 0),\n            parseInt(child.attributes?.to ?? 0),\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else if (child.tagName === 'forEach') {\n        if ('object' in child.attributes) {\n          el = elementsCreator.forEach(\n            child.attributes?.object ?? {},\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else {\n        el = elementsCreator.createElement(\n          child.tagName,\n          child.attributes,\n          this.#generateChildren(elementsCreator, child),\n        )\n\n        output.push(el)\n      }\n    }\n\n    return output\n  }\n\n  #makeNewElement() {\n    const parent = this.#currentElement\n    const attributes = this.#attributes\n\n    if (Object.keys(this.#styles).length > 0) {\n      attributes.style = this.#styles\n    }\n\n    const child = this.#currentElement.newChild(parent, attributes)\n\n    child.tagName = this.#tagName\n\n    this.#currentElement = child\n  }\n\n  /**\n   * JS Templates provide two arrays - a string array and keys array.\n   * This function is designed to merge these two into a single array.\n   *\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   * @returns {any[]}\n   */\n  #mergeStringsAndKeys(strings, keys=[]) {\n    const output = []\n\n    for (let index = 0; index < strings.length; index++) {\n      if (strings[index]) {\n        output.push(strings[index])\n      }\n\n      if (keys[index] !== undefined) {\n        output.push(keys[index])\n      }\n    }\n\n    return output\n  }\n\n  #rotate() {\n    for (\n      let dataIndex = 0;\n      dataIndex < this.#data.length;\n      dataIndex++\n    ) {\n      if (typeof this.#data[dataIndex] === 'string') {\n        for (\n          let charIndex = 0;\n          charIndex < this.#data[dataIndex].length;\n          charIndex++\n        ) {\n          this.#char         = this.#data[dataIndex][charIndex]\n          this.#charPrevious = this.#data[dataIndex][charIndex - 1]\n\n          // this.#char, this.#stage.name)\n\n          this.#stage()\n        }\n      }\n      else {\n        this.#char = this.#data[dataIndex]\n        this.#charPrevious = undefined\n\n        // console.log(this.#char, this.#stage.name)\n\n        this.#stage()\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setAttribute(name, value) {\n    if (!name) return\n\n    this.#attributes[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  /**\n   * @param {() => void} stage\n   */\n  #setStage(stage) {\n    // Actions to do before a given stage is set\n    if (stage === this.#stageAttrName) {\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n    }\n\n    // Set the stage\n    this.#stage = stage\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setStyle(name, value) {\n    if (!name) return\n\n    this.#styles[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  #stageAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '/') {\n      if (SELF_CLOSING_TAGS.includes(this.#tagName)) {\n        this.#makeNewElement()\n      }\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === '=') {\n      this.#setStage(this.#stageAttrOpenQuote)\n    }\n    else {\n      this.#attrName += this.#char\n    }\n  }\n\n  #stageAttrOpenQuote() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '\\'' || this.#char === '\"') {\n      this.#attrQuote = this.#char\n\n      this.#setStage(\n        (this.#attrName === 'style')\n          ? this.#stageStyleAttrName\n          : this.#stageAttrValue,\n      )\n    }\n    else {\n      // Value without quotes.\n      // Whitespaces are allowed before the value, but not after.\n      // For that reason, the quote would be a whitespace here\n\n      this.#attrQuote = ' '\n      this.#attrValue = this.#appendData(this.#attrValue, this.#char)\n\n      this.#setStage(this.#stageAttrValue)\n    }\n  }\n\n  #stageAttrValue() {\n    if (this.#char === '>' && this.#charPrevious !== '/') {\n      // When > is found, but the attribute wasn't closed properly.\n      // Could happen if the quote is an empty space, for example: <...attr=true>\n      // Or even unclosed quote, for example: <...attr=\"value>\n      if (this.#attrQuote && this.#attrName && this.#attrValue) {\n        this.#setAttribute(this.#attrName, this.#attrValue)\n      }\n\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n\n      this.#setStage(this.#stageNothing)\n\n      this.#makeNewElement()\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setAttribute(this.#attrName, this.#attrValue)\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#attrValue += this.#char\n    }\n  }\n\n  #stageNothing() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '<') {\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      // In HTML when there are multiple spaces before or after a text,\n      // only one could be visualized. So if\n      if (this.#charPrevious === ' ') {\n        this.#textContents = this.#charPrevious + this.#char\n      }\n      else {\n        this.#textContents = this.#char\n      }\n\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTextContents)\n    }\n  }\n\n  #stageStyleAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setStage(this.#stageAttrName)\n    }\n    else if (this.#char === ':') {\n      this.#setStage(this.#stageStyleAttrValue)\n    }\n    else {\n      this.#styleAttrName += this.#char\n    }\n  }\n\n  #stageStyleAttrValue() {\n    if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === ';') {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageStyleAttrName)\n    }\n    else if (this.#char === this.#attrQuote) {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#styleAttrValue = this.#appendData(this.#styleAttrValue, this.#char)\n    }\n  }\n\n  /**\n   * In this stage we have just detected \"<\" and we are in HTML tag.\n   * This tag could be a new tag, or it could be the closing tag.\n   *\n   * @returns {void}\n   */\n  #stageTag() {\n    if (isWhitespace(this.#char)) {\n      if (this.#tagName !== '') {\n        this.#setStage(this.#stageAttrName)\n      }\n    }\n    else if (this.#char === '/' && SELF_CLOSING_TAGS.includes(this.#tagName)) {\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      if (!this.#tagName) {\n        throw new Error('Expected tag name, found >')\n      }\n\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#charPrevious === '<' && this.#char === '/') {\n      if (!this.#tagName) {\n        //throw new Error('no tag name')\n      }\n\n      this.#tagNameClosing = ''\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else {\n      this.#tagName += this.#char\n    }\n  }\n\n  #stageTagToClose() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      if (\n        this.#currentElement.tagName // Empty if text node\n        && this.#currentElement.tagName !== '-'\n        && !SELF_CLOSING_TAGS.includes(this.#currentElement.tagName)\n        && this.#currentElement.tagName !== this.#tagNameClosing\n      ) {\n        throw new Error(`Expected ${this.#currentElement.tagName} tag to be closed, but ${this.#tagNameClosing} found`)\n      }\n\n      this.#tagName = ''\n      this.#tagNameClosing = ''\n\n      if (\n        !this.#currentElement.tagName // Text node\n      ) {\n        this.#currentElement = this.#currentElement.parent.parent\n      }\n      else {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#setStage(this.#stageNothing)\n    }\n    else {\n      this.#tagNameClosing += this.#char\n    }\n  }\n\n  #stageTextContents() {\n    if (this.#char === '<') {\n      // Reset what was possibly used for text node\n      this.#attributes = {}\n      this.#currentElement.attributes.textContent = this.#textContents\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      this.#textContents = this.#appendData(this.#textContents, this.#char)\n\n      if (!this.#currentElement.tagName) {\n        this.#currentElement.attributes.textContent = this.#textContents\n      }\n    }\n  }\n}\n\nexport { HtmlTemplateParser }\n","import { ElementsCollector } from './ElementsCollector.js'\nimport {\n  addChildrenToStack,\n  addChildToStack,\n  addEventListenerIfPossible,\n  appendChildrenToElement,\n  arrayRemoveKey,\n  forEachLoop,\n  forLoop,\n  format,\n  getGlobalObject,\n  insertAfter,\n  isEventAttribute,\n  modifyStyleRule,\n  objectHasKey,\n  setDataSetAttributesToElement,\n  setElementAttrOrProp,\n  stringToHTML,\n} from './functions.js'\nimport { htmlTags } from './htmlTags.js'\nimport { HtmlTemplateParser } from './HtmlTemplateParser/HtmlTemplateParser.js'\nimport { Component } from './Component.js'\nimport { isState } from './State.js'\nimport { setSuggestItems, unsetSuggestedItems } from './StateSubscriptions.js'\n\n/**\n * @typedef {Array<{key: (string | number | symbol), elements: (Node)[]}>} RenderedElementsMap\n */\n\nclass ElementsCreator {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the\n   * elements separately. Then, when the IF or FOR statement ends, the\n   * collected elements are moved to the upper level and that new level\n   * is deleted.\n   *\n   * @type {ElementsCollector[]}\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {Element | ShadowRoot | null}\n   */\n  #containerElement\n\n  /** @type {Document} */\n  #document\n\n  /** @type {HTMLTemplateElement} */\n  #dummyHtmlElement\n\n  /**\n   * Is String-Rendering mode\n   *\n   * @type {boolean}\n   */\n  #isSr = true\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /** @type {Window} */\n  #window\n\n  /**\n   * @param {Window} window\n   * @param {HTMLElement | Element | ShadowRoot | null} containerElement\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} [translations=[]]\n   */\n  constructor(window, containerElement, templates, translations = []) {\n    this.#window = window\n    this.#document = window.document\n    this.#isSr = this.#document.baseURI === ''\n    this.#containerElement = containerElement\n    this.#templates = templates\n    this.#translations = translations\n\n    this.#dummyHtmlElement = this.#document.createElement('template')\n  }\n\n  appendChildrenToContainer() {\n    const containerElement = this.#containerElement\n\n    if (containerElement) {\n      appendChildrenToElement(containerElement, this.getCreatedElements())\n    }\n  }\n\n  /**\n   * Create HTML element\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * Different variants are possible:<br>\n   * - String value - It will be textContent of the element. Use this in div tags and similar.\n   * - Object value - For all the properties of the element, like \"id\", \"class\" and so on...\n   * - Element (multiple arguments) - For other calls of this same function (creating children)\n   * - Array - Alternative for creating children\n   * @returns {HTMLElement | Text}\n   */\n  createElement(tagName, ...args) {\n    const element = (tagName)\n      ? this.#document.createElement(tagName)\n      : this.#document.createTextNode('')\n\n    /** @type {any[]} */\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string') {\n        // In case of a string, create a new text node.\n        // This way, multiple text nodes can be put into the element,\n        // mixed with http elements.\n\n        const textNode = this.#document.createTextNode(\n          this.#translate(argument),\n        )\n\n        children = addChildToStack(textNode, children)\n      }\n      else if (typeof argument === 'number') {\n        // The number is converted into a string\n\n        const textNode = this.#document.createTextNode(argument.toString())\n\n        children = addChildToStack(textNode, children)\n      }\n      // @ts-ignore\n      else if (argument instanceof this.#window.Node) {\n        // This is a child, created by this function, to be appended to its parent\n        children = addChildToStack(argument, children)\n      }\n      else if (argument instanceof Array) {\n        if (argument.length === 0) {\n          continue\n        }\n\n        let isChildrenArray = false\n\n        for (const child of argument) {\n          if (\n            // @ts-ignore\n            child instanceof this.#window.Node // Node includes HTMLElement and Comment\n          ) {\n            isChildrenArray = true\n\n            break\n          }\n        }\n\n        // Case 1) Array, containing at least one child to be added to their parent\n        // In DOM, if some elements are not children, they are turned into strings,\n        // but the same produces error in SSR\n        if (isChildrenArray) {\n          children = addChildrenToStack(argument, children)\n        }\n        // Case 2) Array, containing string to be formatted\n        else {\n          const textNode = this.#document.createTextNode(\n            this.#arrayTranslateFormatTranslate(argument),\n          )\n\n          children = addChildToStack(textNode, children)\n        }\n      }\n      else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = this.#translate(argument.message)\n      }\n      else if (argument instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? argument.getElementsSr()\n          : argument.getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          for (const child of childrenGroup) {\n            children = addChildToStack(child, children)\n          }\n        }\n      }\n      else if (argument instanceof Function) {\n        if (this.#isSr) {\n          // @ts-ignore\n          element.innerHTML = `(${argument.toString()})()`\n        }\n        else {\n          if (element instanceof HTMLScriptElement) {\n            const inlineScript = this.#document.createTextNode(`(${argument.toString()})()`)\n            element.appendChild(inlineScript)\n          }\n          else {\n            if (\n              'value' in element\n              && !(element instanceof HTMLLIElement) // <li> has value, but it accepts only numbers\n            ) {\n              this.#setPropertiesToElement(element, { value: argument })\n            }\n            else {\n              const textNode = this.#document.createTextNode('')\n\n              this.#setPropertiesToElement(textNode, { textContent: argument })\n\n              children = addChildToStack(textNode, children)\n            }\n          }\n        }\n      }\n      else if (\n        argument instanceof Object\n        && !(argument instanceof Function)\n        && argumentID === 1\n      ) {\n        // If Object, and the first argument, this is a property.\n        // This condition needs to be at the end of the 'if' chain.\n\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].removeTheseElements(children)\n    this.#collectedElements[level].addElement(element)\n\n    return element\n  }\n\n  /**\n   * For loop with from-to numbers\n   *\n   * @param {number} from\n   * @param {number} to\n   * @param {ForLoopIterableCallback} handler\n   * @returns {Node[] | Error}\n   */\n  for(from, to, handler) {\n    const callback = () => {\n      const result = forLoop(from, to, handler)\n\n      if (result instanceof Error) console.error(result)\n    }\n\n    return this.#statementHandler('for', null, callback)\n  }\n\n  /**\n   * \"for\" loop for objects, arrays, maps and sets\n   *\n   * @template T\n   * @param {T | function() : T} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forEach(input, handler) {\n    return this.#forEachLoop(1, input, handler)\n  }\n\n  /**\n   * \"for\" loop for states\n   *\n   * @template T\n   * @param {State} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forState(input, handler) {\n    return this.#forEachLoop(2, input, handler)\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  getCreatedElements() {\n    return this.#collectedElements[0].getElements()\n  }\n\n  /**\n   * - Browser mode: Returns an empty string\n   * - Server mode: Generate HTML code of the elements at level 0\n   *\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   * - Browser mode: Empty string\n   * - Server mode: The final HTML code\n   */\n  getHtmlCode(htmlOptions) {\n    let htmlCode = ''\n\n    if (this.#isSr) {\n      const containerElement = this.#containerElement\n\n      if (containerElement) {\n        // @ts-ignore\n        htmlCode = containerElement.paintChildren(htmlOptions)\n      }\n    }\n\n    return htmlCode\n  }\n\n  /**\n   * @param {string[] | string} strings\n   * A string when html is used as a function, or an array of strings when used as template\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  html(strings, ...keys) {\n    const elements = (\n      keys.length === 0\n      && this.#translations.length === 0 // the faster method doesn't translate anything\n    )\n      ? this.#htmlForSimpleString((strings instanceof Array) ? strings[0] : strings)\n      : this.#htmlForTemplateLiteral((strings instanceof Array) ? strings : [strings], ...keys)\n\n    for (const element of elements) {\n      if (\n        // Dummy tag (virtual mode) when simple string, or text node when template literal\n        // In both cases the tag name is an empty string\n        // @ts-ignore\n        element.tagName === ''\n      ) {\n        element.textContent = this.#translate(element.textContent)\n      }\n    }\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   *\n   * @param {boolean | StatementBindFunction} condition\n   * @param {function():void} handler\n   * @param {function():void} [elseHandler]\n   * @returns {Node[]}\n   */\n  if(condition, handler, elseHandler) {\n    /**\n     * If the condition is a value (true or false), the elements\n     * are either created or not.\n     *\n     * If the condition is a function, two helper Comment elements\n     * are created - one in the beginning and another at the end.\n     * All normal elements are placed in between.\n     */\n\n    /**\n     * @param {any} data\n     */\n    const callback = (data) => {\n      if (Boolean(data)) {\n        if (typeof handler === 'function') {\n          handler()\n        }\n      }\n      else {\n        if (typeof elseHandler === 'function') {\n          elseHandler()\n        }\n      }\n    }\n\n    return (condition instanceof Function)\n      ? this.#statementHandlerForFunction('if', condition, callback)\n      : this.#statementHandler('if', condition, callback)\n  }\n\n  render() {\n    this.#collectedElements = [new ElementsCollector()] // Reset\n\n    for (const template of this.#templates) {\n      if (template instanceof Function) {\n        // @ts-ignore\n        const returnedValue = template(this)\n\n        if (returnedValue && typeof returnedValue === 'string') {\n          this.html(returnedValue)\n        }\n        else if (returnedValue instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            // @ts-ignore\n            ? returnedValue.useTranslations(this.#translations).getElementsSr()\n            // @ts-ignore\n            : returnedValue.useTranslations(this.#translations).getElements()\n\n          for (const childrenGroup of generatedChildren) {\n            this.#collectedElements[0].addElements(childrenGroup)\n          }\n        }\n        else if (returnedValue instanceof Function) {\n          // @ts-ignore\n          returnedValue(this)\n        }\n        else if (returnedValue instanceof Array) {\n          let allComponents   = true\n          let allFunctions = true\n\n          for (const value of returnedValue) {\n            if (!(value instanceof Component)) {\n              allComponents = false\n\n              break\n            }\n\n            if (!(value instanceof Function)) {\n              allFunctions = false\n\n              break\n            }\n          }\n\n          if (allComponents) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Component)) break\n\n              const generatedChildren = (this.#isSr)\n                ? value.getElementsSr()\n                : value.getElements()\n\n              for (const childrenGroup of generatedChildren) {\n                this.#collectedElements[0].addElements(childrenGroup)\n              }\n            }\n          }\n          else if (allFunctions) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Function)) break\n\n              // @ts-ignore\n              value(this)\n            }\n          }\n        }\n      }\n      else if (template instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? template.useTranslations(this.#translations).getElementsSr()\n          : template.useTranslations(this.#translations).getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          this.#collectedElements[0].addElements(childrenGroup)\n        }\n      }\n    }\n\n    this.appendChildrenToContainer()\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler.\n   *\n   * @param {object} input\n   * @param {number} input.thisLevel\n   * @param {number} input.upperLevel\n   * @returns {Node[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n    this.#collectedElements[thisLevel].removeAllElements()\n\n    // ... and clean this level\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  /**\n   * @template T\n   * @param {T[]} array\n   * @returns {(string | T)[]}\n   */\n  #arrayTranslate(array) {\n    const needsTranslation = Boolean(this.#translations)\n\n    return (needsTranslation)\n      ? array.map((value) => this.#translate(value))\n      : array\n  }\n\n  /**\n   * This function first translations each part of the input array,\n   * then formats it, then translations the result.\n   *\n   * @template T\n   * @param {T[]} array\n   * The input array is supposed to be what would format() arguments be\n   * (format string plus multiple arguments), but as an array.\n   * @returns {string}\n   */\n  #arrayTranslateFormatTranslate(array) {\n    return this.#translate(\n      format.apply(\n        null,\n        // @ts-ignore\n        this.#arrayTranslate(array),\n      ),\n    )\n  }\n\n  /**\n   * Prepare the levels to be used in IF or FOR loop, and return them.\n   * This method must be called in the IF or FOR loop, before calling\n   * the handler.\n   *\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    const thisLevel = this.#collectedElements.length\n    const upperLevel = thisLevel - 1\n\n    this.#collectedElements.push(new ElementsCollector())\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * @template T\n   * @param {ForLoopType} forLoopType\n   * @param {(T | function() : T) | State} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  #forEachLoop(forLoopType, input, handler) {\n    /**\n     * @param {any} value\n     * @returns {any}\n     */\n    const beforeIterationCallback = (value) => {\n      return this.#translate(value)\n    }\n\n    if (isState(input)) {\n      /**\n       * @param {State} data\n       * @param {ElementsCollector} elementsCollector\n       * @param {string | number | symbol} [keyToRender]\n       * @returns {RenderedElementsMap}\n       */\n      const callbackForState = (data, elementsCollector, keyToRender) => {\n        /** @type {RenderedElementsMap} */\n        const renderedElementsMap = []\n\n        /**\n         * Initially there is 1 element - the forEach-begin element.\n         * We want to start after this element.\n         */\n        let index = elementsCollector.getElements().length\n\n        /**\n         * @param {number | string} key\n         */\n        const onIteration = (key) => {\n          const elementsFromCollector = elementsCollector.getElements()\n          const elements = elementsFromCollector.slice(index)\n\n          renderedElementsMap.push({ key, elements })\n\n          index = elementsFromCollector.length\n        }\n\n        forEachLoop(forLoopType, data, handler, beforeIterationCallback, keyToRender, onIteration)\n\n        return renderedElementsMap\n      }\n\n      return this.#statementHandlerForState('forEach', input, callbackForState)\n    }\n\n    /**\n     * @param {State} data\n     */\n    const callback = (data) => {\n      forEachLoop(forLoopType, data, handler, beforeIterationCallback)\n    }\n\n    if (input instanceof Function) {\n      // @ts-ignore\n      return this.#statementHandlerForFunction('forEach', input, callback)\n    }\n\n    return this.#statementHandler('forEach', input, callback)\n  }\n\n  /**\n   * Quicker version for the 'html' function that does not use parsing,\n   * because the input is just a single string.\n   *\n   * @param {string} string\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForSimpleString(string) {\n    /** @type {(Element | Node)[]} */\n    let elements = []\n\n    if (this.#isSr) {\n      // We create a new dummy element every time.\n      // An element with no tag name is skipped in the render stage.\n      const element = this.#document.createElement('')\n\n      element.innerHTML = string ?? ''\n\n      elements = [element]\n    }\n    else {\n      if (false && 'DOMParser' in this.#document) {\n        // @ts-ignore\n        elements = stringToHTML(string.trim() ?? '').childNodes\n      }\n      else {\n        // In DOM, we can reuse the same element\n        const template = this.#dummyHtmlElement\n\n        //element.setHTML(string.trim() ?? '')\n        template.innerHTML = string.trim() ?? ''\n\n        // childNodes also contains the text nodes\n        elements = Array.from(template.content.childNodes)\n\n        template.innerHTML = ''\n      }\n    }\n\n    // Add the newly created elements into the collection\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].addElements(elements)\n\n    return elements\n  }\n\n  /**\n   * @param {string[]} strings\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForTemplateLiteral(strings, ...keys) {\n    const htmlTemplateParser = new HtmlTemplateParser(strings, keys)\n\n    return htmlTemplateParser.generate(this)\n  }\n\n  /**\n   * @param {Comment} beginCommentElement\n   * @param {Node[]} elements\n   * @returns {boolean}\n   * Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginCommentElement, elements) {\n    if (!(this.#containerElement?.contains(beginCommentElement))) {\n      return false\n    }\n\n    /** @type {Node|Comment} */\n    let lastElement = beginCommentElement\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are a pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   *\n   * @param {Comment} beginCommentElement\n   * - The 'begin' Comment element\n   * @returns {number}\n   * - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginCommentElement) {\n    /**\n     * @type {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n     */\n    const COMMENT_NODE = 8 // Node.COMMENT_NODE\n\n    if (beginCommentElement.nodeType !== COMMENT_NODE) {\n      return -1\n    }\n\n    // Decide what will be the text content of the end element\n    const beginCommentElementText = beginCommentElement.textContent\n    let endElementText = ''\n\n    if (beginCommentElementText) {\n      endElementText = beginCommentElementText.slice(0, -6) + '-end'\n    }\n    else {\n      return -1\n    }\n\n    /**\n     * Delete elements between the 'begin' and 'end' element,\n     * including inner 'begin' and 'end' elements\n     */\n\n    let currentElement = beginCommentElement.nextSibling\n    let statementsCounter = 0\n    let deletedElementsCount = 0\n\n    while (true) {\n      if (currentElement === null) {\n        break\n      }\n\n      if (currentElement.nodeType === COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginCommentElementText) { // inner 'begin' element\n          statementsCounter += 1\n        }\n        else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0) {\n            break\n          }\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      this.#unsubscribeElementAndItsChildren(currentElement)\n\n      currentElement.remove()\n      deletedElementsCount += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElementsCount\n  }\n\n  /**\n   * @param {HTMLElement | Text} element\n   * @param {Object<string, string|number|Object<*,*>|function(*):*|BindFunction>} properties\n   */\n  #setPropertiesToElement(element, properties) {\n    for (const propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#isSr) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function) {\n          setElementAttrOrProp(element, propertyName, property)\n\n          continue\n        }\n      }\n      else if (property instanceof Function) {\n        // If the property name is an event (for example onClick),\n        // then the property is a function. This function should not\n        // be immediately called to get a value from it. Instead, it\n        // should be added as a listener.\n        if (addEventListenerIfPossible(element, propertyName, property)) {\n          continue\n        }\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        /** @type {BindFunction} */\n        const bindFunction = property\n\n        // this.#subscribeToBindings({\n        //   element,\n        //   propertyName,\n        //   bindFunction,\n        // })\n\n        setSuggestItems(\n          element,\n          propertyName,\n          '',\n          bindFunction,\n          null,\n        )\n\n        let value = bindFunction(element)\n\n        if (value instanceof Function) {\n          /**\n           * Remark \"() => value\"\n           *\n           * In forEach the value is provided as a function, so it is not necessary\n           * to use it like this () => value. However, when used like this, the function\n           * returns a function. Resolve the returned function here.\n           */\n          value = value()\n        }\n\n        unsetSuggestedItems()\n\n        if (value instanceof Array) {\n          value = this.#arrayTranslateFormatTranslate(value)\n        }\n        else if (typeof value === 'string') {\n          value = this.#translate(value)\n        }\n\n        setElementAttrOrProp(element, propertyName, value)\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'style'\n        && property instanceof Object\n      ) {\n        // @ts-ignore\n        this.#setStylesToElement(element, property)\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'data'\n      ) {\n        if (property instanceof Object) {\n          // @ts-ignore\n          setDataSetAttributesToElement(element, property)\n        }\n      }\n      else if (propertyName === 'textContent') {\n        if (property instanceof Array) {\n          element[propertyName] = this.#arrayTranslateFormatTranslate(property)\n        }\n        else {\n          element[propertyName] = this.#translate(property)\n        }\n      }\n      else {\n        if (\n          propertyName === 'innerText'\n          || (\n            propertyName === 'value'\n            && (\n              // Can't use HTMLInputElement here, because it does not exist in SrDOM\n              // @ts-ignore\n              element.tagName === 'INPUT'\n              // @ts-ignore\n              && (element.getAttribute('type') ?? '').toLowerCase() === 'button'\n            )\n          )\n        ) {\n          property = this.#translate(property)\n        }\n\n        setElementAttrOrProp(element, propertyName, property)\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<keyof CSSStyleDeclaration, (string | BindFunction)>} styleRules\n   */\n  #setStylesToElement(element, styleRules) {\n    for (const ruleName in styleRules) {\n      const ruleValue = styleRules[ruleName]\n      let finalValue  = ''\n\n      if (ruleValue instanceof Function) {\n        const propertyName = 'style'\n        const bindFunction = ruleValue\n\n        // this.#subscribeToBindings({\n        //   element,\n        //   propertyName,\n        //   subPropertyName: ruleName,\n        //   bindFunction,\n        // })\n\n        setSuggestItems(\n          element,\n          propertyName,\n          ruleName,\n          bindFunction,\n          null,\n        )\n\n        finalValue = bindFunction(element)\n\n        unsetSuggestedItems()\n      }\n      else {\n        finalValue = ruleValue\n      }\n\n      if (typeof ruleName === 'string') {\n        // @ts-ignore\n        element.style[ruleName] = modifyStyleRule(ruleName, finalValue)\n      }\n    }\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach'} type\n   * @param {any} data\n   * @param {function(any): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandler(type, data, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    callback(data)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach'} type\n   * @param {function(): any} bindFunction\n   * @param {function(boolean | State): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForFunction(type, bindFunction, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n    const isFunction = bindFunction instanceof Function\n\n    if (isFunction) {\n      const commentElementBegin = this.#document.createComment(`${type}-begin`)\n      const commentElementEnd   = this.#document.createComment(`${type}-end`)\n\n      this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n      /**\n       * @type {StatementRepaintFunction}\n       */\n      const statementRepaintFunction = (bindFunctionResult) => {\n        // Clean all contents.\n        this.#collectedElements[0].removeAllElements()\n        this.#removeStatementElements(commentElementBegin)\n\n        // Create the new elements\n        callback(bindFunctionResult)\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[0].getElements(),\n        )\n\n        if (!success) {\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n        }\n      }\n\n      const element = commentElementBegin\n      const propertyName = `--${type}` // --if or --for\n\n      setSuggestItems(\n        element,\n        propertyName,\n        '',\n        bindFunction,\n        statementRepaintFunction,\n      )\n\n      const resolved = bindFunction()\n\n      // TODO maybe this one should be below the callback below?\n      unsetSuggestedItems()\n\n      // Run the handler function\n      callback(resolved)\n\n      this.#collectedElements[thisLevel].addElement(commentElementEnd)\n    }\n    else {\n      const resolved = bindFunction\n\n      // Run the handler function\n      callback(resolved)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'forEach'} type\n   * @param {any} state\n   * @param {function(\n   *   State, ElementsCollector, (string | number | symbol)=\n   * ): RenderedElementsMap} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForState(type, state, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    const commentElementBegin = this.#document.createComment(`${type}-begin`)\n    /**\n     * Use the 'end' comment element as a storage for the rendered elements.\n     * It's easier this way, and if the element is being deleted along with\n     * the rendered elements, no references to these elements would remain.\n     *\n     * @type {Comment & {renderedElementsMap: RenderedElementsMap}}\n     */\n    // @ts-ignore\n    const commentElementEnd = this.#document.createComment(`${type}-end`)\n\n    this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n    /**\n     * TODO Refactor this function, because it's too long\n     *\n     * @type {StatementRepaintFunction} updatedState\n     */\n    const statementRepaintFunction = (updatedState) => {\n      if (!(updatedState instanceof Object)) {\n        return\n      }\n\n      // Remove what is not in the updated state\n      for (let i = commentElementEnd.renderedElementsMap.length - 1; i >= 0; i--) {\n        const item = commentElementEnd.renderedElementsMap[i]\n\n        if (!(objectHasKey(updatedState, item.key))) {\n          item.elements.forEach((element) => {\n            // @ts-ignore\n            element.remove()\n          })\n\n          commentElementEnd.renderedElementsMap\n            = arrayRemoveKey(commentElementEnd.renderedElementsMap, i)\n        }\n      }\n\n      /**\n       * @type {Node}\n       */\n      let lastElement = commentElementBegin\n\n      // Add what is not in the updated state\n      const renderedElementsMapNew = []\n\n      const keys = (\n        updatedState instanceof Map\n        || updatedState instanceof Set\n        || updatedState instanceof Array\n      )\n        ? updatedState.keys()\n        : Object.keys(updatedState)\n\n      for (let i of keys) {\n        /**\n         * When Array, if an element is deleted, the key remains and the\n         * value is undefined. But also, the array iterates differently\n         * when 'of' or 'in' is used. With 'of', the deleted value is iterated,\n         * while with 'if' it's not. That's why this 'in' is here, to prevent\n         * iteration of deleted array elements.\n         */\n        if (!(i in updatedState)) {\n          continue\n        }\n\n        let isKeyInRenderedElementsMap = false\n\n        for (const item of commentElementEnd.renderedElementsMap) {\n          if (item.key === i) {\n            const { elements } = item\n\n            lastElement = (elements.length > 0)\n              ? elements[elements.length - 1]\n              : lastElement\n            renderedElementsMapNew.push(item)\n            isKeyInRenderedElementsMap = true\n\n            break\n          }\n        }\n\n        if (!isKeyInRenderedElementsMap) {\n          const added = callback(\n            updatedState,\n            this.#collectedElements[0],\n            i,\n          )\n\n          for (const item of added) {\n            renderedElementsMapNew.push(item)\n\n            // eslint-disable-next-line @typescript-eslint/no-loop-func\n            item.elements.forEach((element) => {\n              // @ts-ignore\n              lastElement.after(element)\n              lastElement = element\n            })\n          }\n        }\n      }\n\n      commentElementEnd.renderedElementsMap = renderedElementsMapNew\n    }\n\n    const propertyName = `-s-${type}` // --if or --for\n    const bindFunction = () => state\n\n    setSuggestItems(\n      commentElementEnd,\n      propertyName,\n      '',\n      bindFunction,\n      statementRepaintFunction,\n    )\n\n    // In this callback the for loop is called\n    commentElementEnd.renderedElementsMap = callback(\n      state,\n      this.#collectedElements[thisLevel],\n    )\n\n    unsetSuggestedItems()\n\n    this.#collectedElements[thisLevel].addElement(commentElementEnd)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {any} input\n   * @returns {string}\n   */\n  #translate(input) {\n    if (typeof input === 'string') {\n      const translated = this.#translateString(input, this.#translations)\n\n      if (typeof translated === 'string') {\n        return translated\n      }\n\n      // Use the global translation\n      const globalObject = getGlobalObject()\n\n      const globallyTranslated = this.#translateString(\n        input,\n        // @ts-ignore\n        globalObject?.paintorTranslations,\n      )\n\n      if (typeof globallyTranslated === 'string') {\n        return globallyTranslated\n      }\n    }\n\n    return input\n  }\n\n  /**\n   * @param {string} str\n   * @param {Translation[]} [translations]\n   * @returns {string | boolean}\n   */\n  #translateString(str, translations) {\n    if (translations instanceof Array && translations.length > 0) {\n      for (const translateObject of translations) {\n        if (str in translateObject) {\n          return translateObject[str]\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Recursively search in an element's child nodes for\n   * elements, who are used in state subscriptions, and\n   * unsubscribe them. Also unsubscribe the initial element.\n   *\n   * Note: This function works only on the browser!\n   *\n   * @param {Node} element\n   */\n  #unsubscribeElementAndItsChildren(element) {\n    if (Object.hasOwn(element, '--subscribed')) {\n      Object.assign(element, { '--deleted': true })\n    }\n\n    /**\n     * Unsubscribe each child element recursively.\n     *\n     * Performance Notes:\n     * - This loop is reached too often for its performance to be ignored\n     * - Used .forEach() before, but while loop is more than 30% faster\n     */\n\n    let index = element.childNodes.length\n\n    while (index--) {\n      this.#unsubscribeElementAndItsChildren(element.childNodes[index])\n    }\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\n\n/**\n * @see https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n * @param {...any} boundArgs\n * @returns {function(...[*]):*}\n * @this {any}\n */\nfunction bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  /**\n   * @param {...any} args\n   * @returns {any}\n   * @this {any}\n   */\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\nconst { prototype } = ElementsCreator\n\n// prototype.createElement.bindArgs = bindArgs\nObject.assign(prototype.createElement, { bindArgs })\n\nhtmlTags.forEach((tagName) => {\n  // @ts-ignore\n  prototype[tagName] = prototype.createElement.bindArgs(tagName)\n})\n\nexport { ElementsCreator }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @enum {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = Object.freeze([\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n])\n\n/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from\n * each other, such as elements, text and comments.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const EnumNodeTypes = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n})\n","export class DOMException extends Error {\n  /**\n   * @param {string} message\n   * @param {string} [name]\n   */\n  constructor(message, name) {\n    super(message)\n    this.name = name ?? 'DOMException'\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { paint } from './functions.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\nclass Node {\n  /** @type {Node | null} */\n  nextSibling = null\n\n  /** @type {Node | null} */\n  previousSibling = null\n\n  /** @type {string} */\n  textContent = ''\n\n  /** @type {Node[]} */\n  #childNodes = []\n\n  /**\n   * @type {string}\n   */\n  #nodeName = ''\n\n  /** @type {number} */\n  #nodeType = 1\n\n  /** @type {Node | null} */\n  #parentNode = null\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} nodeName\n   */\n  constructor(nodeType, nodeName) {\n    this.#nodeType = nodeType\n    this.#nodeName = nodeName\n  }\n\n  /**\n   * @returns {string}\n   */\n  get baseURI() {\n    return ''\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  get childNodes() {\n    return this.#childNodes\n  }\n\n  /**\n   * @returns {Node | null}\n   */\n  get firstChild() {\n    return this.#childNodes[0] ?? null\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @returns {string}\n   */\n  get nodeName() {\n    return this.#nodeName\n  }\n\n  /**\n   * @returns {number}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentnode.asp\n   * @returns {Node | null}\n   */\n  get parentNode() {\n    return this.#parentNode\n  }\n\n  /**\n   * Not in DOM\n   *\n   * @param {Node | null} parentNode\n   */\n  set parentNode(parentNode) {\n    this.#parentNode = parentNode\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\n   *\n   * @param {Node} aChild\n   * @throws {DOMException | TypeError}\n   */\n  appendChild(aChild) {\n    // If the parent of aChild is not a Document, DocumentFragment, or an Element.\n    if (\n      this.nodeType !== EnumNodeTypes.DOCUMENT_NODE\n      && this.nodeType !== EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n      && this.nodeType !== EnumNodeTypes.ELEMENT_NODE\n    ) {\n      throw new DOMException('This node type does not support this method.')\n    }\n\n    // If the insertion of aChild would lead to Document with more than one Element as child.\n    // (document should contain body here, which is an Element)\n    if (\n      this.nodeType === EnumNodeTypes.DOCUMENT_NODE\n    ) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': Only one element on document allowed.')\n    }\n\n    // If aChild is not a DocumentFragment, a DocumentType, an Element, or a CharacterData.\n    if (!(aChild instanceof Node)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Node\\''\n        + ': parameter 1 is not of type \\'Node\\'.'\n\n      throw new TypeError(errorMessage)\n    }\n\n    // If the node already exists, do not append it\n    if (this.#childNodes.includes(aChild)) {\n      return\n    }\n\n    if (aChild === this) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': The new child element contains the parent.')\n    }\n\n    this.#childNodes.push(aChild)\n    aChild.parentNode = this\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#childNodes.length - 2\n\n    if (prevKey >= 0) {\n      this.#childNodes[prevKey].nextSibling = aChild\n      aChild.previousSibling = this.#childNodes[prevKey] ?? null\n    }\n  }\n\n  /**\n   * TODO Make this function do whatever it has to do\n   *\n   * @returns {boolean}\n   */\n  contains() {\n    return false\n  }\n\n  /**\n   * TODO Check whether this function works correctly\n   *\n   * @param {Node} newElement\n   * @param {Node} referenceElement\n   * @returns {Node}\n   */\n  insertBefore(newElement, referenceElement) {\n    /** @type {Node[]} */\n    const newChildren = []\n\n    for (const child of this.#childNodes) {\n      if (child === referenceElement) {\n        newChildren.push(newElement)\n      }\n\n      newChildren.push(child)\n    }\n\n    this.#childNodes = newChildren\n\n    return newElement\n  }\n\n  /**\n   * Removes a child node and returns the removed node.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n   * @param {Node} childNode\n   * @returns {Node}\n   */\n  removeChild(childNode) {\n    if (!childNode) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'parameter 1 is not of type \\'HTMLElement\\'.',\n      )\n    }\n\n    if (!this.#childNodes.includes(childNode)) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'The node to be removed is not a child of this node.',\n      )\n    }\n\n    this.#childNodes = this.#childNodes.filter((node) => node !== childNode)\n\n    return childNode\n  }\n\n  /**\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   */\n  paintChildren({ indent = '' }) {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.childNodes) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += paint(child, indent, '', isChild)\n    }\n\n    return children\n  }\n}\n\nexport { Node }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Comment extends Node {\n  constructor() {\n    super(EnumNodeTypes.COMMENT_NODE, '#comment')\n  }\n}\n\nexport default Comment\n\nexport { Comment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Text extends Node {\n  constructor() {\n    super(EnumNodeTypes.TEXT_NODE, '#text')\n  }\n}\n\nexport { Text }\n","import { Comment } from './Comment.js'\nimport { BOOLEAN_ATTRIBUTES, SELF_CLOSING_TAGS } from './constants.js'\nimport { HTMLElement } from './HTMLElement.js'\nimport { Text } from './Text.js'\nimport { Node } from './Node.js'\n\n/**\n * @param {number} count\n * @param {string} [chars='\\t']\n * @returns {string}\n */\nfunction generateIndents(count, chars = '\\t') {\n  let output = ''\n\n  for (let i = 0; i < count; i++) {\n    output += chars\n  }\n\n  return output\n}\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {SrAttr[]} attributes\n * @returns {string}\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      ) {\n        output += ` ${name}`\n      }\n    }\n    else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else if (value instanceof Function) value = `return(${value.toString()}).call(this,window.event)`\n      else value = value.toString()\n\n      value = value.replace(/\\\"/g, '\\\\\"')\n      value = escapeHTML(value)\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @returns {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * @param {Node} node\n * @param {string} indentWith\n * @param {string} indentCurrent\n * @param {boolean} isChild If true, a new row is put in the beginning\n * @returns {string}\n */\nfunction paint(node, indentWith, indentCurrent, isChild = false) {\n  let output = ''\n  let indent = ''\n  let newRow = ''\n\n  if (indentWith) {\n    indent = indentCurrent\n    newRow = '\\n'\n  }\n\n  if (node instanceof Comment) {\n    output += `${newRow}${indent}<!--${node.textContent}-->`\n  }\n  else if (node instanceof Text) {\n    output += `${newRow}${indent}${node.textContent}`\n  }\n  else if (node instanceof HTMLElement) {\n    const selfClosingTag = (SELF_CLOSING_TAGS.includes(node.tagName))\n    const attributes = generateAttributesString(node.attributes)\n\n    let style = ''\n\n    if (Object.keys(node.style).length > 0) {\n      style = ` style=\"${getStyleStringFromObject(node.style)}\"`\n    }\n\n    // Paint the opening tag (including attributes)\n    if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n    output += indent\n\n    // Paint the opening tag\n    if (node.tagName) {\n      output += `<${node.tagName.toLowerCase()}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n    }\n\n    // Paint the text in the element\n    output += node.textContent\n\n    // Paint the children\n    let children = ''\n\n    for (const child of node.childNodes) {\n      children += paint(child, indentWith, indentCurrent + indentWith, true)\n    }\n\n    if (children) {\n      output += children + newRow + indent\n    }\n\n    // Paint the closing tag\n    if (\n      node.tagName !== ''\n    ) {\n      output += (selfClosingTag) ? '/>' : `</${node.tagName.toLowerCase()}>`\n    }\n  }\n\n  return output\n}\n\nexport { paint, escapeHTML }\n","import { EnumNodeTypes } from './constants.js'\nimport { escapeHTML } from './functions.js'\nimport { Node } from './Node.js'\n\nexport class Element extends Node {\n  /** @type {SrAttr[]} */\n  #attributes = []\n\n  /** @type {string} */\n  #tagName = ''\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} tagName\n   */\n  constructor(nodeType, tagName) {\n    super(nodeType, tagName.toUpperCase())\n\n    this.#tagName = tagName.toUpperCase()\n  }\n\n  /**\n   * @returns {SrAttr[]}\n   */\n  get attributes() {\n    return this.#attributes\n  }\n\n  /**\n   * Includes only Element nodes\n   *\n   * @returns {Element[]}\n   */\n  get children() {\n    // @ts-ignore\n    return this.childNodes.filter((node) => node instanceof Element)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @returns {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @returns {string}\n   */\n  get innerHTML() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @returns {string}\n   */\n  get tagName() {\n    return this.#tagName\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   *\n   * @param {Node | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof Node) {\n      this.appendChild(childElement)\n    }\n    else {\n      this.textContent = escapeHTML(childElement.toString())\n    }\n  }\n\n  /**\n   * @param {string} attributeName\n   * @returns {string | null}\n   */\n  getAttribute(attributeName) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return null\n    }\n\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      return null\n    }\n    else {\n      return this.#attributes[index].value\n    }\n  }\n\n  /**\n   * Removes the element from the children list of its parent.\n   *\n   * @returns {void}\n   */\n  remove() {\n    this.parentNode?.removeChild(this)\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   *\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return\n    }\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      this.#attributes.push({ name, value })\n    }\n    else {\n      this.#attributes[index] = { name, value }\n    }\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { Element } from './Element.js'\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n *\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringToCamelCase(str) {\n  const split = str.split('-')\n\n  if (split.length === 1) return split[0]\n\n  return (\n    split[0]\n    + split.slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @returns {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  /** @type {StylesObject} */\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass HTMLElement extends Element {\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {string} tagName\n   */\n  constructor(tagName) {\n    super(EnumNodeTypes.ELEMENT_NODE, tagName)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @returns {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @returns {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | StylesObject} input\n   */\n  set style(input) {\n    // In the browser there are few ways to set the style:\n    // - By setting each individual property (.style.color = red)\n    // - By setting '.style.cssText' to a string (.style.cssText = 'color:red')\n    // - By setting '.style' itself to a string (.style = 'color:red')\n\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style) {\n        this.#style[key] = style[key].toString()\n      }\n    }\n  }\n}\n\nexport { HTMLElement }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass DocumentFragment extends Node {\n  constructor() {\n    super(EnumNodeTypes.DOCUMENT_FRAGMENT_NODE, '#document-fragment')\n  }\n}\n\nexport { DocumentFragment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Comment, DocumentFragment, HTMLElement, Element, Node, Text } from './orderedExports.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass Document extends Node {\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ELEMENT_NODE = EnumNodeTypes.ELEMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ATTRIBUTE_NODE = EnumNodeTypes.ATTRIBUTE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  TEXT_NODE = EnumNodeTypes.TEXT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  CDATA_SECTION_NODE = EnumNodeTypes.CDATA_SECTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  PROCESSING_INSTRUCTION_NODE = EnumNodeTypes.PROCESSING_INSTRUCTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  COMMENT_NODE = EnumNodeTypes.COMMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_NODE = EnumNodeTypes.DOCUMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_TYPE_NODE = EnumNodeTypes.DOCUMENT_TYPE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_FRAGMENT_NODE = EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n\n  /** @type {HTMLElement} */\n  #body\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @type {Element[]}\n   */\n  #children = []\n\n  constructor() {\n    super(/* DOCUMENT_NODE */ 9, '#document')\n\n    const html = new HTMLElement('html')\n    const head = new HTMLElement('head')\n    const body = new HTMLElement('body')\n\n    html.appendChild(head)\n    html.appendChild(body)\n\n    this.#children.push(html)\n\n    this.#body = body\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get body() {\n    return this.#body\n  }\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/children\n   * @returns {Element[]}\n   */\n  get children() {\n    return this.#children\n  }\n\n  /**\n   * @returns {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment() {\n    return new DocumentFragment()\n  }\n\n  /**\n   * @param {string} [text]\n   * @returns {Comment}\n   */\n  createComment(text = '') {\n    const element = new Comment()\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   * @returns {HTMLElement}\n   */\n  createElement(tagName) {\n    return new HTMLElement(tagName)\n  }\n\n  /**\n   * @param {string} text\n   * @returns {Text}\n   */\n  createTextNode(text) {\n    const element = new Text()\n\n    element.textContent = text\n\n    return element\n  }\n\n  // /**\n  //  * @param {boolean} [prettyPrint]\n  //  * @returns {string}\n  //  */\n  // paint(prettyPrint = true) {\n  //   const tabsCount = (prettyPrint) ? 0 : -1\n  //\n  //   return this.body.paint(tabsCount)\n  // }\n}\n\nexport { Document, HTMLElement }\n","import { Comment, Document, DocumentFragment, Element, HTMLElement, Node, Text } from './orderedExports.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\n/**\n * String-Rendering DOM\n */\nclass Window {\n  /** @type {typeof Comment} */\n  Comment = Comment\n\n  /** @type {typeof DocumentFragment} */\n  DocumentFragment = DocumentFragment\n\n  /** @type {typeof Element} */\n  Element = Element\n\n  /** @type {typeof HTMLElement} */\n  HTMLElement = HTMLElement\n\n  /** @type {typeof Node} */\n  Node = Node\n\n  /** @type {typeof Text} */\n  Text = Text\n\n  /** @type {typeof DOMException} */\n  DOMException = DOMException\n\n  /** @type {typeof Error} */\n  Error = Error\n\n  /** @type {typeof TypeError} */\n  TypeError = TypeError\n\n  /** @type {Document} */\n  document\n\n  constructor() {\n    this.document = new Document()\n  }\n}\n\nexport { Window }\n","import { ElementsCreator } from './ElementsCreator.js'\nimport {\n  isBrowserEnvironment,\n  isValidCustomElementName,\n  selectorEndsWithId,\n} from './functions.js'\nimport { Window as SrWindow } from './SrDOM/Window.js'\n\nconst isBrowserEnv = isBrowserEnvironment()\nconst srWindow = new SrWindow()\n\nclass Component {\n  /** @type {boolean} */\n  #renderCustomElements = false\n\n  /** @type {string} */\n  #selectorNonId = ''\n\n  /** @type {string} */\n  #selector = ''\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {HTMLElement[] | HTMLCollection}\n   */\n  #containerDOMElements = []\n\n  /** @type {Node[][]} */\n  #finalElements = []\n\n  /**\n   * In server mode this will hold the final WebApi code\n   *\n   * @type {string}\n   */\n  #finalHtmlCode = ''\n\n  /** @type {boolean} */\n  #isStatic = false\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Map<Translation | null, string>} */\n  #staticHtmlCodes = new Map()\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /**\n   * @param {string | HTMLElement} container\n   * @returns {void}\n   */\n  appendTo(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only do this in browser environment')\n    }\n\n    this.#render(container, window, false)\n  }\n\n  /**\n   * @param {(Template | Component)[]} templates\n   * @returns {Component}\n   */\n  compose(...templates) {\n    if (templates instanceof Array) {\n      for (const item of templates) {\n        if (item instanceof Array) {\n          for (const template of item) {\n            this.#templates.push(template)\n          }\n        }\n        else {\n          this.#templates.push(item)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElements() {\n    this.#render(null, window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  getHtml(options) {\n    if (this.#isStatic) {\n      return this.getStaticHtml(options)\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true, options)\n\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  getStaticHtml(options) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticHtmlCodes.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render('', window, true, options)\n      this.#staticHtmlCodes.set(\n        key,\n        this.#finalHtmlCode,\n      )\n    }\n\n    return this.#staticHtmlCodes.get(key) ?? ''\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElementsSr() {\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection} container\n   * @returns {void}\n   */\n  paint(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only use this function in browser environment')\n    }\n\n    if (!container) {\n      throw new Error('No container selected.')\n    }\n\n    if (\n      typeof container !== 'string'\n      && !(container instanceof HTMLElement)\n      && !(container instanceof NodeList)\n      && !(container instanceof Array)\n      && !(container instanceof HTMLCollection)\n    ) {\n      throw new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof container}>`,\n      )\n    }\n\n    this.#render(container, window, true)\n  }\n\n  /**\n   * @param {boolean} [on=true]\n   * @returns {Component}\n   */\n  static(on = true) {\n    this.#isStatic = on\n\n    return this\n  }\n\n  /**\n   * @param {...Translation} translations\n   * @returns {Component}\n   */\n  useTranslations(...translations) {\n    // Reset translations here, because the whole api chain (containing this function)\n    // can be executed multiple times, but with different translations every time.\n    // EDIT: Commented out, so that translations can be used in Components\n    // this.#translations = []\n\n    translations.map((item) => {\n      if (item instanceof Array) {\n        item.forEach((subItem) => {\n          if (!this.#translations.includes(subItem)) {\n            this.#translations = [...this.#translations, subItem]\n          }\n        })\n      }\n      else if (item instanceof Object) {\n        if (!this.#translations.includes(item)) {\n          this.#translations = [...this.#translations, item]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElements() {\n    if (this.#containerDOMElements) {\n      for (const el of this.#containerDOMElements) {\n        while (el?.firstChild) {\n          el.removeChild(el.firstChild)\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is for tricking TS that the string-rendering DOM's Window\n   * has the same type of the browser DOM's window\n   *\n   * @returns {Window}\n   */\n  #getSrWindow() {\n    // @ts-ignore\n    return srWindow\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {Translation[]} translations\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #init(container, window, translations, templates) {\n    this.#finalElements = []\n    this.#finalHtmlCode = ''\n\n    this.#initContainer(container, window)\n    this.#initTranslations(translations)\n    this.#initTemplates(templates)\n\n    return true\n  }\n\n  /**\n   * @param {string | HTMLElement| HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @returns {boolean}\n   */\n  #initContainer(container, window) {\n    const isSr = window.document.baseURI === ''\n\n    if (typeof container === 'string') {\n      this.#selector = container\n      this.#renderCustomElements = false\n\n      if (isValidCustomElementName(container)) {\n        this.#renderCustomElements = true\n      }\n      else {\n        if (!selectorEndsWithId(container)) {\n          this.#selectorNonId = container\n        }\n\n        // @ts-ignore\n        this.#containerDOMElements = (isSr)\n          ? [window.document.createElement('#container')]\n          : window.document.querySelectorAll(container)\n\n        if (!this.#containerDOMElements) {\n          throw new Error(`Could not find an element by the following query: ${container}`)\n        }\n      }\n    }\n    else if (container instanceof HTMLElement) {\n      this.#containerDOMElements = [container]\n    }\n    else if (\n      container instanceof NodeList\n      || container instanceof HTMLCollection\n    ) {\n      this.#containerDOMElements = container\n    }\n    else if (container instanceof Array) {\n      for (const element of container) {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('All elements in the input array must be DOM elements')\n        }\n      }\n\n      this.#containerDOMElements = container\n    }\n\n    return true\n  }\n\n  /**\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTemplates(templates) {\n    for (let template of templates) {\n      if (\n        !(template instanceof Function)\n        && !(template instanceof Component)\n      ) {\n        throw new Error('The template must be a function')\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Translation[]} translations\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTranslations(translations) {\n    if (!(translations instanceof Array)) {\n      throw new Error('The argument \\'translations\\' must be an Array')\n    }\n\n    this.#translations = translations\n\n    return true\n  }\n\n  /**\n   * @param { string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {boolean} clearContainers\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #render(container, window, clearContainers = true, htmlOptions = {}) {\n    this.#init(container, window, this.#translations, this.#templates)\n\n    if (clearContainers) {\n      this.#clearContainerElements()\n    }\n\n    const templates = this.#templates\n    const translations = this.#translations\n\n    if (!window) {\n      throw new Error('Missing window element')\n    }\n\n    if (this.#renderCustomElements) {\n      // Custom Elements\n\n      /**\n       * @param {Component} component\n       * @returns {CustomElementConstructor}\n       */\n      const getCustomElementConstructor = (component) => {\n        return class extends HTMLElement {\n          constructor() {\n            super()\n            this.attachShadow({ mode: 'open' })\n          }\n\n          connectedCallback() {\n            if (!this.shadowRoot) {\n              throw new Error('Missing shadow root')\n            }\n\n            component.#renderElements(window, this.shadowRoot, templates, translations, htmlOptions)\n          }\n        }\n      }\n\n      customElements.define(\n        this.#selector,\n        getCustomElementConstructor(this),\n      )\n    }\n    else {\n      // DOM or Virtual\n\n      if (this.#selectorNonId) {\n        const domObserver = new MutationObserver((mutationList) => {\n          for (const mutation of mutationList) {\n            const addedNodes = mutation.addedNodes\n\n            for (let node of addedNodes) {\n              // we track only elements, skip other nodes (e.g. text nodes)\n              if (!(node instanceof HTMLElement)) continue\n\n              // check the inserted element for being a code snippet\n              if (node.matches(this.#selectorNonId)) {\n                this.#renderElements(window, node, templates, translations, htmlOptions)\n              }\n\n              // or maybe there's a code snippet somewhere in its subtree?\n              for (let containerElement of node.querySelectorAll(this.#selectorNonId)) {\n                this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n              }\n            }\n\n          }\n        })\n\n        domObserver.observe(\n          document.body,\n          { attributes: false, childList: true, characterData: false, subtree: true },\n        )\n      }\n\n      if (this.#containerDOMElements.length === 0) {\n        this.#renderElements(window, null, templates, translations, htmlOptions)\n      }\n      else {\n        for (const containerElement of this.#containerDOMElements) {\n          this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Window} window\n   * @param {Element | ShadowRoot | null} container\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} translations\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #renderElements(window, container, templates, translations, htmlOptions = {}) {\n    const creator = new ElementsCreator(\n      window, container, templates, translations,\n    )\n    creator.render()\n\n    this.#finalHtmlCode = creator.getHtmlCode(htmlOptions)\n    this.#finalElements.push(creator.getCreatedElements())\n  }\n}\n\nexport { Component }\n","import { isBrowserEnvironment } from './functions.js'\n\n/**\n * TODO make it work for server environment\n *\n * @returns {string}\n */\nconst getLocale = function () {\n  let locale = 'en'\n\n  if (isBrowserEnvironment()) {\n    const html = document.getElementById('html')\n\n    locale = html?.getAttribute('lang') ?? locale\n  }\n\n  return locale\n}\n\n/**\n * @param {string} defaultPath\n * @param {string} locale\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createSingleTranslation = async function (defaultPath, locale) {\n  if (typeof defaultPath !== 'string') {\n    throw new Error('Translation path must be a string')\n  }\n\n  let translation = null\n\n  /**\n   * Matches on /path/to/filename.ext\n   * [1] /path/to/\n   * [2] filename\n   * [3] .ext\n   *\n   * @type {RegExpMatchArray | null}\n   */\n  const match = defaultPath.match(/^(.*?)([^.\\/\\\\]+)(.\\w+)$/m)\n\n  if (match === null) {\n    throw new TypeError(`Incorrect path: ${defaultPath}`)\n  }\n\n  const filePath = match[1] + locale + match[3]\n\n  try {\n    translation = (await import(/* @vite-ignore */ filePath)).default\n  }\n  catch (e) {\n    if (filePath !== defaultPath) {\n      translation = (await import(/* @vite-ignore */ defaultPath)).default\n    }\n  }\n\n  if (!(translation instanceof Object)) {\n    throw new TypeError(`Translation at ${filePath} must export an object`)\n  }\n\n  return translation\n}\n\n/**\n * @param {...string} defaultPaths\n * @returns {Promise<Translation[]>}\n * @throws\n */\nconst fetchTranslations = async function (...defaultPaths) {\n  const locale = getLocale()\n\n  const promises = []\n\n  for (let path of defaultPaths) {\n    promises.push(createSingleTranslation(path, locale))\n  }\n\n  return Promise.all(promises)\n}\n\nexport { fetchTranslations }\n","import { Component } from './Component.js'\nimport { createState } from './State.js'\nimport { fetchTranslations } from './Translation.js'\n\n/**\n * @param {(Template | Component)[]} templates\n * @returns {Component}\n */\nfunction compose(...templates) {\n  return new Component().compose(...templates)\n}\n\n/**\n * @param {Template} template\n * @returns {Template}\n */\nfunction createTemplate(template) {\n  return template\n}\n\nconst paintor = { compose, createState, createTemplate, fetchTranslations, Component }\n\nexport default paintor\nexport { paintor, compose, createState, createTemplate, fetchTranslations, Component }\n"],"names":["ElementsCollector","element","elements","elementsCollector","symStateId","symArrayAccess","symObjectAccess","suggestedItems","setSuggestItems","propertyName","subPropertyName","bindFunction","statementRepaintFunction","unsetSuggestedItems","StateSubscriptions","#subscriptions","#state","state","stateProp","subscriptions","item","subscription","key","object","statePath","handler","#createProxyHandler","proxy","innerStatePath","#onArrayLengthChange","updatedState","listItem","#onPropCreateOrDelete","prop","#onPropCreate","#onPropUpdate","target","result","modifyStyleRule","setElementAttrOrProp","#onPropDelete","receiver","fn","args","value","stateIdCounter","createState","isState","getGlobalObject","format","fmt","re","replacer","match","escaped","ptn","flag","arg","out","isBrowserEnvironment","isBrowser","addChildToStack","inputChild","childrenStack","addChildrenToStack","inputChildren","child","isEventAttribute","attributeName","isWhitespace","char","isValidCustomElementName","name","selectorEndsWithId","stringToBoolean","string","int","addEventListenerIfPossible","callback","eventSmallName","appendDOMChildrenToElement","children","fragment","appendVirtualChildrenToElement","appendChildrenToElement","forEachLoop","forLoopType","data","beforeIterationCallback","keyToRender","iterationCallback","isProxy","val","ret","forLoop","start","end","arrayRemoveKey","arr","el","index","insertAfter","newNode","existingNode","nextSibling","parentNode","setDataSetAttributesToElement","dataSet","attrOrPropName","output","objectHasKey","htmlTags","HtmlTemplateParserElement","parent","attributes","SELF_CLOSING_TAGS","HtmlTemplateParser","#attrName","#attrQuote","#attrValue","#attributes","#char","#charPrevious","#data","#stage","#stageNothing","#styleAttrName","#styleAttrValue","#styles","#tagName","#tagNameClosing","#textContents","#topElement","#currentElement","strings","keys","#mergeStringsAndKeys","#rotate","elementsCreator","#generateChildren","#appendData","to","#makeNewElement","dataIndex","charIndex","#setAttribute","#setStage","stage","#stageAttrName","#setStyle","#stageTagToClose","#stageAttrOpenQuote","#stageStyleAttrName","#stageAttrValue","#stageTag","#stageTextContents","#stageStyleAttrValue","ElementsCreator","#collectedElements","#containerElement","#document","#dummyHtmlElement","#isSr","#templates","#translations","#window","window","containerElement","templates","translations","tagName","argumentID","argument","textNode","#translate","isChildrenArray","#arrayTranslateFormatTranslate","Component","generatedChildren","childrenGroup","inlineScript","#setPropertiesToElement","level","from","#statementHandler","input","#forEachLoop","htmlOptions","htmlCode","#htmlForSimpleString","#htmlForTemplateLiteral","condition","elseHandler","#statementHandlerForFunction","template","returnedValue","allComponents","allFunctions","#afterStatement","thisLevel","upperLevel","#arrayTranslate","array","#beforeStatement","callbackForState","renderedElementsMap","elementsFromCollector","#statementHandlerForState","#insertStatementElements","beginCommentElement","lastElement","newElement","#removeStatementElements","beginCommentElementText","endElementText","currentElement","statementsCounter","deletedElementsCount","text","#unsubscribeElementAndItsChildren","properties","property","#setStylesToElement","styleRules","ruleName","ruleValue","finalValue","type","commentElementBegin","commentElementEnd","bindFunctionResult","resolved","i","renderedElementsMapNew","isKeyInRenderedElementsMap","added","translated","#translateString","globalObject","globallyTranslated","str","translateObject","bindArgs","boundArgs","targetFunction","prototype","BOOLEAN_ATTRIBUTES","EnumNodeTypes","DOMException","message","Node","#childNodes","#nodeName","#nodeType","#parentNode","nodeType","nodeName","aChild","errorMessage","prevKey","referenceElement","newChildren","childNode","node","indent","childNumber","isChild","paint","Comment","Text","escapeHTML","html","charsToReplace","tag","generateAttributesString","attribute","formatStringFromCamelCase","all","getStyleStringFromObject","style","indentWith","indentCurrent","newRow","HTMLElement","selfClosingTag","Element","className","childElement","attributeValue","formatStringToCamelCase","split","word","getStyleObjectFromString","formattedProperty","#style","Document","#body","#children","head","body","DocumentFragment","Window","isBrowserEnv","srWindow","SrWindow","#renderCustomElements","#selectorNonId","#selector","#containerDOMElements","#finalElements","#finalHtmlCode","#isStatic","#staticHtmlCodes","container","#render","options","#getSrWindow","on","subItem","#clearContainerElements","#init","#initContainer","#initTranslations","#initTemplates","isSr","clearContainers","getCustomElementConstructor","component","#renderElements","mutationList","mutation","addedNodes","creator","getLocale","locale","createSingleTranslation","defaultPath","translation","filePath","__vitePreload","fetchTranslations","defaultPaths","promises","path","compose","createTemplate","paintor"],"mappings":"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"}