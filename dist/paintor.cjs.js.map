{"version":3,"file":"paintor.cjs.js","sources":["../src/constants.js","../src/elementsSuggestor.js","../src/StateProxyArrayFunctions.js","../src/SubscriptionsManager.js","../src/StateProxy.js","../src/state.js","../src/functions.js","../src/ElementsCollector.js","../src/HtmlTemplateParser/HtmlTemplateParserElement.js","../src/HtmlTemplateParser/constants.js","../src/HtmlTemplateParser/HtmlTemplateParser.js","../src/ElementsCreator.js","../src/SrDOM/constants.js","../src/SrDOM/exceptions/DOMException.js","../src/SrDOM/Node.js","../src/SrDOM/Comment.js","../src/SrDOM/Text.js","../src/SrDOM/functions.js","../src/SrDOM/Element.js","../src/SrDOM/HTMLElement.js","../src/SrDOM/DocumentFragment.js","../src/SrDOM/Document.js","../src/SrDOM/Window.js","../src/Component.js","../src/Translation.js","../src/paintor.js"],"sourcesContent":["/**\n * @readonly\n * @enum {number}\n */\nexport const EnumStateAction = Object.freeze({\n  CREATE: 1,\n  READ: 2,\n  UPDATE: 3,\n  DELETE: 4,\n  ARRAY_SPLICE: 5,\n  ARRAY_SWAP: 6,\n  ARRAY_COPY_WITHIN: 7,\n  ARRAY_SORT: 8,\n  ARRAY_PUSH: 9,\n  ARRAY_LENGTH: 10,\n})\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n * @see https://www.w3schools.com/tags/\n * @readonly\n * @enum {string[]}\n */\nexport const HTML_TAGS = Object.freeze([\n  'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', // 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n])\n\nexport const symSubscriptions  = Symbol('Subscriptions')\nexport const symAccess  = Symbol('Access')\nexport const symTemplateFunction = Symbol('TemplateFunction')\nexport const symState = Symbol('State')\n","/**\n * @type {{\n *   element: null | Element | Comment,\n *   propertyName: string,\n *   subPropertyName: string,\n *   bindFunction: null | BindFunction,\n *   statementRepaintFunction: null | StatementRepaintFunction\n * }}\n */\nlet suggestedItems = {\n  element                 : null,\n  propertyName            : '',\n  subPropertyName         : '',\n  bindFunction            : null,\n  statementRepaintFunction: null,\n}\n\n/**\n * This function should be called just before calling the bindFunction. The idea is\n * that the bindFunction, along with its html element and property name are suggested\n * here to the proxy handler. When the bindFunction is called, any state used in it\n * would trigger the proxy get event, which means that it will be added to the subscriptions.\n *\n * @param {Element | Comment | Text} element\n * @param {string} propertyName\n * @param {string} subPropertyName\n * @param {BindFunction} bindFunction\n * @param {null | StatementRepaintFunction} statementRepaintFunction\n */\nfunction setSuggestedItems(\n  element,\n  propertyName,\n  subPropertyName,\n  bindFunction,\n  statementRepaintFunction,\n) {\n  suggestedItems.element                  = element\n  suggestedItems.propertyName             = propertyName\n  suggestedItems.subPropertyName          = subPropertyName\n  suggestedItems.bindFunction             = bindFunction\n  suggestedItems.statementRepaintFunction = statementRepaintFunction\n}\n\n/**\n * Reset the suggested items\n *\n * @returns {void}\n */\nfunction unsetSuggestedItems() {\n  suggestedItems.element                  = null\n  suggestedItems.propertyName             = ''\n  suggestedItems.subPropertyName          = ''\n  suggestedItems.bindFunction             = null\n  suggestedItems.statementRepaintFunction = null\n}\n\nexport { suggestedItems, setSuggestedItems, unsetSuggestedItems }\n","import { EnumStateAction } from './constants.js'\n\n/** @typedef {Object<*, *> | Array<*>} ProxyObject */\n\nexport class StateProxyArrayFunctions {\n  /**\n   * @type {{receiver: State, target: ProxyObject, callback: Function}}\n   */\n  #arrayFnObjects = { receiver: [], target: [], callback: () => {} }\n\n  /**\n   * @param {string} fnName\n   * @param {ProxyObject} target\n   * @param {State} receiver\n   * @param {Function} callback\n   * @returns {Function | void}\n   */\n  callArrayFn(fnName, target, receiver, callback) {\n    this.#arrayFnObjects.target = target\n    this.#arrayFnObjects.receiver = receiver\n    this.#arrayFnObjects.callback = callback\n\n    switch (fnName) {\n      case 'push':       return this.#arrayFnPush\n      case 'copyWithin': return this.#arrayFnCopyWithin\n      case 'reverse':    return this.#arrayFnReverse\n      case 'shift':      return this.#arrayFnShift\n      case 'sort':       return this.#arrayFnSort\n      case 'splice':     return this.#arrayFnSplice\n      case 'unshift':    return this.#arrayFnUnshift\n      default:           return target[fnName]\n    }\n  }\n\n  /**\n   * @param {any} args\n   * @returns {any}\n   */\n  #arrayFnCopyWithin = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let [targetIndex, start, end] = args\n    const { length } = target\n\n    /**\n     * Fix the arguments, according to the rules in the following link:\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin\n     */\n    if (targetIndex < 0) targetIndex += length\n    else if (targetIndex < -length) targetIndex = 0\n    else if (targetIndex >= length) return\n    else if (targetIndex > start) end = length - 1\n\n    if (start < 0) start += length\n    else if (start < -length || start === undefined) start = 0\n    else if (start >= length) return\n\n    if (end < 0) end += length\n    else if (end < -length) end = 0\n    else if (end >= length || end === undefined) end = length\n    else if (end <= start) return\n\n    // Apply the function\n    const result = target.copyWithin.apply(target, [targetIndex, start, end])\n\n    this.#arrayFnObjects.callback(\n      EnumStateAction.ARRAY_COPY_WITHIN,\n      receiver,\n      [targetIndex, start, end],\n    )\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnPush = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.push.apply(target, args)\n\n    //this.#onPropCreate(receiver, (target.length - 1).toString())\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_PUSH, receiver, args)\n\n    return result\n  }\n\n  #arrayFnReverse = () => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.reverse.apply(target)\n\n    for (let i = 0, len = target.length; i < len; i++) {\n      const j = len - 1 - i\n\n      if (i >= j) break\n\n      this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SWAP, receiver, [i, j])\n    }\n\n    return result\n  }\n\n  #arrayFnShift = () => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.shift.apply(target)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, [0, 1])\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnSort = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.sort.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SORT, receiver, args)\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnSplice = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.splice.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, args)\n\n    return result\n  }\n\n  /**\n   * @param {any} args\n   * @returns {ProxyObject}\n   */\n  #arrayFnUnshift = (...args) => {\n    const { target, receiver } = this.#arrayFnObjects\n    const result = target.unshift.apply(target, args)\n\n    this.#arrayFnObjects.callback(EnumStateAction.ARRAY_SPLICE, receiver, [0, 0, ...args])\n\n    return result\n  }\n}\n","import { symSubscriptions } from './constants.js'\n\nexport class SubscriptionsManager {\n  /** @type {Map<string | symbol, Subscription[]>} */\n  #subscriptions = new Map()\n\n  get subscriptions() {\n    return this.#subscriptions\n  }\n\n  /**\n   * @param {State} state\n   * @param {string | symbol} stateProp\n   * @param {Element | Comment} element\n   * The HTML element for which the other parameters apply.\n   * @param {string} propertyName\n   * The name of the property of the HTML element, for\n   * which the subscription is going to be created.\n   * For example: 'style', 'value', 'textContent', 'innerHTML'.\n   * Also, '--if' for IF statement.\n   * @param {string} subPropertyName\n   * If the property name is 'style', the sub-property could be\n   * any style property.\n   * For example: 'fontSize'\n   * @param {BindFunction} bindFunction\n   * The function that is used instead of a fixed value.\n   * For example: () => (state.clicks)\n   * @param {StatementRepaintFunction | null} statementRepaintFunction\n   * This is only used in the if() function. It's a function that\n   * is used to repaint the elements in case the condition is changed\n   * from false to true or vice versa.\n   */\n  subscribe(\n    state,\n    stateProp,\n    element,\n    propertyName,\n    subPropertyName,\n    bindFunction,\n    statementRepaintFunction,\n  ) {\n    if (\n      propertyName === '-s-if'\n      || propertyName === '-s-forEach'\n      || propertyName === '-s-forState'\n    ) {\n      stateProp = propertyName\n    }\n\n    if (!this.#subscriptions.has(stateProp)) {\n      this.#subscriptions.set(stateProp, [])\n    }\n\n    const subscriptions = this.#subscriptions.get(stateProp) ?? []\n\n    // Search for a subscription with the same parameters.\n    // If such already exists, just don't create a new one.\n    for (const item of subscriptions) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementRepaintFunction === statementRepaintFunction\n      ) return\n    }\n\n    /**\n     * @type {Subscription}\n     */\n    const subscription = {\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementRepaintFunction,\n      stateSubscription: this,\n    }\n\n    subscriptions.push(subscription)\n\n    // @ts-ignore\n    element[symSubscriptions] ??= []\n    // @ts-ignore\n    element[symSubscriptions].push(subscription)\n  }\n\n  /**\n   * Remove any subscriptions that the element is subscribed to\n   *\n   * @param {Node} element\n   */\n  unsubscribe(element) {\n    if (\n      symSubscriptions in element\n      && element[symSubscriptions] instanceof Array\n    ) {\n      /** @type {Subscription[]} */\n      const subs = element[symSubscriptions]\n      let index = subs.length\n\n      while (index--) {\n        if (subs[index].stateSubscription === this) {\n          subs.splice(index, 1)\n        }\n      }\n    }\n\n    for (const [key, subscription] of this.#subscriptions) {\n      let index = subscription.length\n\n      while (index--) {\n        if (subscription[index].element === element) {\n          subscription.splice(index, 1)\n        }\n      }\n\n      this.#subscriptions.set(key, subscription)\n\n      // The variant below works, but slower\n      //this.#subscriptions.set(key, subscription.filter((item) => (item.element !== element)))\n    }\n  }\n}\n\n/**\n * @param {Node | Element | Comment | Text} element\n * @returns {boolean}\n */\nexport function hasSubscriptions(element) {\n  return Object.hasOwn(element, symSubscriptions)\n}\n\n/**\n * Move subscription records from one DOM element into another DOM element.\n * Subscription records are located in a special array in the DOM element.\n *\n * @param {Element | Comment | Text} fromElement\n * @param {Element | Comment | Text} toElement\n * @param {BindFunction} [bindFunction] Optionally filter by the bind function\n * @param {Partial<Subscription>} [newSubscriptionProperties] Optionally set these parameters\n */\nexport function moveSubscriptions(fromElement, toElement, bindFunction, newSubscriptionProperties) {\n  if (\n    symSubscriptions in fromElement\n    && fromElement[symSubscriptions] instanceof Array\n  ) {\n    let index = fromElement[symSubscriptions].length\n\n    while (index--) {\n      /** @type {Subscription} */\n      const subscription = fromElement[symSubscriptions][index]\n\n      if (\n        bindFunction === undefined\n        || bindFunction === subscription.bindFunction\n      ) {\n        /**\n         * 1. Move the subscription record\n         */\n        subscription.element = toElement\n\n        if (newSubscriptionProperties) {\n          for (const prop in newSubscriptionProperties) {\n            // @ts-ignore\n            subscription[prop] = newSubscriptionProperties[prop]\n          }\n        }\n\n        // @ts-ignore\n        toElement[symSubscriptions] ??= []\n        // @ts-ignore\n        toElement[symSubscriptions].push(subscription)\n\n        /**\n         * 2. Remove the subscription record from the origin element\n         */\n        fromElement[symSubscriptions].splice(index, 1)\n      }\n    }\n  }\n}\n\n/**\n * @param {Node | Element | Comment | Text} element\n */\nexport function removeAllSubscriptions(element) {\n  /** @type {Subscription[]} */\n  // @ts-ignore\n  const elementSubs = element[symSubscriptions]\n  let idx = elementSubs.length\n\n  while (idx--) {\n    if (!elementSubs[idx]) continue\n\n    elementSubs[idx].stateSubscription.unsubscribe(element)\n  }\n\n  // @ts-ignore\n  delete element[symSubscriptions]\n}\n","import { EnumStateAction, symAccess, symState } from './constants.js'\nimport { suggestedItems } from './elementsSuggestor.js'\nimport { modifyStyleRule, setElementAttrOrProp } from './functions.js'\nimport { StateProxyArrayFunctions } from './StateProxyArrayFunctions.js'\nimport { SubscriptionsManager } from './SubscriptionsManager.js'\n\n/** @typedef {Object<*, *> | Array<*>} ProxyObject */\n\nclass StateProxy {\n  /** @type {StateProxyArrayFunctions} */\n  #arrayFunctions\n\n  /** @type {SubscriptionsManager} */\n  #subsManager\n\n  constructor() {\n    this.#arrayFunctions = new StateProxyArrayFunctions()\n    this.#subsManager = new SubscriptionsManager()\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * The input object that will be used to create\n   * a proxy object with the same keys and values.\n   * @param {string} [statePath]\n   * The path to the state:\n   * <br>\n   * - If the state is the parent state, this is an empty string.\n   * <br>\n   * - If the state is a child state, this is the path to it (dot notated).\n   * @returns {T}\n   */\n  createProxy(object, statePath = '') {\n    if (!(object instanceof Object)) {\n      throw new Error('Cannot create a Proxy on non-object')\n    }\n\n    const handler = this.#createProxyHandler()\n    const proxy = new Proxy(object, handler)\n\n    // Store the path to the state in a special value in the\n    // proxy object, but make that value invisible for \"for\"\n    // (and similar) statements.\n    // Object.defineProperty(proxy, '--state-path', {\n    //   enumerable: false,\n    //   configurable: false,\n    //   writable: false,\n    //   value: statePath,\n    // })\n\n    // Recursive proxy. To find all inner objects\n    // and turn them into child states.\n    for (const key in proxy) {\n      if (!(proxy[key] instanceof Object)) {\n        continue\n      }\n\n      const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n      proxy[key] = this.createProxy(proxy[key], innerStatePath)\n    }\n\n    return proxy\n  }\n\n  /**\n   * @returns {ProxyHandler<ProxyObject>}\n   */\n  #createProxyHandler() {\n    /** @type {ProxyHandler<ProxyObject>} */\n    const handler = {\n      get: (target, prop, receiver) => {\n        if (prop === symState) {\n          return target[prop]\n        }\n        /**\n         * Why is hasOwn() needed?\n         * If the state is for example an array and its whole value is read,\n         * then JS tries to read few extra properties first - map, length, constructor\n         */\n        else if (\n          Object.hasOwn(target, prop)\n          || prop === symAccess\n        ) {\n          /**\n           * In the if below it would be enough to check just one element,\n           * but because of TS more than one is checked\n           */\n          if (\n            suggestedItems.element\n            && suggestedItems.bindFunction\n          ) {\n            this.#subsManager.subscribe(\n              target,\n              prop,\n              suggestedItems.element,\n              suggestedItems.propertyName,\n              suggestedItems.subPropertyName,\n              suggestedItems.bindFunction,\n              suggestedItems.statementRepaintFunction,\n            )\n          }\n        }\n        // Internal functions of Set() and Map()\n        else if (\n          (target instanceof Map || target instanceof Set)\n          // @ts-ignore\n          && target[prop] instanceof Function\n        ) {\n          /**\n           * @see https://stackoverflow.com/questions/48452885/observe-changes-to-a-map-using-a-proxy\n           */\n\n          // @ts-ignore\n          const fn = target[prop]\n\n          /**\n           * @param {any[]} args\n           * @returns {*}\n           */\n          const boundFunction = (...args) => {\n            const result = fn.apply(target, args)\n\n            if (target instanceof Set) {\n              if (prop === 'add') {\n                this.#onPropCreate(receiver, prop)\n              }\n              else if (prop === 'delete') {\n                this.#onPropDelete(receiver, prop)\n              }\n            }\n            else if (target instanceof Map) {\n              if (prop === 'set') {\n                this.#onPropCreate(receiver, prop)\n              }\n              else if (prop === 'delete') {\n                this.#onPropDelete(receiver, prop)\n              }\n            }\n\n            return result\n          }\n\n          return boundFunction\n        }\n        else if (\n          target instanceof Array\n          // @ts-ignore\n          && target[prop] instanceof Function\n          && typeof prop === 'string'\n        ) {\n          return this.#arrayFunctions.callArrayFn(\n            prop, target, receiver, this.#onArrayFunctionCallback,\n          )\n        }\n\n        return target[prop]\n      },\n      set: (target, prop, value, receiver) => {\n        if (prop === symState || prop === symAccess) {\n          target[prop] = value\n        }\n        // Array's length is set every time after\n        // adding or removing elements\n        else if (target instanceof Array && prop === 'length') {\n          target[prop] = value\n\n          this.#onArrayFunctionCallback(\n            EnumStateAction.ARRAY_LENGTH, receiver, [value],\n          )\n        }\n        else if (Object.hasOwn(target, prop)) {\n          if (value instanceof Object) {\n            target[prop] = this.createProxy(value)\n\n            this.#onPropDelete(receiver, prop)\n            this.#onPropCreate(receiver, prop)\n          }\n          else {\n            target[prop] = value\n\n            this.#onPropUpdate(receiver, prop, value)\n          }\n        }\n        else {\n          if (value instanceof Object) {\n            target[prop] = this.createProxy(value)\n          }\n          else {\n            target[prop] = value\n          }\n\n          this.#onPropCreate(receiver, prop)\n        }\n\n        return true\n      },\n\n      /**\n       * Trap for the delete operator. This trap can intercept these operations:\n       *  - delete proxy[foo] and delete proxy.foo\n       *  - Reflect.deleteProperty()\n       *\n       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty\n       * @param {ProxyObject} target\n       * @param {string | symbol} prop\n       * @returns {boolean}\n       * A Boolean indicating whether the property has been successfully deleted.\n       */\n      deleteProperty: (target, prop) => {\n        delete target[prop]\n\n        this.#onPropDelete(target, prop)\n\n        return true\n      },\n    }\n\n    return handler\n  }\n\n  /**\n   * @param {EnumStateAction} action\n   * @param {State} updatedState\n   * @param {any[]} args\n   */\n  #onArrayFunctionCallback = (action, updatedState, args) => {\n    const subscription = this.#subsManager.subscriptions.get('-s-forState')\n\n    if (subscription) {\n      for (let index = 0, length = subscription.length; index < length; index++) {\n        const { statementRepaintFunction } = subscription[index]\n\n        if (statementRepaintFunction) {\n          // @ts-ignore\n          statementRepaintFunction(action, updatedState, '', args)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreate(updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.CREATE, updatedState, prop)\n  }\n\n  /**\n   * @param {EnumStateAction} action\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreateOrDelete(action, updatedState, prop) {\n    const subscription = this.#subsManager.subscriptions.get('-s-forState')\n\n    if (subscription) {\n      for (let index = 0, length = subscription.length; index < length; index++) {\n        const { statementRepaintFunction } = subscription[index]\n\n        if (statementRepaintFunction) {\n          // @ts-ignore\n          statementRepaintFunction(action, updatedState, prop)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropDelete(updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.DELETE, updatedState, prop)\n  }\n\n  /**\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   * @param {any} value\n   */\n  #onPropUpdate(updatedState, prop, value) {\n    // 1. When the repaint function is outside all elements\n    // const subscription = this.#subscriptions.subscriptions.get('-s-forState')\n    //\n    // if (subscription) {\n    //   for (let index = 0, length = subscription.length; index < length; index++) {\n    //     const { statementRepaintFunction } = subscription[index]\n    //\n    //     if (statementRepaintFunction) {\n    //       // @ts-ignore\n    //       statementRepaintFunction(EnumStateAction.UPDATE, updatedState, prop)\n    //     }\n    //   }\n    // }\n\n    // 2. Individual elements\n    if (this.#subsManager.subscriptions.has(prop)) {\n      const list = this.#subsManager.subscriptions.get(prop) ?? []\n\n      for (const listItem of list) {\n        const {\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementRepaintFunction,\n        } = listItem\n\n        if (Object.hasOwn(element, '--deleted')) {\n          this.#subsManager.unsubscribe(element)\n\n          return\n        }\n\n        let result = bindFunction.call(element, element)\n\n        if (propertyName === 'style' && subPropertyName) {\n          // @ts-ignore\n          element.style[subPropertyName]\n            = modifyStyleRule(subPropertyName, result)\n        }\n        else if (\n          propertyName === '--if'\n          || propertyName === '--for'\n          || propertyName === '--nest'\n        ) {\n          if (statementRepaintFunction) {\n            // @ts-ignore\n            statementRepaintFunction(result)\n          }\n        }\n        else {\n          /**\n           * @see Remark \"() => value\"\n           */\n          if (result instanceof Function) {\n            result = result()\n          }\n\n          // @ts-ignore\n          setElementAttrOrProp(element, propertyName, result)\n        }\n      }\n    }\n  }\n}\n\nexport { StateProxy }\n","import { StateProxy } from './StateProxy.js'\nimport { symState } from './constants.js'\n\nlet stateIdCounter = 0\n\n/**\n * @template T\n * @param {T} object\n * Your input object or array\n * @returns {T}\n * A proxy object/array that looks the same as the input object/array\n */\nconst state = function state(object) {\n  if (!(object instanceof Object)) {\n    throw new Error('state() only accepts Object, Array, Set or Map as input value.')\n  }\n\n  const stateProxy = new StateProxy()\n  const proxy = stateProxy.createProxy(object)\n\n  stateIdCounter += 1\n\n  // @ts-ignore\n  proxy[symState] = { id: stateIdCounter, target: object }\n\n  return proxy\n}\n\n/**\n * @param {Object<*,*>} object\n * @returns {boolean}\n */\nconst isState = function (object) {\n  return (object instanceof Object) && (symState in object)\n}\n\nexport { state, isState }\n","import { isState } from './state.js'\nimport { symAccess, symState } from './constants.js'\n\n/**\n * @see https://github.com/purposeindustries/window-or-global/blob/master/lib/index.js\n * @returns {Window | any}\n */\nexport function getGlobalObject() {\n  return (typeof self === 'object' && self.self === self && self)\n    || (typeof global === 'object' && global.global === global && global)\n    // @ts-ignore\n    || this\n}\n\n/**\n * @see https://github.com/tmpfs/format-util/blob/master/format.js\n * @param {string} fmt\n * @param {...any[]} args\n * @returns {string}\n */\nexport function format(fmt, ...args) {\n  const re = /(%?)(%([ojdsif]))/g\n\n  if (args.length > 0) {\n    /**\n     * @param {string} match\n     * @param {string} escaped % (for %%) or null (for anything else)\n     * @param {string} ptn %o or %s or whatever\n     * @param {string} flag The s from %s\n     * @returns {string}\n     */\n    const replacer = (match, escaped, ptn, flag) => {\n      let arg = args.shift()\n      let out = ''\n\n      switch (flag) {\n        case 'o':\n          if (Array.isArray(arg)) {\n            out = JSON.stringify(arg)\n          }\n          break\n        case 's':\n          out = '' + arg\n          break\n        case 'd':\n          out = '' + Number(arg)\n          break\n        case 'j':\n          out = JSON.stringify(arg)\n          break\n        case 'i':\n          out = '' + parseInt('' + arg, 10)\n          break\n        case 'f':\n          out = '' + parseFloat('' + arg)\n          break\n      }\n\n      if (!escaped) {\n        return out\n      }\n\n      // @ts-ignore\n      args.unshift(out)\n\n      return match\n    }\n\n    fmt = fmt.replace(re, replacer)\n  }\n\n  // arguments, remained after the formatting\n  if (args.length > 0) {\n    fmt += ' ' + args.join(' ')\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%')\n\n  return '' + fmt\n}\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @returns {boolean}\n */\nexport function isBrowserEnvironment() {\n  if (isBrowserEnvironment.isIt === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n    isBrowserEnvironment.isIt = isBrowser()\n  }\n\n  return isBrowserEnvironment.isIt ?? false\n}\n\n/**\n * The environment doesn't change over time, so it's enough\n * to determine it once. This variable is used to store the\n * environment, it's a cache.\n *\n * @type {undefined | boolean}\n */\nisBrowserEnvironment.isIt = undefined\n\n/**\n * @template T\n * @param {T} inputChild\n * @param {T[]} childrenStack\n */\nexport function addChildToStack(inputChild, childrenStack) {\n  childrenStack.push(inputChild)\n}\n\n/**\n * @template T\n * @param {T[]} inputChildren\n * @param {T[]} childrenStack\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren) {\n    childrenStack.push(child)\n  }\n}\n\n/**\n * @param {string} attributeName\n * @returns {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {string} char\n * @returns {boolean}\n */\nexport function isWhitespace(char) {\n  return (\n    char === ' '\n    || char === '\\t'\n    || char === '\\r'\n    || char === '\\n'\n  )\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function isValidCustomElementName(name) {\n  return /^[a-z][a-z0-9-]+$/.test(name) && name.includes('-')\n}\n\n/**\n * @param {string} selector\n * @returns {boolean}\n */\nexport function selectorEndsWithId(selector) {\n  return /#[a-z0-9-]+\\s*$/.test(selector)\n}\n\n/**\n * Turns a string into boolean.\n * Covers the cases when the string is 'true', 'false' or a number.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexport function stringToBoolean(string) {\n  if (string === 'true') return true\n\n  if (string === 'false') return false\n\n  const int = parseInt(string)\n\n  return (isNaN(int)) ? Boolean(string) : Boolean(int)\n}\n\n/**\n * @param {Element | Text} element\n * @param {string} attributeName\n * @param {EventListenerOrEventListenerObject} callback\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof window.Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  const eventSmallName = attributeName.toLowerCase().substring(2)\n\n  element.addEventListener(eventSmallName, callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n *\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  }\n  else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child) {\n        fragment.append(child)\n      }\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child) {\n      element.appendChild(child)\n    }\n  }\n}\n\n/**\n * @param {Node | null} element\n * The element in which to append the children\n * @param {Node[]} children\n * The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (!element) return\n\n  if (isBrowserEnvironment() && element instanceof window.Node) {\n    appendDOMChildrenToElement(element, children)\n  }\n  else {\n    appendVirtualChildrenToElement(element, children)\n  }\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values\n * and the \"handler\" function is looped once for each pair.\n * The loop breaks if \"false\" is returned by the \"handler\"\n * function.\n *\n * @template T\n * @param {1 | 2} forLoopType\n * @param {Array<T> | Object<string | number, T> | Map<string | number, T>} state\n * @param {ForLoopCallback<T>} handler\n * @param {ForLoopCallbackOnEmpty} [handlerOnEmpty]\n * @param {(key: number | string) => void} [beforeIterationCallback]\n * @param {string | number | symbol} [keyToRender]\n * @param {(key: number | string | undefined) => void} [iterationCallback]\n * @returns {boolean}\n * @throws {TypeError}\n */\nexport function forEachLoop(\n  forLoopType,\n  state,\n  handler,\n  handlerOnEmpty,\n  beforeIterationCallback,\n  keyToRender,\n  iterationCallback,\n) {\n  if (!(handler instanceof Function)) {\n    throw new TypeError('\"handler\" argument should be a Function')\n  }\n\n  const object = isState(state) ? state[symState].target : state\n  const isProxy = forLoopType === 2 && isState(object)\n\n  /**\n   * Dummy variable, used when the proxy needs to be\n   * forced to fire \"get\" event.\n   *\n   * @type {any}\n   */\n  let nothing = undefined\n\n  if (object instanceof Array) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = isProxy ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && object.length === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const key in object) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy\n        ? (object[key] instanceof Object)\n          ? state[key]\n          : object[key]\n        : object[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (\n    object instanceof Map\n    || object instanceof Set\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = (isProxy) ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && object.size === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const [key, value] of object.entries()) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let val = value\n\n      if (beforeIterationCallback) {\n        val = beforeIterationCallback?.(val)\n      }\n\n      const ret = handler(val, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (object instanceof Object) {\n    /**\n     * The Object loop must be at the end,\n     * because Array, Set and Map are also Object.\n     */\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    nothing = isProxy ? state[symAccess] : undefined\n\n    if (keyToRender === undefined && Object.keys(object).length === 0 && handlerOnEmpty instanceof Function) {\n      handlerOnEmpty()\n      iterationCallback?.(undefined)\n    }\n\n    for (const key in object) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy\n        ? (object[key] instanceof Object)\n          ? state[key]\n          : object[key]\n        : object[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    throw new TypeError('\"data\" argument should be an Object or an Array')\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {ForLoopIterableCallback} handler\n * @returns {boolean | Error}\n */\nexport function forLoop(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number') {\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n  }\n\n  if (!(handler instanceof Function)) {\n    return new Error('\"handler\" argument should be a Function')\n  }\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} key\n * @returns {T[]}\n */\nexport function arrayRemoveKey(arr, key) {\n  arr.splice(key, 1)\n\n  return arr\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {T} value\n * @returns {T[]}\n */\nexport function arrayRemoveValue(arr, value) {\n  return arr.filter(function (el) {\n    return el !== value\n  })\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n *\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  if (!existingNode) return\n\n  const { nextSibling, parentNode } = existingNode\n\n  if (parentNode) {\n    parentNode.insertBefore(newNode, nextSibling)\n  }\n}\n\n/**\n *\n * @param {HTMLElement} element\n * @param {Object<string, (string | number | boolean)>}dataSet\n */\nexport function setDataSetAttributesToElement(element, dataSet) {\n  if (dataSet instanceof Object) {\n    for (const key in dataSet) {\n      const value = dataSet[key].toString()\n\n      element.setAttribute(`data-${key}`, value)\n    }\n  }\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends on the name of the attribute or property.\n *\n * @param {Element | Text} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    if (value instanceof Array) {\n      // @ts-ignore\n      element[attrOrPropName] = format.apply(null, value)\n    }\n    else {\n      // @ts-ignore\n      element[attrOrPropName] = value ?? ''\n    }\n  }\n  else {\n    if ('setAttribute' in element) {\n      element.setAttribute(attrOrPropName, value)\n    }\n  }\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n *\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function modifyStyleRule(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {HTMLElement}\n */\nexport function stringToHTML(str) {\n  const parser = new DOMParser()\n  const doc    = parser.parseFromString(str, 'text/html')\n\n  return doc.body\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {boolean}\n */\nexport function objectHasKey(object, key) {\n  if (object instanceof Map || object instanceof Set) {\n    return object.has(key)\n  }\n  else {\n    return (key in object)\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {any}\n */\nexport function objectGetValue(object, key) {\n  if (object instanceof Map) {\n    return object.get(key)\n  }\n  else if (object instanceof Set) {\n    return object.has(key) ? key : undefined\n  }\n  else {\n    return object[key]\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @returns {number}\n */\nexport function objectLength(object) {\n  if (object instanceof Array) {\n    return object.length\n  }\n  else if (object instanceof Map || object instanceof Set) {\n    return object.size\n  }\n  else if (object instanceof Object) {\n    return Object.keys(object).length\n  }\n\n  return 0\n}\n\n/**\n * @see https://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another\n * @template T\n * @param {T[]} array\n * @param {number} oldIndex\n * @param {number} newIndex\n * @returns {T[]}\n */\nexport function arrayMoveIndex(array, oldIndex, newIndex) {\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length + 1\n\n    while (k--) {\n      // @ts-ignore\n      array.push(undefined)\n    }\n  }\n\n  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0])\n\n  return array\n}\n\n/**\n * @param {...Element} elements\n */\nexport const chainElements = (...elements) => {\n  const length = elements.length\n\n  for (let i = 1; i < length; i++) {\n    elements[i-1].after(elements[i])\n  }\n}\n","import { arrayMoveIndex } from './functions.js'\n\n/**\n * This class has an array where HTML elements are stored.\n * The class methods provide an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type {Node[]} */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   *\n   * @param {Node} element\n   */\n  addElement(element) {\n    if (element) this.elements.push(element)\n  }\n\n  /**\n   * Add multiple elements to the array of collected elements\n   *\n   * @param {Node[]} elements\n   */\n  addElements(elements) {\n    for (let element of elements) {\n      this.elements.push(element)\n    }\n  }\n\n  /**\n   * Returns the array of collected elements\n   *\n   * @returns {Node[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * @param {Node} element\n   * @returns {boolean}\n   */\n  hasElement(element) {\n    return this.elements.indexOf(element) > -1\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   *\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements) {\n      this.addElement(element)\n    }\n  }\n\n  /**\n   * @param {Node} elementToMove\n   * @param {Node} referenceElement\n   */\n  moveElementAfterAnother(elementToMove, referenceElement) {\n    const indexOfElementToMove    = this.elements.indexOf(elementToMove)\n    const indexOfReferenceElement = this.elements.indexOf(referenceElement)\n\n    if (indexOfElementToMove === -1 || indexOfReferenceElement === -1) {\n      throw new Error('Cannot move one element after another, because one element is missing')\n    }\n\n    if (indexOfReferenceElement - indexOfElementToMove === 1) {\n      // no need to move\n      return\n    }\n\n    this.elements = arrayMoveIndex(\n      this.elements,\n      indexOfElementToMove,\n      indexOfReferenceElement + 1,\n    )\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements.length = 0\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   *\n   * @param {Node[]} elements\n   */\n  removeTheseElements(elements) {\n    let indexInput = elements.length\n\n    while (indexInput--) {\n      let indexOutput = this.elements.length\n\n      while (indexOutput--) {\n        if (elements[indexInput] === this.elements[indexOutput]) {\n          this.elements.splice(indexOutput, 1)\n\n          continue // remove only the first occurrence\n        }\n      }\n    }\n\n    // if (elements.length > 0) {\n    //   this.elements = this.elements.filter(\n    //     (element) => !(elements.includes(element)),\n    //   )\n    // }\n  }\n\n  /**\n   * @param {Node[]} elements\n   */\n  replaceElements(elements) {\n    this.elements = elements\n  }\n}\n\nexport { ElementsCollector }\n","class HtmlTemplateParserElement {\n  tagName = '-'\n\n  /** @type {HtmlTemplateParserElement} */\n  parent = this\n\n  /** @type {HtmlTemplateParserElement[]} */\n  children = []\n\n  /** @type {Object<string, any>} */\n  attributes = {}\n\n  /**\n   * Create a new instance of this class, but also put it\n   * into the list of children of the current instance\n   *\n   * @param {HtmlTemplateParserElement} parent\n   * @param {Object<string, any>} attributes\n   * @returns {HtmlTemplateParserElement}\n   */\n  newChild(parent, attributes) {\n    const child = new HtmlTemplateParserElement()\n\n    child.parent = parent\n    child.attributes = attributes\n\n    this.children.push(child)\n\n    return child\n  }\n}\n\nexport { HtmlTemplateParserElement }\n","/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n","import { isWhitespace, stringToBoolean } from '../functions.js'\nimport { HtmlTemplateParserElement } from './HtmlTemplateParserElement.js'\nimport { SELF_CLOSING_TAGS } from './constants.js'\n\n/**\n * This class is used to turn JS template literals (containing HTML code) into\n * properly ordered Template Tree.\n */\nclass HtmlTemplateParser {\n  #attrName = ''\n\n  /**\n   * The quote symbol in <...attr=\"value\"> - a single or a double quote.\n   * When the attribute has no quote, for example <...attr=123...>,\n   * the quote would be an empty space.\n   *\n   * @type {\"'\" | \"\\\"\" | \" \" | ''}\n   */\n  #attrQuote = ''\n\n  /** @type {any} */\n  #attrValue = ''\n\n  /** @type {Object<string, any>} */\n  #attributes = {}\n\n  /**\n   * Usually a string, but it could be function, boolean, number...\n   *\n   * @type {any}\n   */\n  #char\n\n  /** @type {any} */\n  #charPrevious\n\n  /** @type {any[]} */\n  #data = []\n\n  /**\n   * Would be set to the method that is going to be used for the next char iteration\n   *\n   * @type {() => void}\n   */\n  #stage = this.#stageNothing\n\n  #styleAttrName = ''\n\n  /** @type {any} */\n  #styleAttrValue = ''\n\n  /** @type {Object<string, any>} */\n  #styles = {}\n\n  #tagName = ''\n\n  #tagNameClosing = ''\n\n  #textContents = ''\n\n  /** @type {HtmlTemplateParserElement} */\n  #topElement = new HtmlTemplateParserElement()\n\n  /** @type {HtmlTemplateParserElement} */\n  #currentElement = this.#topElement\n\n  /**\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   */\n  constructor(strings, keys) {\n    this.#data = this.#mergeStringsAndKeys(strings, keys)\n\n    this.#rotate()\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @returns {(HTMLElement | Text)[]}\n   */\n  generate(elementsCreator) {\n    if (this.#tagName || this.#tagNameClosing) {\n      throw new Error('Some HTML tag is not closed')\n    }\n\n    const elements = this.#generateChildren(elementsCreator, this.#topElement)\n\n    return elements\n  }\n\n  /**\n   * @param {any} to\n   * @param {any} data\n   * @returns {any}\n   */\n  #appendData(to, data) {\n    if (typeof to === 'function') {\n      // The input is a function. In this case:\n      // If the data to append is also a function, return that function\n      // If the data to append is not a function, return the input\n      return (typeof data === 'function')\n        ? data\n        : to\n    }\n\n    return (\n      typeof to === 'string'\n      && (\n        typeof data === 'string'\n        || typeof data === 'number'\n        || typeof data === 'boolean'\n      )\n    )\n      ? to + data.toString()\n      : data\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @param {HtmlTemplateParserElement} element\n   * @returns {(HTMLElement | Text)[]}\n   */\n  #generateChildren(elementsCreator, element) {\n    /** @type {(HTMLElement | Text)[]} */\n    const output = []\n\n    for (const child of element.children) {\n      let el = null\n\n      if (child.tagName === 'if') {\n        el = elementsCreator.if(\n          stringToBoolean(child.attributes?.condition ?? ''),\n          () => this.#generateChildren(elementsCreator, child),\n        )\n      }\n      else if (child.tagName === 'for') {\n        if ('iterations' in child.attributes) {\n          el = elementsCreator.for(\n            0,\n            parseInt(child.attributes?.iterations ?? 0) - 1,\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n        else if ('from' in child.attributes || 'to' in child.attributes) {\n          el = elementsCreator.for(\n            parseInt(child.attributes?.from ?? 0),\n            parseInt(child.attributes?.to ?? 0),\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else if (child.tagName === 'forEach') {\n        if ('object' in child.attributes) {\n          el = elementsCreator.forEach(\n            child.attributes?.object ?? {},\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else {\n        el = elementsCreator.createElement(\n          child.tagName,\n          child.attributes,\n          this.#generateChildren(elementsCreator, child),\n        )\n\n        output.push(el)\n      }\n    }\n\n    return output\n  }\n\n  #makeNewElement() {\n    const parent = this.#currentElement\n    const attributes = this.#attributes\n\n    if (Object.keys(this.#styles).length > 0) {\n      attributes.style = this.#styles\n    }\n\n    const child = this.#currentElement.newChild(parent, attributes)\n\n    child.tagName = this.#tagName\n\n    this.#currentElement = child\n  }\n\n  /**\n   * JS Templates provide two arrays - a string array and keys array.\n   * This function is designed to merge these two into a single array.\n   *\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   * @returns {any[]}\n   */\n  #mergeStringsAndKeys(strings, keys=[]) {\n    const output = []\n\n    for (let index = 0; index < strings.length; index++) {\n      if (strings[index]) {\n        output.push(strings[index])\n      }\n\n      if (keys[index] !== undefined) {\n        output.push(keys[index])\n      }\n    }\n\n    return output\n  }\n\n  #rotate() {\n    for (\n      let dataIndex = 0;\n      dataIndex < this.#data.length;\n      dataIndex++\n    ) {\n      if (typeof this.#data[dataIndex] === 'string') {\n        for (\n          let charIndex = 0;\n          charIndex < this.#data[dataIndex].length;\n          charIndex++\n        ) {\n          this.#char         = this.#data[dataIndex][charIndex]\n          this.#charPrevious = this.#data[dataIndex][charIndex - 1]\n\n          // this.#char, this.#stage.name)\n\n          this.#stage()\n        }\n      }\n      else {\n        this.#char = this.#data[dataIndex]\n        this.#charPrevious = undefined\n\n        // console.log(this.#char, this.#stage.name)\n\n        this.#stage()\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setAttribute(name, value) {\n    if (!name) return\n\n    this.#attributes[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  /**\n   * @param {() => void} stage\n   */\n  #setStage(stage) {\n    // Actions to do before a given stage is set\n    if (stage === this.#stageAttrName) {\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n    }\n\n    // Set the stage\n    this.#stage = stage\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setStyle(name, value) {\n    if (!name) return\n\n    this.#styles[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  #stageAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '/') {\n      if (SELF_CLOSING_TAGS.includes(this.#tagName)) {\n        this.#makeNewElement()\n      }\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === '=') {\n      this.#setStage(this.#stageAttrOpenQuote)\n    }\n    else {\n      this.#attrName += this.#char\n    }\n  }\n\n  #stageAttrOpenQuote() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '\\'' || this.#char === '\"') {\n      this.#attrQuote = this.#char\n\n      this.#setStage(\n        (this.#attrName === 'style')\n          ? this.#stageStyleAttrName\n          : this.#stageAttrValue,\n      )\n    }\n    else {\n      // Value without quotes.\n      // Whitespaces are allowed before the value, but not after.\n      // For that reason, the quote would be a whitespace here\n\n      this.#attrQuote = ' '\n      this.#attrValue = this.#appendData(this.#attrValue, this.#char)\n\n      this.#setStage(this.#stageAttrValue)\n    }\n  }\n\n  #stageAttrValue() {\n    if (this.#char === '>' && this.#charPrevious !== '/') {\n      // When > is found, but the attribute wasn't closed properly.\n      // Could happen if the quote is an empty space, for example: <...attr=true>\n      // Or even unclosed quote, for example: <...attr=\"value>\n      if (this.#attrQuote && this.#attrName && this.#attrValue) {\n        this.#setAttribute(this.#attrName, this.#attrValue)\n      }\n\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n\n      this.#setStage(this.#stageNothing)\n\n      this.#makeNewElement()\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setAttribute(this.#attrName, this.#attrValue)\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      if (this.#char instanceof Object) {\n        this.#attrValue = this.#char\n      }\n      else {\n        this.#attrValue += this.#char\n      }\n    }\n  }\n\n  #stageNothing() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '<') {\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      // In HTML when there are multiple spaces before or after a text,\n      // only one could be visualized. So if\n      if (this.#charPrevious === ' ') {\n        this.#textContents = this.#charPrevious + this.#char\n      }\n      else {\n        this.#textContents = this.#char\n      }\n\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTextContents)\n    }\n  }\n\n  #stageStyleAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setStage(this.#stageAttrName)\n    }\n    else if (this.#char === ':') {\n      this.#setStage(this.#stageStyleAttrValue)\n    }\n    else {\n      this.#styleAttrName += this.#char\n    }\n  }\n\n  #stageStyleAttrValue() {\n    if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === ';') {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageStyleAttrName)\n    }\n    else if (this.#char === this.#attrQuote) {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#styleAttrValue = this.#appendData(this.#styleAttrValue, this.#char)\n    }\n  }\n\n  /**\n   * In this stage we have just detected \"<\" and we are in HTML tag.\n   * This tag could be a new tag, or it could be the closing tag.\n   *\n   * @returns {void}\n   */\n  #stageTag() {\n    if (isWhitespace(this.#char)) {\n      if (this.#tagName !== '') {\n        this.#setStage(this.#stageAttrName)\n      }\n    }\n    else if (this.#char === '/' && SELF_CLOSING_TAGS.includes(this.#tagName)) {\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      if (!this.#tagName) {\n        throw new Error('Expected tag name, found >')\n      }\n\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#charPrevious === '<' && this.#char === '/') {\n      if (!this.#tagName) {\n        //throw new Error('no tag name')\n      }\n\n      this.#tagNameClosing = ''\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else {\n      this.#tagName += this.#char\n    }\n  }\n\n  #stageTagToClose() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      if (\n        this.#currentElement.tagName // Empty if text node\n        && this.#currentElement.tagName !== '-'\n        && !SELF_CLOSING_TAGS.includes(this.#currentElement.tagName)\n        && this.#currentElement.tagName !== this.#tagNameClosing\n      ) {\n        throw new Error(`Expected ${this.#currentElement.tagName} tag to be closed, but ${this.#tagNameClosing} found`)\n      }\n\n      this.#tagName = ''\n      this.#tagNameClosing = ''\n\n      if (\n        !this.#currentElement.tagName // Text node\n      ) {\n        this.#currentElement = this.#currentElement.parent.parent\n      }\n      else {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#setStage(this.#stageNothing)\n    }\n    else {\n      this.#tagNameClosing += this.#char\n    }\n  }\n\n  #stageTextContents() {\n    if (this.#char === '<') {\n      // Reset what was possibly used for text node\n      this.#attributes = {}\n      this.#currentElement.attributes.textContent = this.#textContents\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      this.#textContents = this.#appendData(this.#textContents, this.#char)\n\n      if (!this.#currentElement.tagName) {\n        this.#currentElement.attributes.textContent = this.#textContents\n      }\n    }\n  }\n}\n\nexport { HtmlTemplateParser }\n","import { Component } from './Component.js'\nimport { EnumStateAction, HTML_TAGS, symState, symTemplateFunction } from './constants.js'\nimport { ElementsCollector } from './ElementsCollector.js'\nimport { setSuggestedItems, unsetSuggestedItems } from './elementsSuggestor.js'\nimport {\n  addChildrenToStack,\n  addChildToStack,\n  addEventListenerIfPossible,\n  appendChildrenToElement,\n  arrayRemoveKey,\n  chainElements,\n  forEachLoop,\n  forLoop,\n  format,\n  getGlobalObject,\n  insertAfter,\n  isEventAttribute,\n  modifyStyleRule,\n  objectLength,\n  setDataSetAttributesToElement,\n  setElementAttrOrProp,\n  stringToHTML,\n} from './functions.js'\nimport { HtmlTemplateParser } from './HtmlTemplateParser/HtmlTemplateParser.js'\nimport { isState } from './state.js'\nimport {\n  hasSubscriptions,\n  moveSubscriptions,\n  removeAllSubscriptions,\n} from './SubscriptionsManager.js'\n\n/**\n * @typedef {Array<{key: (string | number | symbol | undefined), elements: (Node)[]}>} RenderedElementsMap\n */\n\nclass ElementsCreator {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the\n   * elements separately. Then, when the IF or FOR statement ends, the\n   * collected elements are moved to the upper level and that new level\n   * is deleted.\n   *\n   * @type {ElementsCollector[]}\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {Element | ShadowRoot | null}\n   */\n  #containerElement\n\n  /** @type {Document} */\n  #document\n\n  /**\n   * Is String-Rendering mode\n   *\n   * @type {boolean}\n   */\n  #isSr = true\n\n  /**\n   * Used only for Browser rendering.\n   * This element is used by html(), in its simple mode.\n   *\n   * @type {HTMLTemplateElement | null}\n   */\n  #reusableTemplateElement = null\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /** @type {Window} */\n  #window\n\n  /**\n   * @param {Window} window\n   * @param {HTMLElement | Element | ShadowRoot | null} containerElement\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} [translations=[]]\n   */\n  constructor(window, containerElement, templates, translations = []) {\n    this.#window = window\n    this.#document = window.document\n    this.#isSr = this.#document.baseURI === ''\n    this.#containerElement = containerElement\n    this.#templates = templates\n    this.#translations = translations\n\n    // HTML_TAGS.forEach((tagName) => {\n    //   // @ts-ignore\n    //   this[tagName] = this[tagName].bind(this)\n    // })\n  }\n\n  /**\n   * Create a DOM element (or multiple elements) and put it into the elements collector\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * @returns {HTMLElement | Text}\n   */\n  createElement(tagName, ...args) {\n    const element = (tagName)\n      ? this.#document.createElement(tagName)\n      : this.#document.createTextNode('')\n\n    /** @type {any[]} */\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string') {\n        // In case of a string, create a new text node.\n        // This way, multiple text nodes can be put into the element,\n        // mixed with http elements.\n\n        const textNode = this.#document.createTextNode(\n          this.#translate(argument),\n        )\n\n        addChildToStack(textNode, children)\n      }\n      else if (typeof argument === 'number') {\n        // The number is converted into a string\n\n        const textNode = this.#document.createTextNode(\n          argument.toString(),\n        )\n\n        addChildToStack(textNode, children)\n      }\n      // @ts-ignore\n      else if (argument instanceof this.#window.Node) {\n        // This is a child, created by this function, to be appended to its parent\n        addChildToStack(argument, children)\n      }\n      else if (argument instanceof Array) {\n        if (argument.length === 0) {\n          continue\n        }\n\n        let isChildrenArray = false\n\n        for (const child of argument) {\n          if (\n            // @ts-ignore\n            child instanceof this.#window.Node // Node includes HTMLElement and Comment\n          ) {\n            isChildrenArray = true\n\n            break\n          }\n        }\n\n        // Case 1) Array, containing at least one child to be added to their parent\n        // In DOM, if some elements are not children, they are turned into strings,\n        // but the same produces error in SSR\n        if (isChildrenArray) {\n          addChildrenToStack(argument, children)\n        }\n        // Case 2) Array, containing string to be formatted\n        else {\n          const textNode = this.#document.createTextNode(\n            this.#arrayTranslateFormatTranslate(argument),\n          )\n\n          addChildToStack(textNode, children)\n        }\n      }\n      else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = this.#translate(argument.message)\n      }\n      else if (argument instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? argument.getElementsSr()\n          : argument.getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          for (const child of childrenGroup) {\n            addChildToStack(child, children)\n          }\n        }\n      }\n      else if (argument instanceof Function) {\n        // Is it a Template function?\n        if (argument[symTemplateFunction]) {\n          const { thisLevel, upperLevel } = this.#beforeStatement()\n\n          argument(this)\n\n          const generatedElements = this.#collectedElements[thisLevel].getElements()\n\n          addChildrenToStack(generatedElements, children)\n\n          this.#afterStatement({ thisLevel, upperLevel })\n        }\n        else {\n          if (this.#isSr) {\n            // @ts-ignore\n            element.innerHTML = `(${argument.toString()})()`\n          }\n          else {\n            if (element instanceof HTMLScriptElement) {\n              const inlineScript = this.#document.createTextNode(`(${argument.toString()})()`)\n              element.appendChild(inlineScript)\n            }\n            else {\n              if (\n                'value' in element\n                && !(element instanceof HTMLLIElement) // <li> has value, but it accepts only numbers\n              ) {\n                this.#setPropertiesToElement(element, { value: argument })\n              }\n              else {\n                // eslint-disable-next-line @typescript-eslint/no-loop-func\n                const callbackOnTemplate = () => {\n                  this.#statementHandlerForFunction(\n                    'nest',\n                    argument,\n                    true,\n                    // eslint-disable-next-line @typescript-eslint/no-loop-func\n                    (\n                      value,\n                      isInitialRun,\n                      commentElementBegin, // Should be Comment element on the first run only\n                      commentElementEnd, // Should be Comment element on the first run only\n                    ) => {\n                      if (value instanceof Function || value instanceof Component) {\n                        if (value instanceof Component) {\n                          const generatedChildren = (this.#isSr)\n                            ? value.getElementsSr()\n                            : value.getElements()\n\n                          if (isInitialRun) {\n                            addChildToStack(commentElementBegin, children)\n                            addChildrenToStack(generatedChildren[0], children)\n                            addChildToStack(commentElementEnd, children)\n                          }\n                          else {\n                            this.#collectedElements[0].addElements(generatedChildren[0])\n                          }\n                        }\n                        else if (symTemplateFunction in value) {\n                          // @ts-ignore\n                          value(this)\n\n                          if (isInitialRun) {\n                            const level = this.#collectedElements.length - 1\n\n                            const generatedElements = this.#collectedElements[level].getElements()\n\n                            addChildToStack(commentElementBegin, children)\n                            addChildrenToStack(generatedElements, children)\n                            addChildToStack(commentElementEnd, children)\n                          }\n                          else {\n                            children.length = 0 // maybe not necessary\n                          }\n                        }\n                      }\n                      else {\n                        if (isInitialRun && commentElementBegin) {\n                          this.#unsubscribeElementAndItsChildren(commentElementBegin)\n                          this.#setPropertiesToElement(element, { textContent: value })\n                        }\n                      }\n                    })\n                }\n\n                this.#setPropertiesToElement(\n                  element, { textNode: argument }, callbackOnTemplate,\n                )\n              }\n            }\n          }\n        }\n      }\n      else if (\n        argument instanceof Object\n        && !(argument instanceof Function)\n        && argumentID === 1\n      ) {\n        // If Object, and the first argument, this is a property.\n        // This condition needs to be at the end of the 'if' chain.\n\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    const level = this.#collectedElements.length - 1\n\n    /**\n     * Along with the known children, there might be unknown children,\n     * created from a function call such as templateCall($). These unknown\n     * children would be placed after the first known child.\n     *\n     * @example\n     * $.div($.span(), templateCall($))\n     *\n     * However, the scenario when the function call is the first argument is\n     * not covered:\n     * @example\n     * $.div(templateCall($), $.span())\n     */\n    if (children.length > 0) {\n      const collectedElements = this.#collectedElements[level].getElements()\n      const indexOfFirstKnownChild = collectedElements.indexOf(children[0])\n\n      if (indexOfFirstKnownChild > -1) {\n        if (children.length < collectedElements.length - indexOfFirstKnownChild) {\n          // Replace the children with all collected elements, starting from the first known child\n          children = collectedElements.slice(indexOfFirstKnownChild)\n        }\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    this.#collectedElements[level].removeTheseElements(children)\n    this.#collectedElements[level].addElement(element)\n\n    return element\n  }\n\n  /**\n   * For loop with from-to numbers\n   *\n   * @param {number} from\n   * @param {number} to\n   * @param {ForLoopIterableCallback} handler\n   * @returns {Node[] | Error}\n   */\n  for(from, to, handler) {\n    const callback = () => {\n      const result = forLoop(from, to, handler)\n\n      if (result instanceof Error) console.error(result)\n    }\n\n    return this.#statementHandler('for', null, callback)\n  }\n\n  /**\n   * \"for\" loop for objects, arrays, maps and sets\n   *\n   * @template T\n   * @param {T | function() : T} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forEach(input, handler) {\n    return this.#forEachLoop(1, input, handler)\n  }\n\n  /**\n   * \"for\" loop for states\n   *\n   * @template T\n   * @param {State} input\n   * @param {ForLoopCallback<T>} handler\n   * @param {ForLoopCallbackOnEmpty} handlerOnEmpty\n   * @returns {Node[] | Error}\n   */\n  forState(input, handler, handlerOnEmpty) {\n    return this.#forEachLoop(2, input, handler, handlerOnEmpty)\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  getCreatedElements() {\n    return this.#collectedElements[0].getElements()\n  }\n\n  /**\n   * - Browser mode: Returns an empty string\n   * - Server mode: Generate HTML code of the elements at level 0\n   *\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   * - Browser mode: Empty string\n   * - Server mode: The final HTML code\n   */\n  getHtmlCode(htmlOptions) {\n    let htmlCode = ''\n\n    if (this.#isSr) {\n      const containerElement = this.#containerElement\n\n      if (containerElement) {\n        // @ts-ignore\n        htmlCode = containerElement.paintChildren(htmlOptions)\n      }\n    }\n\n    return htmlCode\n  }\n\n  /**\n   * @param {string[] | string} strings\n   * A string when html is used as a function, or an array of strings when used as template\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  html(strings, ...keys) {\n    const elements = (\n      keys.length === 0\n      && this.#translations.length === 0 // the faster method doesn't translate anything\n    )\n      ? this.#htmlForSimpleString((strings instanceof Array) ? strings[0] : strings)\n      : this.#htmlForTemplateLiteral((strings instanceof Array) ? strings : [strings], ...keys)\n\n    for (const element of elements) {\n      if (\n        // Dummy tag (virtual mode) when simple string, or text node when template literal\n        // In both cases the tag name is an empty string\n        // @ts-ignore\n        element.tagName === ''\n      ) {\n        element.textContent = this.#translate(element.textContent)\n      }\n    }\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   *\n   * @param {boolean | StatementBindFunction} condition\n   * @param {function():void} handler\n   * @param {function():void} [elseHandler]\n   * @returns {Node[]}\n   */\n  if(condition, handler, elseHandler) {\n    /**\n     * If the condition is a value (true or false), the elements\n     * are either created or not.\n     *\n     * If the condition is a function, two helper Comment elements\n     * are created - one in the beginning and another at the end.\n     * All normal elements are placed in between.\n     */\n\n    /**\n     * @param {any} data\n     */\n    const callbackForFunction = (data) => {\n      if (Boolean(data)) {\n        if (handler instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            ? handler.getElementsSr()\n            : handler.getElements()\n\n          const level = this.#collectedElements.length - 1\n\n          this.#collectedElements[level].addElements(generatedChildren[0])\n        }\n        else if (handler instanceof Function) {\n          handler()\n        }\n      }\n      else {\n        if (elseHandler instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            ? elseHandler.getElementsSr()\n            : elseHandler.getElements()\n\n          const level = this.#collectedElements.length - 1\n\n          this.#collectedElements[level].addElements(generatedChildren[0])\n        }\n        else if (elseHandler instanceof Function) {\n          elseHandler()\n        }\n      }\n    }\n\n    return (condition instanceof Function)\n      ? this.#statementHandlerForFunction(\n        'if', condition, true, callbackForFunction,\n      )\n      : this.#statementHandler(\n        'if', condition, callbackForFunction,\n      )\n  }\n\n  async render() {\n    this.#collectedElements = [new ElementsCollector()] // Reset\n\n    for (const template of this.#templates) {\n      if (template instanceof Function) {\n        // @ts-ignore\n        let returnedValue = template(this)\n\n        if (returnedValue instanceof Promise) {\n          returnedValue = await returnedValue\n        }\n\n        if (returnedValue && typeof returnedValue === 'string') {\n          this.html(returnedValue)\n        }\n        else if (returnedValue instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            // @ts-ignore\n            ? returnedValue.useTranslations(this.#translations).getElementsSr()\n            // @ts-ignore\n            : returnedValue.useTranslations(this.#translations).getElements()\n\n          for (const childrenGroup of generatedChildren) {\n            this.#collectedElements[0].addElements(childrenGroup)\n          }\n        }\n        else if (returnedValue instanceof Function) {\n          // @ts-ignore\n          returnedValue(this)\n        }\n        else if (returnedValue instanceof Array) {\n          let allComponents   = true\n          let allFunctions = true\n\n          for (const value of returnedValue) {\n            if (!(value instanceof Component)) {\n              allComponents = false\n\n              break\n            }\n\n            if (!(value instanceof Function)) {\n              allFunctions = false\n\n              break\n            }\n          }\n\n          if (allComponents) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Component)) break\n\n              const generatedChildren = (this.#isSr)\n                ? value.getElementsSr()\n                : value.getElements()\n\n              for (const childrenGroup of generatedChildren) {\n                this.#collectedElements[0].addElements(childrenGroup)\n              }\n            }\n          }\n          else if (allFunctions) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Function)) break\n\n              // @ts-ignore\n              value(this)\n            }\n          }\n        }\n      }\n      else if (template instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? template.useTranslations(this.#translations).getElementsSr()\n          : template.useTranslations(this.#translations).getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          this.#collectedElements[0].addElements(childrenGroup)\n        }\n      }\n    }\n\n    this.#appendChildrenToContainer()\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler.\n   *\n   * @param {object} input\n   * @param {number} input.thisLevel\n   * @param {number} input.upperLevel\n   * @returns {Node[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n\n    // ... and clean this level\n    this.#collectedElements[thisLevel].replaceElements([]) // to keep reference\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  #appendChildrenToContainer() {\n    const containerElement = this.#containerElement\n\n    if (containerElement) {\n      appendChildrenToElement(containerElement, this.getCreatedElements())\n    }\n  }\n\n  /**\n   * @template T\n   * @param {T[]} array\n   * @returns {(string | T)[]}\n   */\n  #arrayTranslate(array) {\n    const needsTranslation = Boolean(this.#translations)\n\n    return (needsTranslation)\n      ? array.map((value) => this.#translate(value))\n      : array\n  }\n\n  /**\n   * This function first translations each part of the input array,\n   * then formats it, then translations the result.\n   *\n   * @template T\n   * @param {T[]} array\n   * The input array is supposed to be what would format() arguments be\n   * (format string plus multiple arguments), but as an array.\n   * @returns {string}\n   */\n  #arrayTranslateFormatTranslate(array) {\n    return this.#translate(\n      format.apply(\n        null,\n        // @ts-ignore\n        this.#arrayTranslate(array),\n      ),\n    )\n  }\n\n  /**\n   * Prepare the levels to be used in IF or FOR loop, and return them.\n   * This method must be called in the IF or FOR loop, before calling\n   * the handler.\n   *\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    this.#collectedElements.push(new ElementsCollector())\n\n    const thisLevel = this.#collectedElements.length - 1\n    const upperLevel = thisLevel - 1\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * @template T\n   * @param {ForLoopType} forLoopType\n   * @param {(T | function() : T) | State} input\n   * @param {ForLoopCallback<T>} handler\n   * @param {ForLoopCallbackOnEmpty} [handlerOnEmpty]\n   * @returns {Node[] | Error}\n   */\n  #forEachLoop(forLoopType, input, handler, handlerOnEmpty) {\n    /** @type {Node[] | null} */\n    let renderedElementsMapOnEmpty = null\n\n    /**\n     * @param {any} value\n     * @returns {any}\n     */\n    const beforeIterationCallback = (value) => {\n      return this.#translate(value)\n    }\n\n    if (isState(input)) {\n      /**\n       * @param {State} state\n       * @param {ElementsCollector} elementsCollector\n       * @param {string | number | symbol} [keyToRender]\n       * @returns {RenderedElementsMap}\n       */\n      const callbackForState = (state, elementsCollector, keyToRender) => {\n        /** @type {RenderedElementsMap} */\n        const renderedElementsMap = []\n\n        /**\n         * Initially there is 1 element - the forEach-begin element.\n         * We want to start after this element.\n         */\n        let index = elementsCollector.getElements().length\n\n        /**\n         * @param {number | string} [key]\n         */\n        const onIteration = (key) => {\n          const elementsFromCollector = elementsCollector.getElements()\n          const elements = (index === 0)\n            ? elementsFromCollector\n            : elementsFromCollector.slice(index)\n\n          if (key === undefined) {\n            // Save the elements, so then they can be removed\n            renderedElementsMapOnEmpty = elements\n          }\n          else {\n            if (renderedElementsMapOnEmpty) {\n              for (const element of renderedElementsMapOnEmpty) {\n                this.#unsubscribeElementAndItsChildren(element)\n                // @ts-ignore\n                element.remove()\n              }\n\n              renderedElementsMapOnEmpty = null\n            }\n          }\n\n          renderedElementsMap.push({ key, elements })\n\n          index = elementsFromCollector.length\n        }\n\n        forEachLoop(\n          forLoopType,\n          state,\n          handler,\n          handlerOnEmpty,\n          beforeIterationCallback,\n          keyToRender,\n          onIteration,\n        )\n\n        return renderedElementsMap\n      }\n\n      return this.#statementHandlerForState(\n        'forState',\n        input,\n        callbackForState,\n        handlerOnEmpty instanceof Function,\n      )\n    }\n\n    /**\n     * @param {State} data\n     */\n    const callbackForFunction = (data) => {\n      forEachLoop(\n        forLoopType,\n        data,\n        handler,\n        handlerOnEmpty,\n        beforeIterationCallback,\n      )\n    }\n\n    const type = (forLoopType === 1) ? 'forEach' : 'forState'\n\n    if (input instanceof Function) {\n      return this.#statementHandlerForFunction(\n        // @ts-ignore\n        type, input, true, callbackForFunction,\n      )\n    }\n\n    return this.#statementHandler(type, input, callbackForFunction)\n  }\n\n  /**\n   * Quicker version for the 'html' function that does not use parsing,\n   * because the input is just a single string.\n   *\n   * @param {string} string\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForSimpleString(string) {\n    /** @type {(Element | Node)[]} */\n    let elements = []\n\n    if (this.#isSr) {\n      // We create a new dummy element every time.\n      // An element with no tag name is skipped in the render stage.\n      const element = this.#document.createElement('')\n\n      element.innerHTML = string ?? ''\n\n      elements = [element]\n    }\n    else {\n      if (\n        false\n        && 'DOMParser' in this.#window\n      ) {\n        elements = Array.from(stringToHTML(string.trim() ?? '').childNodes)\n      }\n      else {\n        if (!this.#reusableTemplateElement) {\n          this.#reusableTemplateElement = this.#document.createElement('template')\n        }\n\n        // In DOM, we can reuse the same element\n        const template = this.#reusableTemplateElement\n\n        //element.setHTML(string.trim() ?? '')\n        template.innerHTML = string.trim() ?? ''\n\n        // childNodes also contains the text nodes\n        elements = Array.from(template.content.childNodes)\n\n        template.innerHTML = ''\n      }\n    }\n\n    // Add the newly created elements into the collection\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].addElements(elements)\n\n    return elements\n  }\n\n  /**\n   * @param {string[]} strings\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForTemplateLiteral(strings, ...keys) {\n    const htmlTemplateParser = new HtmlTemplateParser(strings, keys)\n\n    return htmlTemplateParser.generate(this)\n  }\n\n  /**\n   * @param {Comment} beginCommentElement\n   * @param {Node[]} elements\n   * @returns {boolean}\n   * Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginCommentElement, elements) {\n    if (!(this.#containerElement?.contains(beginCommentElement))) {\n      return false\n    }\n\n    /** @type {Node|Comment} */\n    let lastElement = beginCommentElement\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are a pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   *\n   * @param {Comment} beginCommentElement\n   * - The 'begin' Comment element\n   * @returns {number}\n   * - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginCommentElement) {\n    /**\n     * @type {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n     */\n    const COMMENT_NODE = 8 // Node.COMMENT_NODE\n\n    if (beginCommentElement.nodeType !== COMMENT_NODE) {\n      return -1\n    }\n\n    // Decide what will be the text content of the end element\n    const beginCommentElementText = beginCommentElement.textContent\n    let endElementText = ''\n\n    if (beginCommentElementText) {\n      endElementText = beginCommentElementText.slice(0, -6) + '-end'\n    }\n    else {\n      return -1\n    }\n\n    /**\n     * Delete elements between the 'begin' and 'end' element,\n     * including inner 'begin' and 'end' elements\n     */\n\n    let currentElement = beginCommentElement.nextSibling\n    let statementsCounter = 0\n    let deletedElementsCount = 0\n\n    while (true) {\n      if (currentElement === null) {\n        break\n      }\n\n      if (currentElement.nodeType === COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginCommentElementText) { // inner 'begin' element\n          statementsCounter += 1\n        }\n        else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0) {\n            break\n          }\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      this.#unsubscribeElementAndItsChildren(currentElement)\n\n      currentElement.remove()\n      deletedElementsCount += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElementsCount\n  }\n\n  /**\n   * @param {HTMLElement | Text} element\n   * @param {Object<string, string|number|Object<*,*>|function(*):*|BindFunction|HTMLElement>} properties\n   * @param {Function} [callbackOnTemplate]\n   */\n  #setPropertiesToElement(element, properties, callbackOnTemplate) {\n    for (let propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#isSr) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function) {\n          setElementAttrOrProp(element, propertyName, property)\n\n          continue\n        }\n      }\n      else if (property instanceof Function) {\n        // If the property name is an event (for example onClick),\n        // then the property is a function. This function should not\n        // be immediately called to get a value from it. Instead, it\n        // should be added as a listener.\n        if (addEventListenerIfPossible(element, propertyName, property)) {\n          continue\n        }\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        /** @type {BindFunction} */\n        const bindFunction = property\n\n        setSuggestedItems(\n          element,\n          propertyName,\n          '',\n          bindFunction,\n          null,\n        )\n\n        let value = bindFunction(element)\n\n        if (\n          (value instanceof Function && Object.hasOwn(value, symTemplateFunction))\n          || value instanceof Component\n        ) {\n          unsetSuggestedItems()\n\n          if (callbackOnTemplate) {\n            callbackOnTemplate()\n          }\n\n          continue\n        }\n        else if (value instanceof Function) {\n          /**\n           * Remark \"() => value\"\n           *\n           * In forEach the value is provided as a function, so it is not necessary\n           * to use it like this () => value. However, when used like this, the function\n           * returns a function. Resolve the returned function here.\n           */\n          value = value()\n        }\n        else {\n          if (propertyName === 'textNode') {\n            unsetSuggestedItems()\n\n            const textNode = this.#document.createTextNode(value)\n\n            element.appendChild(textNode)\n\n            moveSubscriptions(\n              element, textNode, bindFunction, { propertyName: 'textContent' },\n            )\n\n            continue\n          }\n        }\n\n        unsetSuggestedItems()\n\n        if (value instanceof Array) {\n          value = this.#arrayTranslateFormatTranslate(value)\n        }\n        else if (typeof value === 'string') {\n          value = this.#translate(value)\n        }\n\n        if (propertyName) {\n          setElementAttrOrProp(element, propertyName, value)\n        }\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'style'\n        && property instanceof Object\n      ) {\n        // @ts-ignore\n        this.#setStylesToElement(element, property)\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'data'\n      ) {\n        if (property instanceof Object) {\n          // @ts-ignore\n          setDataSetAttributesToElement(element, property)\n        }\n      }\n      else if (propertyName === 'textContent') {\n        if (property instanceof Array) {\n          element[propertyName] = this.#arrayTranslateFormatTranslate(property)\n        }\n        else {\n          element[propertyName] = this.#translate(property)\n        }\n      }\n      else {\n        if (\n          propertyName === 'innerText'\n          || (\n            propertyName === 'value'\n            && (\n              // Can't use HTMLInputElement here, because it does not exist in SrDOM\n              // @ts-ignore\n              element.tagName === 'INPUT'\n              // @ts-ignore\n              && (element.getAttribute('type') ?? '').toLowerCase() === 'button'\n            )\n          )\n        ) {\n          property = this.#translate(property)\n        }\n\n        setElementAttrOrProp(element, propertyName, property)\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<keyof CSSStyleDeclaration, (string | BindFunction)>} styleRules\n   */\n  #setStylesToElement(element, styleRules) {\n    for (const ruleName in styleRules) {\n      const ruleValue = styleRules[ruleName]\n      let finalValue  = ''\n\n      if (ruleValue instanceof Function) {\n        const propertyName = 'style'\n        const bindFunction = ruleValue\n\n        setSuggestedItems(\n          element,\n          propertyName,\n          ruleName,\n          bindFunction,\n          null,\n        )\n\n        finalValue = bindFunction(element)\n\n        unsetSuggestedItems()\n      }\n      else {\n        finalValue = ruleValue\n      }\n\n      if (typeof ruleName === 'string') {\n        // @ts-ignore\n        element.style[ruleName] = modifyStyleRule(ruleName, finalValue)\n      }\n    }\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach' | 'forState'} type\n   * @param {any} data\n   * @param {function(any): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandler(type, data, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    callback(data)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach' | 'forState' | 'nest'} type\n   * @param {function(): any} bindFunction\n   * @param {boolean} autoAddCommentElements\n   * @param {function((boolean | State | Template | Component), boolean, Comment?, Comment?): void} callbackForFunction\n   * @returns {Node[]}\n   */\n  #statementHandlerForFunction(type, bindFunction, autoAddCommentElements, callbackForFunction) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n    const isFunction = bindFunction instanceof Function\n\n    if (isFunction) {\n      const commentElementBegin = this.#document.createComment(`${type}-begin`)\n      const commentElementEnd   = this.#document.createComment(`${type}-end`)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementBegin)\n      }\n\n      /**\n       * @type {StatementRepaintFunctionForFunction}\n       */\n      const statementRepaintFunction = (bindFunctionResult) => {\n        if (this.#isSr) {\n          return\n        }\n\n        const level = this.#collectedElements.length - 1\n\n        // Clean all contents.\n        this.#collectedElements[level].removeAllElements()\n        //this.#removeStatementElements(commentElementBegin)\n\n        // Create the new elements\n        callbackForFunction(bindFunctionResult, false, null, null)\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[level].getElements(),\n        )\n\n        if (!success) {\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n        }\n      }\n\n      const element = commentElementBegin\n      const propertyName = `--${type}` // --if or --for\n\n      setSuggestedItems(\n        element,\n        propertyName,\n        '',\n        bindFunction,\n        statementRepaintFunction,\n      )\n\n      const bindFunctionResult = bindFunction()\n\n      unsetSuggestedItems()\n\n      // Run the handler function\n      callbackForFunction(bindFunctionResult, true, commentElementBegin, commentElementEnd)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementEnd)\n      }\n    }\n    else {\n      const resolved = bindFunction\n\n      // Run the handler function\n      callbackForFunction(resolved, false, null, null)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'forState'} type\n   * @param {any} state\n   * @param {function(\n   *   State, ElementsCollector, (string | number | symbol)=\n   * ): RenderedElementsMap} callbackForState\n   * @param {boolean} hasHandlerOnEmpty\n   * @returns {Node[]}\n   */\n  #statementHandlerForState(type, state, callbackForState, hasHandlerOnEmpty) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    const commentElementBegin = this.#document.createComment(`${type}-begin`)\n    /**\n     * Use the 'end' comment element as a storage for the rendered elements.\n     * It's easier this way, and if the element is being deleted along with\n     * the rendered elements, no references to these elements remains.\n     *\n     * @type {Comment & {renderedElementsMap: RenderedElementsMap}}\n     */\n    // @ts-ignore\n    const commentElementEnd = this.#document.createComment(`${type}-end`)\n\n    this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n    /**\n     * @param {State} updatedState\n     * @param {State} updatedObject\n     * @param {Node} lastElement\n     * @param {string | symbol | undefined} prop\n     */\n    const createElements = (updatedState, updatedObject, lastElement, prop) => {\n      let isTemporaryLevel = false\n\n      if (commentElementBegin.parentElement) {\n        // When the loop is in inner level, make a new temporary collector,\n        // which will be deleted after that. Otherwise, the new elements are\n        // placed on level 0\n        this.#collectedElements.push(new ElementsCollector())\n        isTemporaryLevel = true\n      }\n\n      const level = this.#collectedElements.length - 1\n      const added = callbackForState(updatedState, this.#collectedElements[level], prop)\n      const isArray = updatedObject instanceof Array\n\n      for (const item of added) {\n        // prop would be undefined when using the state is empty, so don't add this item in the map\n        if (prop !== undefined) {\n          if (isArray) {\n            // @ts-ignore\n            commentElementEnd.renderedElementsMap[prop] = item\n          }\n          else {\n            commentElementEnd.renderedElementsMap.push(item)\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-loop-func\n        for (const element of item.elements) {\n          if (level === 0) {\n            /**\n             * Parent element is needed in order to apply 'after'.\n             * But if for example there is a for loop (for a state) at top level and\n             * immediately after that a new element is added to the state, that new\n             * element can't be properly added after the previous one, because of the\n             * lack of parent element.\n             * Because of this, let's reorder the collected elements.\n             */\n\n            this.#collectedElements[level].moveElementAfterAnother(element, lastElement)\n          }\n\n          // @ts-ignore\n          lastElement.after(element)\n          lastElement = element\n        }\n      }\n\n      if (isTemporaryLevel) {\n        this.#collectedElements.pop()\n      }\n    }\n\n    /**\n     * TODO Refactor this function, because it's too long\n     *\n     * @type {StatementRepaintFunctionForState}\n     */\n    const statementRepaintFunction = (action, updatedState, prop, arrayFunctionArgs) => {\n      // @ts-ignore\n      const stateParams = updatedState[symState]\n      const updatedObject = stateParams.target\n\n      if (!(updatedObject instanceof Object)) {\n        return\n      }\n\n      if (this.#isSr) {\n        return\n      }\n\n      if (action === EnumStateAction.CREATE) {\n        /** @type {null | string} */\n        let prevKey = null\n\n        const iterator = (\n          updatedObject instanceof Map\n          || updatedObject instanceof Set\n        )\n          ? updatedObject.keys()\n          : Object.keys(updatedObject)\n\n        for (let i of iterator) {\n          if (i === prop) {\n            break\n          }\n\n          prevKey = i\n        }\n\n        /**\n         * @type {Node}\n         */\n        let lastElement = commentElementBegin\n\n        if (prevKey !== null) {\n          let isKeyInRenderedElementsMap = false\n\n          for (const item of commentElementEnd.renderedElementsMap) {\n            if (!item) continue\n\n            if (item.key === prevKey) {\n              const { elements } = item\n\n              lastElement = (elements.length > 0)\n                ? elements[elements.length - 1]\n                : lastElement\n\n              isKeyInRenderedElementsMap = true\n\n              break\n            }\n          }\n        }\n\n        createElements(updatedObject, updatedObject, lastElement, prop)\n      }\n      else if (action === EnumStateAction.UPDATE) {\n        // if (updatedObject[prop] instanceof Object) {\n        //\n        //   const iterator = (\n        //     updatedObject instanceof Map\n        //     || updatedObject instanceof Set\n        //   )\n        //     ? updatedObject.keys()\n        //     : Object.keys(updatedObject)\n        //\n        //   for (let i of iterator) {\n        //     if (i !== prop && updatedObject[i] === updatedObject[prop]) {\n        //       console.log(prop, i)\n        //       break\n        //     }\n        //   }\n        // }\n        // else {\n        statementRepaintFunction(EnumStateAction.DELETE, updatedState, prop, undefined)\n        statementRepaintFunction(EnumStateAction.CREATE, updatedState, prop, undefined)\n        // }\n      }\n      /**\n       * Element has been deleted from the state?\n       * - Remove the DOM elements\n       * - Remove these same elements from .renderedElementsMap\n       */\n      if (action === EnumStateAction.DELETE) {\n        let index = commentElementEnd.renderedElementsMap.length\n\n        while (index--) {\n          //const item = commentElementEnd.renderedElementsMap[index]\n\n          if (!commentElementEnd.renderedElementsMap[index]) continue\n\n          const isArray = updatedObject instanceof Array\n\n          if (commentElementEnd.renderedElementsMap[index].key === prop) {\n            for (const element of commentElementEnd.renderedElementsMap[index].elements) {\n              // Delete all subscriptions for this element\n              this.#unsubscribeElementAndItsChildren(element)\n\n              // Delete the element itself\n              // @ts-ignore\n              element.remove()\n            }\n\n            if (isArray) {\n              commentElementEnd.renderedElementsMap[index].elements.length = 0\n\n              delete commentElementEnd.renderedElementsMap[index]\n\n              if (index === updatedObject.length - 1) {\n                commentElementEnd.renderedElementsMap.length = updatedObject.length\n              }\n            }\n            else {\n              commentElementEnd.renderedElementsMap\n                = arrayRemoveKey(commentElementEnd.renderedElementsMap, index)\n            }\n\n            break\n          }\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_SPLICE) {\n        if (updatedObject instanceof Array) {\n          /**\n           * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n           */\n          // @ts-ignore\n          let [start, deleteCount, ...newItems] = arrayFunctionArgs\n\n          if (deleteCount === Infinity) {\n            deleteCount = updatedObject.length - start\n          }\n          else if (deleteCount < 0) {\n            deleteCount = 0\n          }\n\n          if (deleteCount > 0) {\n            for (\n              let i = start, length = start + deleteCount;\n              i < length;\n              i++\n            ) {\n              statementRepaintFunction(\n                EnumStateAction.DELETE, updatedState, i.toString(), undefined,\n              )\n              delete commentElementEnd.renderedElementsMap[i]\n            }\n          }\n\n          const oldSize = commentElementEnd.renderedElementsMap.length\n          const newSize = updatedObject.length\n          const sizeDiff = newSize - oldSize\n\n          // The array needs to be enlarged?\n          if (sizeDiff > 0) {\n            commentElementEnd.renderedElementsMap.length = newSize\n\n            // Update keys in the map\n            for (\n              let index = newSize - 1;\n              index >= start + newItems.length;\n              index--\n            ) {\n              const oldIndex = index - sizeDiff\n\n              if (oldIndex < 0) break\n\n              commentElementEnd.renderedElementsMap[index] = commentElementEnd.renderedElementsMap[oldIndex]\n              commentElementEnd.renderedElementsMap[index].key = index.toString()\n              delete commentElementEnd.renderedElementsMap[oldIndex]\n            }\n          }\n          else if (sizeDiff < 0) {\n            commentElementEnd.renderedElementsMap.splice(start, deleteCount)\n\n            // Update keys in the map\n            for (\n              let index = newSize - 1;\n              index >= start + newItems.length;\n              index--\n            ) {\n              commentElementEnd.renderedElementsMap[index].key = index.toString()\n            }\n          }\n\n          if (newItems.length > 0) {\n            for (\n              let index = start;\n              index < start + newItems.length;\n              index++\n            ) {\n              statementRepaintFunction(\n                EnumStateAction.CREATE, updatedState, index.toString(), undefined,\n              )\n            }\n          }\n        }\n\n        commentElementEnd.renderedElementsMap.length = updatedObject.length\n      }\n      else if (action === EnumStateAction.ARRAY_SWAP) {\n        const [key1, key2] = arrayFunctionArgs\n\n        // change siblings\n        // swap elements objects by reference\n        const tmp = commentElementEnd.renderedElementsMap[key2].elements\n        commentElementEnd.renderedElementsMap[key2].elements = commentElementEnd.renderedElementsMap[key1].elements\n        commentElementEnd.renderedElementsMap[key1].elements = tmp\n\n        for (let i = 1; i < commentElementEnd.renderedElementsMap.length; i++) {\n          chainElements(\n            // @ts-ignore\n            ...commentElementEnd.renderedElementsMap[i - 1].elements,\n            ...commentElementEnd.renderedElementsMap[i].elements,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_COPY_WITHIN) {\n        let [target, start, end] = arrayFunctionArgs\n\n        for (\n          let fromIndex = start, toIndex = target;\n          fromIndex < end;\n          fromIndex++, toIndex++\n        ) {\n          statementRepaintFunction(\n            EnumStateAction.DELETE, updatedState, toIndex.toString(), undefined,\n          )\n          statementRepaintFunction(\n            EnumStateAction.CREATE, updatedState, toIndex.toString(), undefined,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_SORT) {\n        for (\n          let index = 0, length = updatedObject.length;\n          index < length;\n          index++\n        ) {\n          statementRepaintFunction(\n            EnumStateAction.DELETE, updatedState, index.toString(), undefined,\n          )\n          statementRepaintFunction(\n            EnumStateAction.CREATE, updatedState, index.toString(), undefined,\n          )\n        }\n      }\n      else if (action === EnumStateAction.ARRAY_PUSH) {\n        const length = updatedObject.length\n\n        let mapIndex = commentElementEnd.renderedElementsMap.length\n        let lastElement = commentElementBegin\n\n        while (mapIndex--) {\n          const item = commentElementEnd.renderedElementsMap[mapIndex]\n\n          if (!item) continue\n\n          const elementsLength = item.elements.length\n\n          if (elementsLength > 0) {\n            // @ts-ignore\n            lastElement = item.elements[elementsLength - 1]\n\n            break\n          }\n        }\n\n        prop = (length - 1).toString()\n\n        createElements(updatedObject, updatedObject, lastElement, prop)\n      }\n      else if (action === EnumStateAction.ARRAY_LENGTH) {\n        const newLength = arrayFunctionArgs?.[0] ?? 0\n\n        if (newLength < commentElementEnd.renderedElementsMap.length) {\n          let index = commentElementEnd.renderedElementsMap.length\n\n          while (index--) {\n            // Skip if already deleted.\n            if (commentElementEnd.renderedElementsMap[index] === undefined) {\n              continue\n            }\n\n            statementRepaintFunction(EnumStateAction.DELETE, updatedState, index.toString(), undefined)\n\n            if (index === newLength) break\n          }\n        }\n\n        if (updatedObject instanceof Array) {\n          commentElementEnd.renderedElementsMap.length = updatedObject.length\n        }\n      }\n\n      if (\n        hasHandlerOnEmpty\n        // it's empty string when array function callback event is fired\n        && (!(updatedObject instanceof Array) || prop === '')\n        && objectLength(updatedObject) === 0\n      ) {\n        createElements(updatedState, updatedObject, commentElementBegin, undefined)\n      }\n    }\n\n    const propertyName = `-s-${type}` // --if or --for\n    const bindFunction = () => state\n\n    setSuggestedItems(\n      commentElementEnd,\n      propertyName,\n      '',\n      bindFunction,\n      statementRepaintFunction,\n    )\n\n    // In this callback the 'for' loop is called\n    const added = callbackForState(state, this.#collectedElements[thisLevel])\n\n    if (added.length === 1 && added[0].key === undefined) {\n      // Initial draw on empty state. We don't want the result from it,\n      // because then it interferes.\n      added.splice(0, 1)\n    }\n\n    commentElementEnd.renderedElementsMap = added\n\n    unsetSuggestedItems()\n\n    this.#collectedElements[thisLevel].addElement(commentElementEnd)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {any} input\n   * @returns {string}\n   */\n  #translate(input) {\n    if (typeof input === 'string') {\n      const translated = this.#translateString(input, this.#translations)\n\n      if (typeof translated === 'string') {\n        return translated\n      }\n\n      // Use the global translation\n      const globalObject = getGlobalObject()\n\n      const globallyTranslated = this.#translateString(\n        input,\n        // @ts-ignore\n        globalObject?.paintorTranslations,\n      )\n\n      if (typeof globallyTranslated === 'string') {\n        return globallyTranslated\n      }\n    }\n\n    return input\n  }\n\n  /**\n   * @param {string} str\n   * @param {Translation[]} [translations]\n   * @returns {string | boolean}\n   */\n  #translateString(str, translations) {\n    if (translations instanceof Array && translations.length > 0) {\n      for (const translateObject of translations) {\n        if (str in translateObject) {\n          return translateObject[str]\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Recursively search in an element's child nodes for\n   * elements, who are used in state subscriptions, and\n   * unsubscribe them. Also unsubscribe the initial element.\n   *\n   * Note: This function works only on the browser!\n   *\n   * @param {Node} element\n   */\n  #unsubscribeElementAndItsChildren(element) {\n    if (hasSubscriptions(element)) {\n      Object.assign(element, { '--deleted': true })\n      removeAllSubscriptions(element)\n    }\n\n    /**\n     * Unsubscribe each child element recursively.\n     *\n     * Performance Notes:\n     * - This loop is reached too often for its performance to be ignored\n     * - Used .forEach() before, but while loop is more than 30% faster\n     */\n\n    let index = element.childNodes.length\n\n    while (index--) {\n      this.#unsubscribeElementAndItsChildren(element.childNodes[index])\n    }\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\n\n/**\n * @see https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n * @param {...any} boundArgs\n * @returns {function(...[*]):*}\n * @this {any}\n */\nfunction bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  /**\n   * @param {...any} args\n   * @returns {any}\n   * @this {any}\n   */\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\nconst { prototype } = ElementsCreator\n\n// prototype.createElement.bindArgs = bindArgs\nObject.assign(prototype.createElement, { bindArgs })\n\nHTML_TAGS.forEach((tagName) => {\n  // @ts-ignore\n  prototype[tagName] = prototype.createElement.bindArgs(tagName)\n})\n\nexport { ElementsCreator }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @enum {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = Object.freeze([\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n])\n\n/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from\n * each other, such as elements, text and comments.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const EnumNodeTypes = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n})\n","export class DOMException extends Error {\n  /**\n   * @param {string} message\n   * @param {string} [name]\n   */\n  constructor(message, name) {\n    super(message)\n    this.name = name ?? 'DOMException'\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { paint } from './functions.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\nclass Node {\n  /** @type {Node | null} */\n  nextSibling = null\n\n  /** @type {Node | null} */\n  previousSibling = null\n\n  /** @type {string} */\n  textContent = ''\n\n  /** @type {Node[]} */\n  #childNodes = []\n\n  /**\n   * @type {string}\n   */\n  #nodeName = ''\n\n  /** @type {number} */\n  #nodeType = 1\n\n  /** @type {Node | null} */\n  #parentNode = null\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} nodeName\n   */\n  constructor(nodeType, nodeName) {\n    this.#nodeType = nodeType\n    this.#nodeName = nodeName\n  }\n\n  /**\n   * @returns {string}\n   */\n  get baseURI() {\n    return ''\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  get childNodes() {\n    return this.#childNodes\n  }\n\n  /**\n   * @returns {Node | null}\n   */\n  get firstChild() {\n    return this.#childNodes[0] ?? null\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @returns {string}\n   */\n  get nodeName() {\n    return this.#nodeName\n  }\n\n  /**\n   * @returns {number}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentnode.asp\n   * @returns {Node | null}\n   */\n  get parentNode() {\n    return this.#parentNode\n  }\n\n  /**\n   * Not in DOM\n   *\n   * @param {Node | null} parentNode\n   */\n  set parentNode(parentNode) {\n    this.#parentNode = parentNode\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\n   *\n   * @param {Node} aChild\n   * @throws {DOMException | TypeError}\n   */\n  appendChild(aChild) {\n    // If the parent of aChild is not a Document, DocumentFragment, or an Element.\n    if (\n      this.nodeType !== EnumNodeTypes.DOCUMENT_NODE\n      && this.nodeType !== EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n      && this.nodeType !== EnumNodeTypes.ELEMENT_NODE\n    ) {\n      throw new DOMException('This node type does not support this method.')\n    }\n\n    // If the insertion of aChild would lead to Document with more than one Element as child.\n    // (document should contain body here, which is an Element)\n    if (\n      this.nodeType === EnumNodeTypes.DOCUMENT_NODE\n    ) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': Only one element on document allowed.')\n    }\n\n    // If aChild is not a DocumentFragment, a DocumentType, an Element, or a CharacterData.\n    if (!(aChild instanceof Node)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Node\\''\n        + ': parameter 1 is not of type \\'Node\\'.'\n\n      throw new TypeError(errorMessage)\n    }\n\n    // If the node already exists, do not append it\n    if (this.#childNodes.includes(aChild)) {\n      return\n    }\n\n    if (aChild === this) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': The new child element contains the parent.')\n    }\n\n    this.#childNodes.push(aChild)\n    aChild.parentNode = this\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#childNodes.length - 2\n\n    if (prevKey >= 0) {\n      this.#childNodes[prevKey].nextSibling = aChild\n      aChild.previousSibling = this.#childNodes[prevKey] ?? null\n    }\n  }\n\n  /**\n   * TODO Make this function do whatever it has to do\n   *\n   * @returns {boolean}\n   */\n  contains() {\n    return false\n  }\n\n  /**\n   * TODO Check whether this function works correctly\n   *\n   * @param {Node} newElement\n   * @param {Node} referenceElement\n   * @returns {Node}\n   */\n  insertBefore(newElement, referenceElement) {\n    /** @type {Node[]} */\n    const newChildren = []\n\n    for (const child of this.#childNodes) {\n      if (child === referenceElement) {\n        newChildren.push(newElement)\n      }\n\n      newChildren.push(child)\n    }\n\n    this.#childNodes = newChildren\n\n    return newElement\n  }\n\n  /**\n   * Removes a child node and returns the removed node.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n   * @param {Node} childNode\n   * @returns {Node}\n   */\n  removeChild(childNode) {\n    if (!childNode) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'parameter 1 is not of type \\'HTMLElement\\'.',\n      )\n    }\n\n    if (!this.#childNodes.includes(childNode)) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'The node to be removed is not a child of this node.',\n      )\n    }\n\n    this.#childNodes = this.#childNodes.filter((node) => node !== childNode)\n\n    return childNode\n  }\n\n  /**\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   */\n  paintChildren({ indent = '' }) {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.childNodes) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += paint(child, indent, '', isChild)\n    }\n\n    return children\n  }\n}\n\nexport { Node }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Comment extends Node {\n  constructor() {\n    super(EnumNodeTypes.COMMENT_NODE, '#comment')\n  }\n}\n\nexport default Comment\n\nexport { Comment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Text extends Node {\n  constructor() {\n    super(EnumNodeTypes.TEXT_NODE, '#text')\n  }\n}\n\nexport { Text }\n","import { Comment } from './Comment.js'\nimport { BOOLEAN_ATTRIBUTES, SELF_CLOSING_TAGS } from './constants.js'\nimport { HTMLElement } from './HTMLElement.js'\nimport { Text } from './Text.js'\nimport { Node } from './Node.js'\n\n/**\n * @param {number} count\n * @param {string} [chars='\\t']\n * @returns {string}\n */\nfunction generateIndents(count, chars = '\\t') {\n  let output = ''\n\n  for (let i = 0; i < count; i++) {\n    output += chars\n  }\n\n  return output\n}\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {SrAttr[]} attributes\n * @returns {string}\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      ) {\n        output += ` ${name}`\n      }\n    }\n    else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else if (value instanceof Function) value = `return(${value.toString()}).call(this,window.event)`\n      else value = value.toString()\n\n      value = value.replace(/\\\"/g, '\\\\\"')\n      value = escapeHTML(value)\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @returns {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * @param {Node} node\n * @param {string} indentWith\n * @param {string} indentCurrent\n * @param {boolean} isChild If true, a new row is put in the beginning\n * @returns {string}\n */\nfunction paint(node, indentWith, indentCurrent, isChild = false) {\n  let output = ''\n  let indent = ''\n  let newRow = ''\n\n  if (indentWith) {\n    indent = indentCurrent\n    newRow = '\\n'\n  }\n\n  if (node instanceof Comment) {\n    output += `${newRow}${indent}<!--${node.textContent}-->`\n  }\n  else if (node instanceof Text) {\n    output += `${newRow}${indent}${node.textContent}`\n  }\n  else if (node instanceof HTMLElement) {\n    const selfClosingTag = (SELF_CLOSING_TAGS.includes(node.tagName))\n    const attributes = generateAttributesString(node.attributes)\n\n    let style = ''\n\n    if (Object.keys(node.style).length > 0) {\n      style = ` style=\"${getStyleStringFromObject(node.style)}\"`\n    }\n\n    // Paint the opening tag (including attributes)\n    if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n    output += indent\n\n    // Paint the opening tag\n    if (node.tagName) {\n      output += `<${node.tagName.toLowerCase()}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n    }\n\n    // Paint the text in the element\n    output += node.textContent\n\n    // Paint the children\n    let children = ''\n\n    for (const child of node.childNodes) {\n      children += paint(child, indentWith, indentCurrent + indentWith, true)\n    }\n\n    if (children) {\n      output += children + newRow + indent\n    }\n\n    // Paint the closing tag\n    if (\n      node.tagName !== ''\n    ) {\n      output += (selfClosingTag) ? '/>' : `</${node.tagName.toLowerCase()}>`\n    }\n  }\n\n  return output\n}\n\nexport { paint, escapeHTML }\n","import { EnumNodeTypes } from './constants.js'\nimport { escapeHTML } from './functions.js'\nimport { Node } from './Node.js'\n\nexport class Element extends Node {\n  /** @type {SrAttr[]} */\n  #attributes = []\n\n  /** @type {string} */\n  #tagName = ''\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} tagName\n   */\n  constructor(nodeType, tagName) {\n    super(nodeType, tagName.toUpperCase())\n\n    this.#tagName = tagName.toUpperCase()\n  }\n\n  /**\n   * @returns {SrAttr[]}\n   */\n  get attributes() {\n    return this.#attributes\n  }\n\n  /**\n   * Includes only Element nodes\n   *\n   * @returns {Element[]}\n   */\n  get children() {\n    // @ts-ignore\n    return this.childNodes.filter((node) => node instanceof Element)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @returns {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @returns {string}\n   */\n  get innerHTML() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @returns {string}\n   */\n  get tagName() {\n    return this.#tagName\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   *\n   * @param {Node | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof Node) {\n      this.appendChild(childElement)\n    }\n    else {\n      this.textContent = escapeHTML(childElement.toString())\n    }\n  }\n\n  /**\n   * @param {string} attributeName\n   * @returns {string | null}\n   */\n  getAttribute(attributeName) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return null\n    }\n\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      return null\n    }\n    else {\n      return this.#attributes[index].value\n    }\n  }\n\n  /**\n   * Removes the element from the children list of its parent.\n   *\n   * @returns {void}\n   */\n  remove() {\n    this.parentNode?.removeChild(this)\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   *\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return\n    }\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      this.#attributes.push({ name, value })\n    }\n    else {\n      this.#attributes[index] = { name, value }\n    }\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { Element } from './Element.js'\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n *\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringToCamelCase(str) {\n  const split = str.split('-')\n\n  if (split.length === 1) return split[0]\n\n  return (\n    split[0]\n    + split.slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @returns {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  /** @type {StylesObject} */\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass HTMLElement extends Element {\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {string} tagName\n   */\n  constructor(tagName) {\n    super(EnumNodeTypes.ELEMENT_NODE, tagName)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @returns {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @returns {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | StylesObject} input\n   */\n  set style(input) {\n    // In the browser there are few ways to set the style:\n    // - By setting each individual property (.style.color = red)\n    // - By setting '.style.cssText' to a string (.style.cssText = 'color:red')\n    // - By setting '.style' itself to a string (.style = 'color:red')\n\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style) {\n        this.#style[key] = style[key].toString()\n      }\n    }\n  }\n}\n\nexport { HTMLElement }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass DocumentFragment extends Node {\n  constructor() {\n    super(EnumNodeTypes.DOCUMENT_FRAGMENT_NODE, '#document-fragment')\n  }\n}\n\nexport { DocumentFragment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Comment, DocumentFragment, HTMLElement, Element, Node, Text } from './orderedExports.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass Document extends Node {\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ELEMENT_NODE = EnumNodeTypes.ELEMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ATTRIBUTE_NODE = EnumNodeTypes.ATTRIBUTE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  TEXT_NODE = EnumNodeTypes.TEXT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  CDATA_SECTION_NODE = EnumNodeTypes.CDATA_SECTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  PROCESSING_INSTRUCTION_NODE = EnumNodeTypes.PROCESSING_INSTRUCTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  COMMENT_NODE = EnumNodeTypes.COMMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_NODE = EnumNodeTypes.DOCUMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_TYPE_NODE = EnumNodeTypes.DOCUMENT_TYPE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_FRAGMENT_NODE = EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n\n  /** @type {HTMLElement} */\n  #body\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @type {Element[]}\n   */\n  #children = []\n\n  constructor() {\n    super(/* DOCUMENT_NODE */ 9, '#document')\n\n    const html = new HTMLElement('html')\n    const head = new HTMLElement('head')\n    const body = new HTMLElement('body')\n\n    html.appendChild(head)\n    html.appendChild(body)\n\n    this.#children.push(html)\n\n    this.#body = body\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get body() {\n    return this.#body\n  }\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/children\n   * @returns {Element[]}\n   */\n  get children() {\n    return this.#children\n  }\n\n  /**\n   * @returns {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment() {\n    return new DocumentFragment()\n  }\n\n  /**\n   * @param {string} [text]\n   * @returns {Comment}\n   */\n  createComment(text = '') {\n    const element = new Comment()\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   * @returns {HTMLElement}\n   */\n  createElement(tagName) {\n    return new HTMLElement(tagName)\n  }\n\n  /**\n   * @param {string} text\n   * @returns {Text}\n   */\n  createTextNode(text) {\n    const element = new Text()\n\n    element.textContent = text\n\n    return element\n  }\n\n  // /**\n  //  * @param {boolean} [prettyPrint]\n  //  * @returns {string}\n  //  */\n  // paint(prettyPrint = true) {\n  //   const tabsCount = (prettyPrint) ? 0 : -1\n  //\n  //   return this.body.paint(tabsCount)\n  // }\n}\n\nexport { Document, HTMLElement }\n","import { Comment, Document, DocumentFragment, Element, HTMLElement, Node, Text } from './orderedExports.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\n/**\n * String-Rendering DOM\n */\nclass Window {\n  /** @type {typeof Comment} */\n  Comment = Comment\n\n  /** @type {typeof DocumentFragment} */\n  DocumentFragment = DocumentFragment\n\n  /** @type {typeof Element} */\n  Element = Element\n\n  /** @type {typeof HTMLElement} */\n  HTMLElement = HTMLElement\n\n  /** @type {typeof Node} */\n  Node = Node\n\n  /** @type {typeof Text} */\n  Text = Text\n\n  /** @type {typeof DOMException} */\n  DOMException = DOMException\n\n  /** @type {typeof Error} */\n  Error = Error\n\n  /** @type {typeof TypeError} */\n  TypeError = TypeError\n\n  /** @type {Document} */\n  document\n\n  constructor() {\n    this.document = new Document()\n  }\n}\n\nexport { Window }\n","import { ElementsCreator } from './ElementsCreator.js'\nimport {\n  isBrowserEnvironment,\n  isValidCustomElementName,\n  selectorEndsWithId,\n} from './functions.js'\nimport { Window as SrWindow } from './SrDOM/Window.js'\nimport { state } from './state.js'\n\nconst isBrowserEnv = isBrowserEnvironment()\nconst srWindow = new SrWindow()\n\nclass Component {\n  state = null\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {HTMLElement[] | HTMLCollection}\n   */\n  #containerDOMElements = []\n\n  /** @type {Node[][]} */\n  #finalElements = []\n\n  /**\n   * In server mode this will hold the final WebApi code\n   *\n   * @type {string}\n   */\n  #finalHtmlCode = ''\n\n  /** @type {boolean} */\n  #isStatic = false\n\n  /** @type {boolean} */\n  #renderCustomElements = false\n\n  /** @type {string} */\n  #selector = ''\n\n  /** @type {string} */\n  #selectorNonId = ''\n\n  /** @type {Map<Translation | null, string>} */\n  #staticHtmlCodes = new Map()\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElements() {\n    this.#render(null, window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElementsSr() {\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * Renders the components into an HTML code and returns it\n   *\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  html(options) {\n    if (this.#isStatic) {\n      return this.staticHtml(options)\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true, options)\n\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection} container\n   * @returns {void}\n   */\n  paint(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only use this function in browser environment')\n    }\n\n    if (!container) {\n      throw new Error('No container selected.')\n    }\n\n    if (\n      typeof container !== 'string'\n      && !(container instanceof HTMLElement)\n      && !(container instanceof NodeList)\n      && !(container instanceof Array)\n      && !(container instanceof HTMLCollection)\n    ) {\n      throw new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof container}>`,\n      )\n    }\n\n    this.#render(container, window, true)\n  }\n\n  /**\n   * @param {boolean} [on=true]\n   * @returns {Component}\n   */\n  static(on = true) {\n    this.#isStatic = on\n\n    return this\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  staticHtml(options) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticHtmlCodes.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render('', window, true, options)\n      this.#staticHtmlCodes.set(\n        key,\n        this.#finalHtmlCode,\n      )\n    }\n\n    return this.#staticHtmlCodes.get(key) ?? ''\n  }\n\n  /**\n   * @param {TemplateTree} tree\n   * @returns {void\n   *   | string\n   *   | HTMLElement | HTMLElement[]\n   *   | Component | Component[]\n   *   | Template | Template[]\n   * }\n   */\n  template(tree) {\n  }\n\n  /**\n   * @param {...(Template | Template[] | Component | Component[])} from\n   * @returns {Component}\n   */\n  useTemplates(...from) {\n    if (from instanceof Array) {\n      for (const item of from) {\n        if (item instanceof Array) {\n          for (const template of item) {\n            this.#templates.push(template)\n          }\n        }\n        else {\n          this.#templates.push(item)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * @param {...Translation} translations\n   * @returns {Component}\n   */\n  useTranslations(...translations) {\n    // Reset translations here, because the whole api chain (containing this function)\n    // can be executed multiple times, but with different translations every time.\n    // EDIT: Commented out, so that translations can be used in Components\n    // this.#translations = []\n\n    translations.map((item) => {\n      if (item instanceof Array) {\n        item.forEach((subItem) => {\n          if (!this.#translations.includes(subItem)) {\n            this.#translations = [...this.#translations, subItem]\n          }\n        })\n      }\n      else if (item instanceof Object) {\n        if (!this.#translations.includes(item)) {\n          this.#translations = [...this.#translations, item]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElements() {\n    if (this.#containerDOMElements) {\n      for (const el of this.#containerDOMElements) {\n        while (el?.firstChild) {\n          el.removeChild(el.firstChild)\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is for tricking TS that the string-rendering DOM's Window\n   * has the same type of the browser DOM's window\n   *\n   * @returns {Window}\n   */\n  #getSrWindow() {\n    // @ts-ignore\n    return srWindow\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {Translation[]} translations\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #init(container, window, translations, templates) {\n    this.#finalElements.length = 0\n    this.#finalHtmlCode = ''\n\n    this.#initContainer(container, window)\n    this.#initTranslations(translations)\n    this.#initTemplates(templates)\n\n    return true\n  }\n\n  /**\n   * @param {string | HTMLElement| HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @returns {boolean}\n   */\n  #initContainer(container, window) {\n    const isSr = window.document.baseURI === ''\n\n    if (typeof container === 'string') {\n      this.#selector = container\n      this.#renderCustomElements = false\n\n      if (isValidCustomElementName(container)) {\n        this.#renderCustomElements = true\n      }\n      else {\n        if (!selectorEndsWithId(container)) {\n          this.#selectorNonId = container\n        }\n\n        // @ts-ignore\n        this.#containerDOMElements = (isSr)\n          ? [window.document.createElement('#container')]\n          : window.document.querySelectorAll(container)\n\n        if (!this.#containerDOMElements) {\n          throw new Error(`Could not find an element by the following query: ${container}`)\n        }\n      }\n    }\n    else if (container instanceof HTMLElement) {\n      this.#containerDOMElements = [container]\n    }\n    else if (\n      container instanceof NodeList\n      || container instanceof HTMLCollection\n    ) {\n      this.#containerDOMElements = container\n    }\n    else if (container instanceof Array) {\n      for (const element of container) {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('All elements in the input array must be DOM elements')\n        }\n      }\n\n      this.#containerDOMElements = container\n    }\n\n    return true\n  }\n\n  /**\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTemplates(templates) {\n    if (this.template instanceof Function) {\n      this.state = (this.state)\n        ? state(this.state)\n        : this.state\n\n      // @ts-ignore\n      this.#templates.push(this.template.bind(this))\n    }\n\n    for (let template of templates) {\n      if (\n        !(template instanceof Function)\n        && !(template instanceof Component)\n      ) {\n        throw new Error('The template must be a function')\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Translation[]} translations\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTranslations(translations) {\n    if (!(translations instanceof Array)) {\n      throw new Error('The argument \\'translations\\' must be an Array')\n    }\n\n    this.#translations = translations\n\n    return true\n  }\n\n  /**\n   * @param { string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {boolean} clearContainers\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #render(container, window, clearContainers = true, htmlOptions = {}) {\n    this.#init(container, window, this.#translations, this.#templates)\n\n    if (clearContainers) {\n      this.#clearContainerElements()\n    }\n\n    const templates = this.#templates\n    const translations = this.#translations\n\n    if (!window) {\n      throw new Error('Missing window element')\n    }\n\n    if (this.#renderCustomElements) {\n      // Custom Elements\n\n      /**\n       * @param {Component} component\n       * @returns {CustomElementConstructor}\n       */\n      const getCustomElementConstructor = (component) => {\n        return class extends HTMLElement {\n          constructor() {\n            super()\n            this.attachShadow({ mode: 'open' })\n          }\n\n          connectedCallback() {\n            if (!this.shadowRoot) {\n              throw new Error('Missing shadow root')\n            }\n\n            component.#renderElements(window, this.shadowRoot, templates, translations, htmlOptions)\n          }\n        }\n      }\n\n      customElements.define(\n        this.#selector,\n        getCustomElementConstructor(this),\n      )\n    }\n    else {\n      // DOM or SrDOM\n\n      if (this.#selectorNonId) {\n        const domObserver = new MutationObserver((mutationList) => {\n          for (const mutation of mutationList) {\n            const addedNodes = mutation.addedNodes\n\n            for (let node of addedNodes) {\n              // we track only elements, skip other nodes (e.g. text nodes)\n              if (!(node instanceof HTMLElement)) continue\n\n              // check the inserted element for being a code snippet\n              if (node.matches(this.#selectorNonId)) {\n                this.#renderElements(window, node, templates, translations, htmlOptions)\n              }\n\n              // or maybe there's a code snippet somewhere in its subtree?\n              // for (let containerElement of node.querySelectorAll(this.#selectorNonId)) {\n              //   this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n              // }\n            }\n\n          }\n        })\n\n        domObserver.observe(\n          document.body,\n          { attributes: false, childList: true, characterData: false, subtree: true },\n        )\n      }\n\n      if (this.#containerDOMElements.length === 0) {\n        this.#renderElements(window, null, templates, translations, htmlOptions)\n      }\n      else {\n        for (const containerElement of this.#containerDOMElements) {\n          this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Window} window\n   * @param {Element | ShadowRoot | null} container\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} translations\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #renderElements(window, container, templates, translations, htmlOptions = {}) {\n    const creator = new ElementsCreator(\n      window, container, templates, translations,\n    )\n    creator.render()\n\n    this.#finalHtmlCode = creator.getHtmlCode(htmlOptions)\n    this.#finalElements.push(creator.getCreatedElements())\n  }\n}\n\nexport { Component }\n","import { isBrowserEnvironment } from './functions.js'\n\n/**\n * TODO make it work for server environment\n *\n * @returns {string}\n */\nconst getLocale = function () {\n  let locale = 'en'\n\n  if (isBrowserEnvironment()) {\n    const html = document.getElementById('html')\n\n    locale = html?.getAttribute('lang') ?? locale\n  }\n\n  return locale\n}\n\n/**\n * @param {string} defaultPath\n * @param {string} locale\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createSingleTranslation = async function (defaultPath, locale) {\n  if (typeof defaultPath !== 'string') {\n    throw new Error('Translation path must be a string')\n  }\n\n  let translation = null\n\n  /**\n   * Matches on /path/to/filename.ext\n   * [1] /path/to/\n   * [2] filename\n   * [3] .ext\n   *\n   * @type {RegExpMatchArray | null}\n   */\n  const match = defaultPath.match(/^(.*?)([^.\\/\\\\]+)(.\\w+)$/m)\n\n  if (match === null) {\n    throw new TypeError(`Incorrect path: ${defaultPath}`)\n  }\n\n  const filePath = match[1] + locale + match[3]\n\n  try {\n    translation = (await import(/* @vite-ignore */ filePath)).default\n  }\n  catch (e) {\n    if (filePath !== defaultPath) {\n      translation = (await import(/* @vite-ignore */ defaultPath)).default\n    }\n  }\n\n  if (!(translation instanceof Object)) {\n    throw new TypeError(`Translation at ${filePath} must export an object`)\n  }\n\n  return translation\n}\n\n/**\n * @param {...string} defaultPaths\n * @returns {Promise<Translation[]>}\n * @throws\n */\nconst fetchTranslations = async function (...defaultPaths) {\n  const locale = getLocale()\n\n  const promises = []\n\n  for (let path of defaultPaths) {\n    promises.push(createSingleTranslation(path, locale))\n  }\n\n  return Promise.all(promises)\n}\n\nexport { fetchTranslations }\n","import { Component } from './Component.js'\nimport { state } from './state.js'\nimport { fetchTranslations } from './Translation.js'\nimport { symTemplateFunction } from './constants.js'\n\n/**\n * @param {...(Template | Template[] | Component | Component[])} from\n * @returns {Component}\n */\nfunction component(...from) {\n  return new Component().useTemplates(...from)\n}\n\n/**\n * Returns the input function, but marked to be used easily in Paintor\n *\n * @param {Template} from\n * @returns {Template}\n */\nfunction template(from) {\n  /**\n   * Mark the function, so it can be recognized later\n   * as a Template function\n   */\n  // @ts-ignore\n  from[symTemplateFunction] = true\n\n  return from\n}\n\nconst paintor = { component, state, template, fetchTranslations, Component }\n\nexport default paintor\nexport { paintor, component, state, template, fetchTranslations, Component }\n"],"names":["EnumStateAction","HTML_TAGS","symSubscriptions","symAccess","symTemplateFunction","symState","suggestedItems","setSuggestedItems","element","propertyName","subPropertyName","bindFunction","statementRepaintFunction","unsetSuggestedItems","StateProxyArrayFunctions","#arrayFnObjects","fnName","target","receiver","callback","#arrayFnPush","#arrayFnCopyWithin","#arrayFnReverse","#arrayFnShift","#arrayFnSort","#arrayFnSplice","#arrayFnUnshift","args","targetIndex","start","end","length","result","i","len","j","SubscriptionsManager","#subscriptions","state","stateProp","subscriptions","item","subscription","subs","index","key","hasSubscriptions","moveSubscriptions","fromElement","toElement","newSubscriptionProperties","prop","removeAllSubscriptions","elementSubs","idx","StateProxy","#arrayFunctions","#subsManager","object","statePath","handler","#createProxyHandler","proxy","innerStatePath","fn","#onPropCreate","#onPropDelete","#onArrayFunctionCallback","value","#onPropUpdate","action","updatedState","#onPropCreateOrDelete","list","listItem","modifyStyleRule","setElementAttrOrProp","stateIdCounter","isState","getGlobalObject","format","fmt","re","replacer","match","escaped","ptn","flag","arg","out","isBrowserEnvironment","isBrowser","addChildToStack","inputChild","childrenStack","addChildrenToStack","inputChildren","child","isEventAttribute","attributeName","isWhitespace","char","isValidCustomElementName","name","selectorEndsWithId","selector","stringToBoolean","string","int","addEventListenerIfPossible","eventSmallName","appendDOMChildrenToElement","children","fragment","appendVirtualChildrenToElement","appendChildrenToElement","forEachLoop","forLoopType","handlerOnEmpty","beforeIterationCallback","keyToRender","iterationCallback","isProxy","ret","val","forLoop","arrayRemoveKey","arr","insertAfter","newNode","existingNode","nextSibling","parentNode","setDataSetAttributesToElement","dataSet","attrOrPropName","output","objectLength","arrayMoveIndex","array","oldIndex","newIndex","k","chainElements","elements","ElementsCollector","elementsCollector","elementToMove","referenceElement","indexOfElementToMove","indexOfReferenceElement","indexInput","indexOutput","HtmlTemplateParserElement","parent","attributes","SELF_CLOSING_TAGS","HtmlTemplateParser","#attrName","#attrQuote","#attrValue","#attributes","#char","#charPrevious","#data","#stage","#stageNothing","#styleAttrName","#styleAttrValue","#styles","#tagName","#tagNameClosing","#textContents","#topElement","#currentElement","strings","keys","#mergeStringsAndKeys","#rotate","elementsCreator","#generateChildren","#appendData","to","data","el","#makeNewElement","dataIndex","charIndex","#setAttribute","#setStage","stage","#stageAttrName","#setStyle","#stageTagToClose","#stageAttrOpenQuote","#stageStyleAttrName","#stageAttrValue","#stageTag","#stageTextContents","#stageStyleAttrValue","ElementsCreator","#collectedElements","#containerElement","#document","#isSr","#reusableTemplateElement","#templates","#translations","#window","window","containerElement","templates","translations","tagName","argumentID","argument","textNode","#translate","isChildrenArray","#arrayTranslateFormatTranslate","Component","generatedChildren","childrenGroup","thisLevel","upperLevel","#beforeStatement","generatedElements","#afterStatement","inlineScript","#setPropertiesToElement","callbackOnTemplate","#statementHandlerForFunction","isInitialRun","commentElementBegin","commentElementEnd","level","#unsubscribeElementAndItsChildren","collectedElements","indexOfFirstKnownChild","from","#statementHandler","input","#forEachLoop","htmlOptions","htmlCode","#htmlForSimpleString","#htmlForTemplateLiteral","condition","elseHandler","callbackForFunction","template","returnedValue","allComponents","allFunctions","#appendChildrenToContainer","#arrayTranslate","renderedElementsMapOnEmpty","callbackForState","renderedElementsMap","elementsFromCollector","#statementHandlerForState","type","#insertStatementElements","beginCommentElement","lastElement","newElement","#removeStatementElements","beginCommentElementText","endElementText","currentElement","statementsCounter","deletedElementsCount","text","properties","property","#setStylesToElement","styleRules","ruleName","ruleValue","finalValue","autoAddCommentElements","bindFunctionResult","hasHandlerOnEmpty","createElements","updatedObject","isTemporaryLevel","added","isArray","arrayFunctionArgs","prevKey","iterator","deleteCount","newItems","oldSize","newSize","sizeDiff","key1","key2","tmp","fromIndex","toIndex","mapIndex","elementsLength","newLength","translated","#translateString","globalObject","globallyTranslated","str","translateObject","bindArgs","boundArgs","targetFunction","prototype","BOOLEAN_ATTRIBUTES","EnumNodeTypes","DOMException","message","Node","#childNodes","#nodeName","#nodeType","#parentNode","nodeType","nodeName","aChild","errorMessage","newChildren","childNode","node","indent","childNumber","isChild","paint","Comment","Text","escapeHTML","html","charsToReplace","tag","generateAttributesString","attribute","formatStringFromCamelCase","all","getStyleStringFromObject","style","indentWith","indentCurrent","newRow","HTMLElement","selfClosingTag","Element","className","childElement","attributeValue","formatStringToCamelCase","split","word","getStyleObjectFromString","formattedProperty","#style","Document","#body","#children","head","body","DocumentFragment","Window","isBrowserEnv","srWindow","SrWindow","#containerDOMElements","#finalElements","#finalHtmlCode","#isStatic","#renderCustomElements","#selector","#selectorNonId","#staticHtmlCodes","#render","#getSrWindow","options","container","on","tree","subItem","#clearContainerElements","#init","#initContainer","#initTranslations","#initTemplates","isSr","clearContainers","getCustomElementConstructor","component","#renderElements","mutationList","mutation","addedNodes","creator","getLocale","locale","createSingleTranslation","defaultPath","translation","filePath","__vitePreload","fetchTranslations","defaultPaths","promises","path","paintor"],"mappings":"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"}