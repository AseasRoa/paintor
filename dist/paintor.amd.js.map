{"version":3,"file":"paintor.amd.js","sources":["../src/constants.js","../src/StateSubscriptions.js","../src/state.js","../src/functions.js","../src/ElementsCollector.js","../src/htmlTags.js","../src/HtmlTemplateParser/HtmlTemplateParserElement.js","../src/HtmlTemplateParser/constants.js","../src/HtmlTemplateParser/HtmlTemplateParser.js","../src/ElementsCreator.js","../src/SrDOM/constants.js","../src/SrDOM/exceptions/DOMException.js","../src/SrDOM/Node.js","../src/SrDOM/Comment.js","../src/SrDOM/Text.js","../src/SrDOM/functions.js","../src/SrDOM/Element.js","../src/SrDOM/HTMLElement.js","../src/SrDOM/DocumentFragment.js","../src/SrDOM/Document.js","../src/SrDOM/Window.js","../src/Component.js","../src/Translation.js","../src/paintor.js"],"sourcesContent":["export const symSubscribe = Symbol('symSubscribe')\nexport const symSubscribed = Symbol('symSubscribed')\n\nexport const symStateId    = Symbol('symStateId')\n\nexport const symArrayAccess  = Symbol('symArrayAccess')\nexport const symObjectAccess = Symbol('symObjectAccess')\n\nexport const symTemplateFunction = Symbol('symTemplateFunction')\n\n/**\n * @readonly\n * @enum {number}\n */\nexport const EnumStateAction = Object.freeze({\n  CREATE: 1,\n  READ: 2,\n  UPDATE: 3,\n  DELETE: 4,\n})\n","import { setElementAttrOrProp, modifyStyleRule } from './functions.js'\nimport { symArrayAccess, symObjectAccess, symStateId, EnumStateAction } from './constants.js'\n\n/** @typedef {Object<*,*>} StateProxy */\n\n/**\n * @type {{\n *   element: null | Element | Comment,\n *   propertyName: string,\n *   subPropertyName: string,\n *   bindFunction: null | BindFunction,\n *   statementRepaintFunction: null | StatementRepaintFunction\n * }}\n */\nlet suggestedItems = {\n  element: null,\n  propertyName: '',\n  subPropertyName: '',\n  bindFunction: null,\n  statementRepaintFunction: null,\n}\n\n/**\n * This function should be called just before calling the bindFunction. The idea is\n * that the bindFunction, along with its html element and property name are suggested\n * here to the proxy handler. When the bindFunction is called, any state used in it\n * would trigger the proxy get event, which means that it will be added to the subscriptions.\n *\n * @param {Element | Comment} element\n * @param {string} propertyName\n * @param {string} subPropertyName\n * @param {BindFunction} bindFunction\n * @param {null | StatementRepaintFunction} statementRepaintFunction\n */\nfunction setSuggestItems(\n  element,\n  propertyName,\n  subPropertyName,\n  bindFunction,\n  statementRepaintFunction,\n) {\n  suggestedItems.element = element\n  suggestedItems.propertyName = propertyName\n  suggestedItems.subPropertyName = subPropertyName\n  suggestedItems.bindFunction = bindFunction\n  suggestedItems.statementRepaintFunction = statementRepaintFunction\n}\n\n/**\n * Reset the suggested items\n *\n * @returns {void}\n */\nfunction unsetSuggestedItems() {\n  suggestedItems = {\n    element: null,\n    propertyName: '',\n    subPropertyName: '',\n    bindFunction: null,\n    statementRepaintFunction: null,\n  }\n}\n\nclass StateSubscriptions {\n  /** @type {Map<string | symbol, Subscription[]>} */\n  #subscriptions = new Map()\n\n  /** @type {State} */\n  #state = {}\n\n  /**\n   * @param {State} state\n   * @param {string | symbol} stateProp\n   * @param {Element | Comment} element\n   * The HTML element for which the other parameters apply.\n   * @param {string} propertyName\n   * The name of the property of the HTML element, for\n   * which the subscription is going to be created.\n   * For example: 'style', 'value', 'textContent', 'innerHTML'.\n   * Also, '--if' for IF statement.\n   * @param {string} subPropertyName\n   * If the property name is 'style', the sub-property could be\n   * any style property.\n   * For example: 'fontSize'\n   * @param {BindFunction} bindFunction\n   * The function that is used instead of a fixed value.\n   * For example: () => (state.clicks)\n   * @param {StatementRepaintFunction | null} statementRepaintFunction\n   * This is only used in the if() function. It's a function that\n   * is used to repaint the elements in case the condition is changed\n   * from false to true or vice versa.\n   */\n  subscribe(\n    state,\n    stateProp,\n    element,\n    propertyName,\n    subPropertyName,\n    bindFunction,\n    statementRepaintFunction,\n  ) {\n    if (propertyName === '-s-if' || propertyName === '-s-forEach') {\n      stateProp = propertyName\n    }\n\n    if (!this.#subscriptions.has(stateProp)) {\n      this.#subscriptions.set(stateProp, [])\n    }\n\n    const subscriptions\n            = this.#subscriptions.get(stateProp) ?? []\n\n    // Search for a subscription with the same parameters.\n    // If such already exists, just don't create a new one.\n    for (const item of subscriptions) {\n      if (\n        item.element === element\n        && item.propertyName === propertyName\n        && item.subPropertyName === subPropertyName\n        && item.bindFunction === bindFunction\n        && item.statementRepaintFunction === statementRepaintFunction\n      ) return\n    }\n\n    subscriptions.push({\n      element,\n      propertyName,\n      subPropertyName,\n      bindFunction,\n      statementRepaintFunction,\n    })\n\n    // Put a mark on the element itself, telling that it\n    // has a subscription\n    Object.assign(element, { '--subscribed': true })\n  }\n\n  /**\n   * Remove any subscriptions that the element is subscribed to\n   *\n   * @param {Node} element\n   */\n  unsubscribe(element) {\n    this.#subscriptions.forEach((subscription, key) => {\n      this.#subscriptions.set(key, subscription.filter((item) => (item.element !== element)))\n    })\n  }\n\n  /**\n   * @template T\n   * @param {T} object\n   * The input object that will be used to create\n   * a proxy object with the same keys and values.\n   * @param {string} [statePath]\n   * The path to the state:\n   * <br>\n   * - If the state is the parent state, this is an empty string.\n   * <br>\n   * - If the state is a child state, this is the path to it (dot notated).\n   * @returns {T}\n   */\n  createProxy(object, statePath = '') {\n    const handler = this.#createProxyHandler()\n    const proxy = new Proxy(object, handler)\n\n    // Store the path to the state in a special value in the\n    // proxy object, but make that value invisible for \"for\"\n    // (and similar) statements.\n    // Object.defineProperty(proxy, '--state-path', {\n    //   enumerable: false,\n    //   configurable: false,\n    //   writable: false,\n    //   value: statePath,\n    // })\n\n    // Recursive proxy. To find all inner objects\n    // and turn them into child states.\n    for (const key in proxy) {\n      if (!(proxy[key] instanceof Object)) {\n        continue\n      }\n\n      const innerStatePath = (statePath === '') ? key : `${statePath}.${key}`\n\n      proxy[key] = this.createProxy(proxy[key], innerStatePath)\n    }\n\n    this.#state = proxy\n\n    return proxy\n  }\n\n  /**\n   * This is called when \"length\" of an array is changed, which\n   * happens when elements are being added or popped from the end\n   * of the array. Not when delete is being used!\n   *\n   * @param {any[]} updatedState\n   */\n  // #onArrayLengthChange(updatedState) {\n  //   const subscription = this.#subscriptions.get('-s-forEach')\n  //\n  //   if (subscription) {\n  //     subscription.forEach((listItem) => {\n  //       const { statementRepaintFunction } = listItem\n  //\n  //       if (statementRepaintFunction instanceof Function) {\n  //         statementRepaintFunction(updatedState)\n  //       }\n  //     })\n  //   }\n  // }\n\n  /**\n   * @param {EnumStateAction} action\n   * @param {State} updatedObject\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreateOrDelete(action, updatedObject, updatedState, prop) {\n    const subscription = this.#subscriptions.get('-s-forEach')\n\n    if (subscription) {\n      for (let index = 0, length = subscription.length; index < length; index++) {\n        const { statementRepaintFunction } = subscription[index]\n\n        if (statementRepaintFunction) {\n          // @ts-ignore\n          statementRepaintFunction(action, updatedObject, updatedState, prop)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {State} updatedObject\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropCreate(updatedObject, updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.CREATE, updatedObject, updatedState, prop)\n  }\n\n  /**\n   * @param {State} target\n   * @param {State} receiver\n   * @param {string | symbol} prop\n   * @param {any} value\n   */\n  #onPropUpdate(target, receiver, prop, value) {\n    if (this.#subscriptions.has(prop)) {\n      const list = this.#subscriptions.get(prop) ?? []\n\n      list.forEach((listItem) => {\n        const {\n          element,\n          propertyName,\n          subPropertyName,\n          bindFunction,\n          statementRepaintFunction,\n        } = listItem\n\n        if (Object.hasOwn(element, '--deleted')) {\n          this.unsubscribe(element)\n\n          return\n        }\n\n        let result = bindFunction.call(element, element)\n\n        if (propertyName === 'style' && subPropertyName) {\n          // @ts-ignore\n          element.style[subPropertyName]\n              = modifyStyleRule(subPropertyName, result)\n        }\n        else if (\n          propertyName === '--if'\n          || propertyName === '--for'\n          || propertyName === '--nest'\n        ) {\n          if (statementRepaintFunction) {\n            // @ts-ignore\n            statementRepaintFunction(result)\n          }\n        }\n        else {\n          /**\n           * @see Remark \"() => value\"\n           */\n          if (result instanceof Function) {\n            result = result()\n          }\n\n          // @ts-ignore\n          setElementAttrOrProp(element, propertyName, result)\n        }\n      })\n    }\n  }\n\n  /**\n   * @param {State} updatedObject\n   * @param {State} updatedState\n   * @param {string | symbol} prop\n   */\n  #onPropDelete(updatedObject, updatedState, prop) {\n    this.#onPropCreateOrDelete(EnumStateAction.DELETE, updatedObject, updatedState, prop)\n  }\n\n  /**\n   * @returns {ProxyHandler<StateProxy>}\n   */\n  #createProxyHandler() {\n    /** @type {ProxyHandler<StateProxy>} */\n    const handler = {}\n\n    handler.get = (target, prop, receiver) => {\n      /**\n       * Why is hasOwn() needed?\n       * If the state is for example an array and its whole value is read,\n       * then JS tries to read few extra properties first - map, length, constructor\n       */\n      if (\n        Object.hasOwn(target, prop)\n        || prop === symObjectAccess\n        || prop === symArrayAccess\n      ) {\n        /**\n         * In the if below it would be enough to check just one element,\n         * but because of TS more than one is checked\n         */\n        if (\n          suggestedItems.element\n          && suggestedItems.bindFunction\n        ) {\n          this.subscribe(\n            target,\n            prop,\n            suggestedItems.element,\n            suggestedItems.propertyName,\n            suggestedItems.subPropertyName,\n            suggestedItems.bindFunction,\n            suggestedItems.statementRepaintFunction,\n          )\n        }\n      }\n      // Internal functions of Set() and Map()\n      else if (\n        (target instanceof Map || target instanceof Set)\n        // @ts-ignore\n        && target[prop] instanceof Function\n      ) {\n        /**\n         * @see https://stackoverflow.com/questions/48452885/observe-changes-to-a-map-using-a-proxy\n         */\n\n        // @ts-ignore\n        const fn = target[prop]\n\n        /**\n         * @param {any[]} args\n         * @returns {*}\n         */\n        const boundFunction = (...args) => {\n          const result = fn.apply(target, args)\n\n          if (target instanceof Set) {\n            if (prop === 'add') {\n              this.#onPropCreate(target, receiver, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(target, receiver, prop)\n            }\n          }\n          else if (target instanceof Map) {\n            if (prop === 'set') {\n              this.#onPropCreate(target, receiver, prop)\n            }\n            else if (prop === 'delete') {\n              this.#onPropDelete(target, receiver, prop)\n            }\n          }\n\n          return result\n        }\n\n        return boundFunction\n      }\n\n      return target[prop]\n    }\n\n    handler.set = (target, prop, value, receiver) => {\n      if (\n        typeof prop === 'symbol'\n        && (\n          prop === symArrayAccess\n          || prop === symObjectAccess\n          || prop === symStateId\n        )\n      ) {\n        target[prop] = value\n      }\n      // Array's length is set every time after\n      // adding or removing elements\n      else if (target instanceof Array && prop === 'length') {\n        target[prop] = value\n\n        // this.#onArrayLengthChange(receiver)\n      }\n      else if (Object.hasOwn(target, prop)) {\n        target[prop] = value\n\n        this.#onPropUpdate(target, receiver, prop, value)\n      }\n      else {\n        target[prop] = value\n\n        this.#onPropCreate(target, receiver, prop)\n      }\n\n      return true\n    }\n\n    /**\n     * Trap for the delete operator. This trap can intercept these operations:\n     *  - delete proxy[foo] and delete proxy.foo\n     *  - Reflect.deleteProperty()\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty\n     * @param {StateProxy} target\n     * @param {string | symbol} prop\n     * @returns {boolean}\n     * A Boolean indicating whether the property has been successfully deleted.\n     */\n    handler.deleteProperty = (target, prop) => {\n      delete target[prop]\n\n      this.#onPropDelete(target, target, prop)\n\n      return true\n    }\n\n    return handler\n  }\n}\n\nexport { StateSubscriptions, setSuggestItems, unsetSuggestedItems }\n","import { StateSubscriptions } from './StateSubscriptions.js'\nimport { symStateId } from './constants.js'\n\nlet stateIdCounter = 0\n\n/**\n * @template T\n * @param {T} object\n * Your input object or array\n * @returns {T}\n * A proxy object/array that looks the same as the input object/array\n */\nconst state = function state(object) {\n  if (!(object instanceof Object)) {\n    throw new Error('state() only accepts Object, Array, Set or Map as input value.')\n  }\n\n  const stateSubscriptions = new StateSubscriptions()\n  const proxy = stateSubscriptions.createProxy(object)\n\n  stateIdCounter += 1\n  // @ts-ignore\n  proxy[symStateId] = stateIdCounter\n\n  return proxy\n}\n\n/**\n * @param {Object<*,*>} object\n * @returns {boolean}\n */\nconst isState = function (object) {\n  return (object instanceof Object) && (symStateId in object)\n}\n\nexport { state, isState }\n","import { isState } from './state.js'\nimport { symArrayAccess, symObjectAccess } from './constants.js'\n\n/**\n * @see https://github.com/purposeindustries/window-or-global/blob/master/lib/index.js\n * @returns {Window | any}\n */\nexport function getGlobalObject() {\n  return (typeof self === 'object' && self.self === self && self)\n    || (typeof global === 'object' && global.global === global && global)\n    // @ts-ignore\n    || this\n}\n\n/**\n * @see https://github.com/tmpfs/format-util/blob/master/format.js\n * @param {string} fmt\n * @param {...any[]} args\n * @returns {string}\n */\nexport function format(fmt, ...args) {\n  const re = /(%?)(%([ojdsif]))/g\n\n  if (args.length > 0) {\n    /**\n     * @param {string} match\n     * @param {string} escaped % (for %%) or null (for anything else)\n     * @param {string} ptn %o or %s or whatever\n     * @param {string} flag The s from %s\n     * @returns {string}\n     */\n    const replacer = (match, escaped, ptn, flag) => {\n      let arg = args.shift()\n      let out = ''\n\n      switch (flag) {\n        case 'o':\n          if (Array.isArray(arg)) {\n            out = JSON.stringify(arg)\n          }\n          break\n        case 's':\n          out = '' + arg\n          break\n        case 'd':\n          out = '' + Number(arg)\n          break\n        case 'j':\n          out = JSON.stringify(arg)\n          break\n        case 'i':\n          out = '' + parseInt('' + arg, 10)\n          break\n        case 'f':\n          out = '' + parseFloat('' + arg)\n          break\n      }\n\n      if (!escaped) {\n        return out\n      }\n\n      // @ts-ignore\n      args.unshift(out)\n\n      return match\n    }\n\n    fmt = fmt.replace(re, replacer)\n  }\n\n  // arguments, remained after the formatting\n  if (args.length > 0) {\n    fmt += ' ' + args.join(' ')\n  }\n\n  // update escaped %% values\n  fmt = fmt.replace(/%{2,2}/g, '%')\n\n  return '' + fmt\n}\n\n/**\n * @see https://stackoverflow.com/questions/17575790/environment-detection-node-js-or-browser\n * @returns {boolean}\n */\nexport function isBrowserEnvironment() {\n  if (isBrowserEnvironment.isIt === undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-implied-eval\n    const isBrowser = new Function('try {return this===window;}catch(e){ return false;}')\n\n    isBrowserEnvironment.isIt = isBrowser()\n  }\n\n  return isBrowserEnvironment.isIt ?? false\n}\n\n/**\n * The environment doesn't change over time, so it's enough\n * to determine it once. This variable is used to store the\n * environment, it's a cache.\n *\n * @type {undefined | boolean}\n */\nisBrowserEnvironment.isIt = undefined\n\n/**\n * @template T\n * @param {T} inputChild\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildToStack(inputChild, childrenStack) {\n  childrenStack.push(inputChild)\n\n  return childrenStack\n}\n\n/**\n * @template T\n * @param {T[]} inputChildren\n * @param {T[]} childrenStack\n * @returns {T[]}\n */\nexport function addChildrenToStack(inputChildren, childrenStack) {\n  for (const child of inputChildren) {\n    childrenStack.push(child)\n  }\n\n  return childrenStack\n}\n\n/**\n * @param {string} attributeName\n * @returns {boolean}\n */\nexport function isEventAttribute(attributeName) {\n  const eventNameLowerCase = attributeName.toLowerCase()\n\n  return eventNameLowerCase.indexOf('on') === 0\n}\n\n/**\n * @param {string} char\n * @returns {boolean}\n */\nexport function isWhitespace(char) {\n  return (\n    char === ' '\n    || char === '\\t'\n    || char === '\\r'\n    || char === '\\n'\n  )\n}\n\n/**\n * @param {string} name\n * @returns {boolean}\n */\nexport function isValidCustomElementName(name) {\n  return /^[a-z][a-z0-9-]+$/.test(name) && name.includes('-')\n}\n\n/**\n * @param {string} selector\n * @returns {boolean}\n */\nexport function selectorEndsWithId(selector) {\n  return /#[a-z0-9-]+\\s*$/.test(selector)\n}\n\n/**\n * Turns a string into boolean.\n * Covers the cases when the string is 'true', 'false' or a number.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexport function stringToBoolean(string) {\n  if (string === 'true') return true\n\n  if (string === 'false') return false\n\n  const int = parseInt(string)\n\n  return (isNaN(int)) ? Boolean(string) : Boolean(int)\n}\n\n/**\n * @param {Element | Text} element\n * @param {string} attributeName\n * @param {EventListenerOrEventListenerObject} callback\n * @returns {boolean}\n */\nexport function addEventListenerIfPossible(element, attributeName, callback) {\n  if (\n    !(element instanceof window.Node)\n\t\t|| (typeof attributeName !== 'string')\n\t\t|| (typeof callback !== 'function')\n    || (isEventAttribute(attributeName) === false)\n  ) return false\n\n  const eventSmallName = attributeName.toLowerCase().substring(2)\n\n  element.addEventListener(eventSmallName, callback)\n\n  return true\n}\n\n/**\n * For multiple elements it's faster to use document fragment\n *\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendDOMChildrenToElement(element, children) {\n  if (children.length === 1) {\n    // It's faster to append single element like this\n    element.appendChild(children[0])\n  }\n  else if (children.length > 1) {\n    // Using document fragment, because it's faster for multiple elements\n    const fragment = new DocumentFragment()\n\n    for (const child of children) {\n      if (child) {\n        fragment.append(child)\n      }\n    }\n\n    element.appendChild(fragment)\n  }\n}\n\n/**\n * @param {Node} element\n * @param {Node[]} children\n */\nfunction appendVirtualChildrenToElement(element, children) {\n  for (const child of children) {\n    if (child) {\n      element.appendChild(child)\n    }\n  }\n}\n\n/**\n * @param {Node | null} element\n * The element in which to append the children\n * @param {Node[]} children\n * The children to append, one or many arguments.\n * For example `<node1, node2>` or `<[node1, node2], node3>`\n */\nexport function appendChildrenToElement(element, children) {\n  if (!element) return\n\n  if (isBrowserEnvironment() && element instanceof window.Node) {\n    appendDOMChildrenToElement(element, children)\n  }\n  else {\n    appendVirtualChildrenToElement(element, children)\n  }\n}\n\n/**\n * In the \"data\" object there are pairs of keys and values\n * and the \"handler\" function is looped once for each pair.\n * The loop breaks if \"false\" is returned by the \"handler\"\n * function.\n *\n * @template T\n * @param {1 | 2} forLoopType\n * @param {Array<T> | Object<string | number, T> | Map<string | number, T>} data\n * @param {ForLoopCallback<T>} handler\n * @param {(key: number | string) => void} [beforeIterationCallback]\n * @param {string | number | symbol} [keyToRender]\n * @param {(key: number | string) => void} [iterationCallback]\n * @returns {boolean}\n * @throws {TypeError}\n */\nexport function forEachLoop(\n  forLoopType,\n  data,\n  handler,\n  beforeIterationCallback,\n  keyToRender,\n  iterationCallback,\n) {\n  if (!(handler instanceof Function)) {\n    throw new TypeError('\"handler\" argument should be a Function')\n  }\n\n  const isProxy = forLoopType === 2 && isState(data)\n\n  if (\n    data instanceof Map\n    || data instanceof Set\n  ) {\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const [key, value] of data.entries()) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let val = isProxy ? () => value : value\n\n      if (beforeIterationCallback) {\n        val = beforeIterationCallback?.(val)\n      }\n\n      const ret = handler(val, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Array) {\n    /**\n     * for-in doesn't work properly in this case,\n     * because the numeric index turns into string.\n     * That's why use the classic for loop is used.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    // @ts-ignore\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const nothing = isProxy ? data[symArrayAccess] : undefined\n\n    for (let key = 0, length = data.length; key < length; key++) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else if (data instanceof Object) {\n    /**\n     * The Object loop must be at the end,\n     * because Array, Set and Map are also Object.\n     */\n\n    // Force the proxy's \"get\" event by trying to access this dummy symbol key\n    const nothing = isProxy ? data[symObjectAccess] : undefined\n\n    for (const key in data) {\n      if (keyToRender !== undefined && keyToRender !== key) {\n        continue\n      }\n\n      let value = isProxy ? () => data[key] : data[key]\n\n      if (beforeIterationCallback) {\n        value = beforeIterationCallback?.(value)\n      }\n\n      const ret = handler(value, key)\n\n      iterationCallback?.(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    throw new TypeError('\"data\" argument should be an Object or an Array')\n  }\n\n  return true\n}\n\n/**\n * \"start\" and \"end\" determine the direction and how many loops are applied on the \"handler\"\n * function. The loop breaks if \"false\" is returned by the \"handler\" function\n *\n * @param {number} start\n * @param {number} end\n * @param {ForLoopIterableCallback} handler\n * @returns {boolean | Error}\n */\nexport function forLoop(start, end, handler) {\n  if (typeof start !== 'number' || typeof end !== 'number') {\n    return new Error('\"start\" and \"end\" arguments should be numbers')\n  }\n\n  if (!(handler instanceof Function)) {\n    return new Error('\"handler\" argument should be a Function')\n  }\n\n  if (end >= start) {\n    for (let key = start; key <= end; key++) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n  else {\n    for (let key = start; key >= end; key--) {\n      const ret = handler(key)\n\n      if (ret === false) break\n    }\n  }\n\n  return true\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} key\n * @returns {T[]}\n */\nexport function arrayRemoveKey(arr, key) {\n  return arr.filter(function (el, index) {\n    return index !== key\n  })\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {T} value\n * @returns {T[]}\n */\nexport function arrayRemoveValue(arr, value) {\n  return arr.filter(function (el) {\n    return el !== value\n  })\n}\n\n/**\n * Insert a new node after an existing node as a child node of a parent node\n *\n * @see https://www.javascripttutorial.net/javascript-dom/javascript-insertafter/\n * @param {Node} newNode\n * @param {Node} existingNode\n */\nexport function insertAfter(newNode, existingNode) {\n  if (!existingNode) return\n\n  const { nextSibling, parentNode } = existingNode\n\n  if (parentNode) {\n    parentNode.insertBefore(newNode, nextSibling)\n  }\n}\n\n/**\n *\n * @param {HTMLElement} element\n * @param {Object<string, (string | number | boolean)>}dataSet\n */\nexport function setDataSetAttributesToElement(element, dataSet) {\n  if (dataSet instanceof Object) {\n    for (const key in dataSet) {\n      const value = dataSet[key].toString()\n\n      element.setAttribute(`data-${key}`, value)\n    }\n  }\n}\n\n/**\n * Html elements have attributes and properties.\n * Here we set either the attribute ot the property.\n * Which one? Depends on the name of the attribute or property.\n *\n * @param {Element | Text} element\n * @param {string} attrOrPropName\n * @param {*} value\n */\nexport function setElementAttrOrProp(element, attrOrPropName, value) {\n  // Decide between element attributes or element properties\n  if (attrOrPropName in element) {\n    if (value instanceof Array) {\n      // @ts-ignore\n      element[attrOrPropName] = format.apply(null, value)\n    }\n    else {\n      // @ts-ignore\n      element[attrOrPropName] = value\n    }\n  }\n  else {\n    if ('setAttribute' in element) {\n      element.setAttribute(attrOrPropName, value)\n    }\n  }\n}\n\n/**\n * Modify the value of a CSS rule, if needed\n *\n * @param {string} name\n * @param {*} value\n * @returns {*}\n */\nexport function modifyStyleRule(name, value) {\n  let output = value\n\n  if (\n    (name === 'visibility' || name === 'backfaceVisibility')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 'visible' : 'hidden'\n\n  if (\n    (name === 'display')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? '' : 'none'\n\n  if (\n    (name === 'flex')\n    && (value === true || value === false || value === undefined || value === null)\n  ) output = (value) ? 1 : 0\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {HTMLElement}\n */\nexport function stringToHTML(str) {\n  const parser = new DOMParser()\n  const doc    = parser.parseFromString(str, 'text/html')\n\n  return doc.body\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {boolean}\n */\nexport function objectHasKey(object, key) {\n  if (object instanceof Map || object instanceof Set) {\n    return object.has(key)\n  }\n  else {\n    return (key in object)\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @param {any} key\n * @returns {any}\n */\nexport function objectGetValue(object, key) {\n  if (object instanceof Map) {\n    return object.get(key)\n  }\n  else if (object instanceof Set) {\n    return object.has(key) ? key : undefined\n  }\n  else {\n    return object[key]\n  }\n}\n\n/**\n * @param {Map<any, any> | Set<any> | Object<any, any>} object\n * @returns {number}\n */\nexport function objectLength(object) {\n  if (object instanceof Array) {\n    return object.length\n  }\n  else if (object instanceof Map || object instanceof Set) {\n    return object.size\n  }\n  else if (object instanceof Object) {\n    return object.keys().length\n  }\n\n  return 0\n}\n\n/**\n * @see https://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another\n * @template T\n * @param {T[]} array\n * @param {number} oldIndex\n * @param {number} newIndex\n * @returns {T[]}\n */\nexport function arrayMoveIndex(array, oldIndex, newIndex) {\n  if (newIndex >= array.length) {\n    let k = newIndex - array.length + 1\n\n    while (k--) {\n      // @ts-ignore\n      array.push(undefined)\n    }\n  }\n\n  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0])\n\n  return array\n}\n","import { arrayMoveIndex } from './functions.js'\n\n/**\n * This class has an array where HTML elements are stored.\n * The class methods provide an interface for managing this array.\n */\nclass ElementsCollector {\n  /** @type {Node[]} */\n  elements = []\n\n  /**\n   * Add one element to the array of collected elements\n   *\n   * @param {Node} element\n   */\n  addElement(element) {\n    if (element) this.elements.push(element)\n  }\n\n  /**\n   * Add multiple elements to the array of collected elements\n   *\n   * @param {Node[]} elements\n   */\n  addElements(elements) {\n    for (let element of elements) {\n      this.elements.push(element)\n    }\n  }\n\n  /**\n   * Returns the array of collected elements\n   *\n   * @returns {Node[]}\n   */\n  getElements() {\n    return this.elements\n  }\n\n  /**\n   * @param {Node} element\n   * @returns {boolean}\n   */\n  hasElement(element) {\n    return this.elements.indexOf(element) > -1\n  }\n\n  /**\n   * Import the elements from another ElementsCollector into this one\n   *\n   * @param {ElementsCollector} elementsCollector\n   */\n  importElements(elementsCollector) {\n    const elements = elementsCollector.getElements()\n\n    for (const element of elements) {\n      this.addElement(element)\n    }\n  }\n\n  /**\n   * @param {Node} elementToMove\n   * @param {Node} referenceElement\n   */\n  moveElementAfterAnother(elementToMove, referenceElement) {\n    const indexOfElementToMove    = this.elements.indexOf(elementToMove)\n    const indexOfReferenceElement = this.elements.indexOf(referenceElement)\n\n    if (indexOfElementToMove === -1 || indexOfReferenceElement === -1) {\n      throw new Error('Cannot move one element after another, because one element is missing')\n    }\n\n    if (indexOfReferenceElement - indexOfElementToMove === 1) {\n      // no need to move\n      return\n    }\n\n    this.elements = arrayMoveIndex(\n      this.elements,\n      indexOfElementToMove,\n      indexOfReferenceElement + 1,\n    )\n  }\n\n  /**\n   * Clears the array of collected elements\n   */\n  removeAllElements() {\n    this.elements.length = 0\n  }\n\n  /**\n   * From the list of collected elements remove any element present in the input array\n   *\n   * @param {Node[]} elements\n   */\n  removeTheseElements(elements) {\n    let indexInput = elements.length\n\n    while (indexInput--) {\n      let indexOutput = this.elements.length\n\n      while (indexOutput--) {\n        if (elements[indexInput] === this.elements[indexOutput]) {\n          this.elements.splice(indexOutput, 1)\n\n          continue // remove only the first occurrence\n        }\n      }\n    }\n\n    // if (elements.length > 0) {\n    //   this.elements = this.elements.filter(\n    //     (element) => !(elements.includes(element)),\n    //   )\n    // }\n  }\n}\n\nexport { ElementsCollector }\n","/**\n * For each of the following tags a method will be created in the class below\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n * @see https://www.w3schools.com/tags/\n * @type {string[]}\n */\nconst htmlTags = [\n  'a', 'abbr', 'address', 'area', 'article', 'aside', 'audio',\n  'b', 'base', 'bdi', 'bdo', 'blockquote', 'body', 'br', 'button',\n  'canvas', 'caption', 'cite', 'code', 'col', 'colgroup',\n  'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt',\n  'em', 'embed',\n  'fieldset', 'figcaption', 'figure', 'footer', 'form',\n  'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', // 'html',\n  'i', 'iframe', 'img', 'input', 'ins',\n  'kbd',\n  'label', 'legend', 'li', 'link',\n  'main', 'map', 'mark', 'meta', 'meter',\n  'nav', 'noscript',\n  'object', 'ol', 'optgroup', 'option', 'output',\n  'p', 'picture', 'pre', 'progress',\n  'q',\n  'rp', 'rt', 'ruby',\n  's', 'samp', 'script', 'section', 'select', 'slot', 'small', 'source',\n  'span', 'strong', 'style', 'sub', 'summary', 'sup', 'svg',\n  'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th',\n  'thead', 'time', 'title', 'tr', 'track',\n  'u', 'ul',\n  'var', 'video',\n  'wbr',\n]\n\nexport { htmlTags }\n","class HtmlTemplateParserElement {\n  tagName = '-'\n\n  /** @type {HtmlTemplateParserElement} */\n  parent = this\n\n  /** @type {HtmlTemplateParserElement[]} */\n  children = []\n\n  /** @type {Object<string, any>} */\n  attributes = {}\n\n  /**\n   * Create a new instance of this class, but also put it\n   * into the list of children of the current instance\n   *\n   * @param {HtmlTemplateParserElement} parent\n   * @param {Object<string, any>} attributes\n   * @returns {HtmlTemplateParserElement}\n   */\n  newChild(parent, attributes) {\n    const child = new HtmlTemplateParserElement()\n\n    child.parent = parent\n    child.attributes = attributes\n\n    this.children.push(child)\n\n    return child\n  }\n}\n\nexport { HtmlTemplateParserElement }\n","/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n","import { isWhitespace, stringToBoolean } from '../functions.js'\nimport { HtmlTemplateParserElement } from './HtmlTemplateParserElement.js'\nimport { SELF_CLOSING_TAGS } from './constants.js'\n\n/**\n * This class is used to turn JS template literals (containing HTML code) into\n * properly ordered Template Tree.\n */\nclass HtmlTemplateParser {\n  #attrName = ''\n\n  /**\n   * The quote symbol in <...attr=\"value\"> - a single or a double quote.\n   * When the attribute has no quote, for example <...attr=123...>,\n   * the quote would be an empty space.\n   *\n   * @type {\"'\" | \"\\\"\" | \" \" | ''}\n   */\n  #attrQuote = ''\n\n  /** @type {any} */\n  #attrValue = ''\n\n  /** @type {Object<string, any>} */\n  #attributes = {}\n\n  /**\n   * Usually a string, but it could be function, boolean, number...\n   *\n   * @type {any}\n   */\n  #char\n\n  /** @type {any} */\n  #charPrevious\n\n  /** @type {any[]} */\n  #data = []\n\n  /**\n   * Would be set to the method that is going to be used for the next char iteration\n   *\n   * @type {() => void}\n   */\n  #stage = this.#stageNothing\n\n  #styleAttrName = ''\n\n  /** @type {any} */\n  #styleAttrValue = ''\n\n  /** @type {Object<string, any>} */\n  #styles = {}\n\n  #tagName = ''\n\n  #tagNameClosing = ''\n\n  #textContents = ''\n\n  /** @type {HtmlTemplateParserElement} */\n  #topElement = new HtmlTemplateParserElement()\n\n  /** @type {HtmlTemplateParserElement} */\n  #currentElement = this.#topElement\n\n  /**\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   */\n  constructor(strings, keys) {\n    this.#data = this.#mergeStringsAndKeys(strings, keys)\n\n    this.#rotate()\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @returns {(HTMLElement | Text)[]}\n   */\n  generate(elementsCreator) {\n    if (this.#tagName || this.#tagNameClosing) {\n      throw new Error('Some HTML tag is not closed')\n    }\n\n    const elements = this.#generateChildren(elementsCreator, this.#topElement)\n\n    return elements\n  }\n\n  /**\n   * @param {any} to\n   * @param {any} data\n   * @returns {any}\n   */\n  #appendData(to, data) {\n    if (typeof to === 'function') {\n      // The input is a function. In this case:\n      // If the data to append is also a function, return that function\n      // If the data to append is not a function, return the input\n      return (typeof data === 'function')\n        ? data\n        : to\n    }\n\n    return (\n      typeof to === 'string'\n      && (\n        typeof data === 'string'\n        || typeof data === 'number'\n        || typeof data === 'boolean'\n      )\n    )\n      ? to + data.toString()\n      : data\n  }\n\n  /**\n   * @param {import('../ElementsCreator.js').ElementsCreator} elementsCreator\n   * @param {HtmlTemplateParserElement} element\n   * @returns {(HTMLElement | Text)[]}\n   */\n  #generateChildren(elementsCreator, element) {\n    /** @type {(HTMLElement | Text)[]} */\n    const output = []\n\n    for (const child of element.children) {\n      let el = null\n\n      if (child.tagName === 'if') {\n        el = elementsCreator.if(\n          stringToBoolean(child.attributes?.condition ?? ''),\n          () => this.#generateChildren(elementsCreator, child),\n        )\n      }\n      else if (child.tagName === 'for') {\n        if ('iterations' in child.attributes) {\n          el = elementsCreator.for(\n            0,\n            parseInt(child.attributes?.iterations ?? 0) - 1,\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n        else if ('from' in child.attributes || 'to' in child.attributes) {\n          el = elementsCreator.for(\n            parseInt(child.attributes?.from ?? 0),\n            parseInt(child.attributes?.to ?? 0),\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else if (child.tagName === 'forEach') {\n        if ('object' in child.attributes) {\n          el = elementsCreator.forEach(\n            child.attributes?.object ?? {},\n            // @ts-ignore\n            (value, key) => {\n              this.#generateChildren(elementsCreator, child)\n            },\n          )\n        }\n      }\n      else {\n        el = elementsCreator.createElement(\n          child.tagName,\n          child.attributes,\n          this.#generateChildren(elementsCreator, child),\n        )\n\n        output.push(el)\n      }\n    }\n\n    return output\n  }\n\n  #makeNewElement() {\n    const parent = this.#currentElement\n    const attributes = this.#attributes\n\n    if (Object.keys(this.#styles).length > 0) {\n      attributes.style = this.#styles\n    }\n\n    const child = this.#currentElement.newChild(parent, attributes)\n\n    child.tagName = this.#tagName\n\n    this.#currentElement = child\n  }\n\n  /**\n   * JS Templates provide two arrays - a string array and keys array.\n   * This function is designed to merge these two into a single array.\n   *\n   * @param {string[]} strings\n   * @param {any[]} [keys=[]]\n   * @returns {any[]}\n   */\n  #mergeStringsAndKeys(strings, keys=[]) {\n    const output = []\n\n    for (let index = 0; index < strings.length; index++) {\n      if (strings[index]) {\n        output.push(strings[index])\n      }\n\n      if (keys[index] !== undefined) {\n        output.push(keys[index])\n      }\n    }\n\n    return output\n  }\n\n  #rotate() {\n    for (\n      let dataIndex = 0;\n      dataIndex < this.#data.length;\n      dataIndex++\n    ) {\n      if (typeof this.#data[dataIndex] === 'string') {\n        for (\n          let charIndex = 0;\n          charIndex < this.#data[dataIndex].length;\n          charIndex++\n        ) {\n          this.#char         = this.#data[dataIndex][charIndex]\n          this.#charPrevious = this.#data[dataIndex][charIndex - 1]\n\n          // this.#char, this.#stage.name)\n\n          this.#stage()\n        }\n      }\n      else {\n        this.#char = this.#data[dataIndex]\n        this.#charPrevious = undefined\n\n        // console.log(this.#char, this.#stage.name)\n\n        this.#stage()\n      }\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setAttribute(name, value) {\n    if (!name) return\n\n    this.#attributes[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  /**\n   * @param {() => void} stage\n   */\n  #setStage(stage) {\n    // Actions to do before a given stage is set\n    if (stage === this.#stageAttrName) {\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n    }\n\n    // Set the stage\n    this.#stage = stage\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} value\n   */\n  #setStyle(name, value) {\n    if (!name) return\n\n    this.#styles[name] = (typeof value === 'string') ? value.trim() : value\n  }\n\n  #stageAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '/') {\n      if (SELF_CLOSING_TAGS.includes(this.#tagName)) {\n        this.#makeNewElement()\n      }\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === '=') {\n      this.#setStage(this.#stageAttrOpenQuote)\n    }\n    else {\n      this.#attrName += this.#char\n    }\n  }\n\n  #stageAttrOpenQuote() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '\\'' || this.#char === '\"') {\n      this.#attrQuote = this.#char\n\n      this.#setStage(\n        (this.#attrName === 'style')\n          ? this.#stageStyleAttrName\n          : this.#stageAttrValue,\n      )\n    }\n    else {\n      // Value without quotes.\n      // Whitespaces are allowed before the value, but not after.\n      // For that reason, the quote would be a whitespace here\n\n      this.#attrQuote = ' '\n      this.#attrValue = this.#appendData(this.#attrValue, this.#char)\n\n      this.#setStage(this.#stageAttrValue)\n    }\n  }\n\n  #stageAttrValue() {\n    if (this.#char === '>' && this.#charPrevious !== '/') {\n      // When > is found, but the attribute wasn't closed properly.\n      // Could happen if the quote is an empty space, for example: <...attr=true>\n      // Or even unclosed quote, for example: <...attr=\"value>\n      if (this.#attrQuote && this.#attrName && this.#attrValue) {\n        this.#setAttribute(this.#attrName, this.#attrValue)\n      }\n\n      this.#attrName = ''\n      this.#attrValue = ''\n      this.#attrQuote = ''\n\n      this.#setStage(this.#stageNothing)\n\n      this.#makeNewElement()\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setAttribute(this.#attrName, this.#attrValue)\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#attrValue += this.#char\n    }\n  }\n\n  #stageNothing() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '<') {\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      // In HTML when there are multiple spaces before or after a text,\n      // only one could be visualized. So if\n      if (this.#charPrevious === ' ') {\n        this.#textContents = this.#charPrevious + this.#char\n      }\n      else {\n        this.#textContents = this.#char\n      }\n\n      this.#tagName = ''\n      this.#attributes = {}\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTextContents)\n    }\n  }\n\n  #stageStyleAttrName() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (\n      this.#char === this.#attrQuote // <...id=\"value\"...>\n      || (this.#attrQuote === ' ' && isWhitespace(this.#char)) // <...id=value ...>\n    ) {\n      this.#setStage(this.#stageAttrName)\n    }\n    else if (this.#char === ':') {\n      this.#setStage(this.#stageStyleAttrValue)\n    }\n    else {\n      this.#styleAttrName += this.#char\n    }\n  }\n\n  #stageStyleAttrValue() {\n    if (this.#char === '>') {\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#char === ';') {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageStyleAttrName)\n    }\n    else if (this.#char === this.#attrQuote) {\n      this.#setStyle(this.#styleAttrName, this.#styleAttrValue)\n\n      this.#styleAttrName = ''\n      this.#styleAttrValue = ''\n\n      this.#setStage(this.#stageAttrName)\n    }\n    else {\n      this.#styleAttrValue = this.#appendData(this.#styleAttrValue, this.#char)\n    }\n  }\n\n  /**\n   * In this stage we have just detected \"<\" and we are in HTML tag.\n   * This tag could be a new tag, or it could be the closing tag.\n   *\n   * @returns {void}\n   */\n  #stageTag() {\n    if (isWhitespace(this.#char)) {\n      if (this.#tagName !== '') {\n        this.#setStage(this.#stageAttrName)\n      }\n    }\n    else if (this.#char === '/' && SELF_CLOSING_TAGS.includes(this.#tagName)) {\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else if (this.#char === '>') {\n      if (!this.#tagName) {\n        throw new Error('Expected tag name, found >')\n      }\n\n      // If there was a text node just before the tag, it would be the current element\n      // But the text node is at the same leve. So, change the current element to the parent\n      if (!this.#currentElement.tagName) {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#makeNewElement()\n\n      this.#setStage(this.#stageNothing)\n    }\n    else if (this.#charPrevious === '<' && this.#char === '/') {\n      if (!this.#tagName) {\n        //throw new Error('no tag name')\n      }\n\n      this.#tagNameClosing = ''\n\n      this.#setStage(this.#stageTagToClose)\n    }\n    else {\n      this.#tagName += this.#char\n    }\n  }\n\n  #stageTagToClose() {\n    if (isWhitespace(this.#char)) {\n      // just skip\n    }\n    else if (this.#char === '>') {\n      if (\n        this.#currentElement.tagName // Empty if text node\n        && this.#currentElement.tagName !== '-'\n        && !SELF_CLOSING_TAGS.includes(this.#currentElement.tagName)\n        && this.#currentElement.tagName !== this.#tagNameClosing\n      ) {\n        throw new Error(`Expected ${this.#currentElement.tagName} tag to be closed, but ${this.#tagNameClosing} found`)\n      }\n\n      this.#tagName = ''\n      this.#tagNameClosing = ''\n\n      if (\n        !this.#currentElement.tagName // Text node\n      ) {\n        this.#currentElement = this.#currentElement.parent.parent\n      }\n      else {\n        this.#currentElement = this.#currentElement.parent\n      }\n\n      this.#setStage(this.#stageNothing)\n    }\n    else {\n      this.#tagNameClosing += this.#char\n    }\n  }\n\n  #stageTextContents() {\n    if (this.#char === '<') {\n      // Reset what was possibly used for text node\n      this.#attributes = {}\n      this.#currentElement.attributes.textContent = this.#textContents\n\n      this.#setStage(this.#stageTag)\n    }\n    else {\n      this.#textContents = this.#appendData(this.#textContents, this.#char)\n\n      if (!this.#currentElement.tagName) {\n        this.#currentElement.attributes.textContent = this.#textContents\n      }\n    }\n  }\n}\n\nexport { HtmlTemplateParser }\n","import { Component } from './Component.js'\nimport { ElementsCollector } from './ElementsCollector.js'\nimport {\n  addChildrenToStack,\n  addChildToStack,\n  addEventListenerIfPossible,\n  appendChildrenToElement,\n  arrayRemoveKey,\n  forEachLoop,\n  forLoop,\n  format,\n  getGlobalObject,\n  insertAfter,\n  isEventAttribute,\n  modifyStyleRule,\n  objectHasKey,\n  setDataSetAttributesToElement,\n  setElementAttrOrProp,\n  stringToHTML,\n} from './functions.js'\nimport { htmlTags } from './htmlTags.js'\nimport { HtmlTemplateParser } from './HtmlTemplateParser/HtmlTemplateParser.js'\nimport { isState } from './state.js'\nimport { setSuggestItems, unsetSuggestedItems } from './StateSubscriptions.js'\nimport { EnumStateAction, symTemplateFunction } from './constants.js'\n\n/**\n * @typedef {Array<{key: (string | number | symbol), elements: (Node)[]}>} RenderedElementsMap\n */\n\nclass ElementsCreator {\n  /**\n   * Each element of this array represents a Level of HTML elements.\n   * Level 0 is the main level where eventually all elements are placed.\n   * A new level is created from IF and FOR in order to collect the\n   * elements separately. Then, when the IF or FOR statement ends, the\n   * collected elements are moved to the upper level and that new level\n   * is deleted.\n   *\n   * @type {ElementsCollector[]}\n   */\n  #collectedElements = [new ElementsCollector()]\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {Element | ShadowRoot | null}\n   */\n  #containerElement\n\n  /** @type {Document} */\n  #document\n\n  /**\n   * Is String-Rendering mode\n   *\n   * @type {boolean}\n   */\n  #isSr = true\n\n  /**\n   * Used only for Browser rendering.\n   * This element is used by html(), in its simple mode.\n   *\n   * @type {HTMLTemplateElement | null}\n   */\n  #reusableTemplateElement = null\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /** @type {Window} */\n  #window\n\n  /**\n   * @param {Window} window\n   * @param {HTMLElement | Element | ShadowRoot | null} containerElement\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} [translations=[]]\n   */\n  constructor(window, containerElement, templates, translations = []) {\n    this.#window = window\n    this.#document = window.document\n    this.#isSr = this.#document.baseURI === ''\n    this.#containerElement = containerElement\n    this.#templates = templates\n    this.#translations = translations\n\n    // htmlTags.forEach((tagName) => {\n    //   // @ts-ignore\n    //   this[tagName] = this[tagName].bind(this)\n    // })\n  }\n\n  /**\n   * Create a DOM element (or multiple elements) and put it into the elements collector\n   *\n   * @param {string} tagName\n   * @param {*} args\n   * @returns {HTMLElement | Text}\n   */\n  createElement(tagName, ...args) {\n    const element = (tagName)\n      ? this.#document.createElement(tagName)\n      : this.#document.createTextNode('')\n\n    /** @type {any[]} */\n    let children = []\n    let argumentID = 0\n\n    for (const argument of args) {\n      argumentID += 1\n\n      if (typeof argument === 'string') {\n        // In case of a string, create a new text node.\n        // This way, multiple text nodes can be put into the element,\n        // mixed with http elements.\n\n        const textNode = this.#document.createTextNode(\n          this.#translate(argument),\n        )\n\n        children = addChildToStack(textNode, children)\n      }\n      else if (typeof argument === 'number') {\n        // The number is converted into a string\n\n        const textNode = this.#document.createTextNode(\n          argument.toString(),\n        )\n\n        children = addChildToStack(textNode, children)\n      }\n      // @ts-ignore\n      else if (argument instanceof this.#window.Node) {\n        // This is a child, created by this function, to be appended to its parent\n        children = addChildToStack(argument, children)\n      }\n      else if (argument instanceof Array) {\n        if (argument.length === 0) {\n          continue\n        }\n\n        let isChildrenArray = false\n\n        for (const child of argument) {\n          if (\n            // @ts-ignore\n            child instanceof this.#window.Node // Node includes HTMLElement and Comment\n          ) {\n            isChildrenArray = true\n\n            break\n          }\n        }\n\n        // Case 1) Array, containing at least one child to be added to their parent\n        // In DOM, if some elements are not children, they are turned into strings,\n        // but the same produces error in SSR\n        if (isChildrenArray) {\n          children = addChildrenToStack(argument, children)\n        }\n        // Case 2) Array, containing string to be formatted\n        else {\n          const textNode = this.#document.createTextNode(\n            this.#arrayTranslateFormatTranslate(argument),\n          )\n\n          children = addChildToStack(textNode, children)\n        }\n      }\n      else if (argument instanceof Error) {\n        // Error message\n\n        element.textContent = this.#translate(argument.message)\n      }\n      else if (argument instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? argument.getElementsSr()\n          : argument.getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          for (const child of childrenGroup) {\n            children = addChildToStack(child, children)\n          }\n        }\n      }\n      else if (argument instanceof Function) {\n        // Is it a Template function?\n        if (argument[symTemplateFunction]) {\n          const { thisLevel, upperLevel } = this.#beforeStatement()\n\n          argument(this)\n\n          const generatedElements = this.#collectedElements[thisLevel].getElements()\n\n          children = addChildrenToStack(generatedElements, children)\n\n          this.#afterStatement({ thisLevel, upperLevel })\n        }\n        else {\n          if (this.#isSr) {\n            // @ts-ignore\n            element.innerHTML = `(${argument.toString()})()`\n          }\n          else {\n            if (element instanceof HTMLScriptElement) {\n              const inlineScript = this.#document.createTextNode(`(${argument.toString()})()`)\n              element.appendChild(inlineScript)\n            }\n            else {\n              if (\n                'value' in element\n                && !(element instanceof HTMLLIElement) // <li> has value, but it accepts only numbers\n              ) {\n                this.#setPropertiesToElement(element, { value: argument })\n              }\n              else {\n                this.#statementHandlerForFunction(\n                  'nest',\n                  argument,\n                  false,\n                  // eslint-disable-next-line @typescript-eslint/no-loop-func\n                  (\n                    value,\n                    isInitialRun,\n                    commentElementBegin, // Should be Comment element on the first run only\n                    commentElementEnd, // Should be Comment element on the first run only\n                  ) => {\n                    if (value instanceof Function || value instanceof Component) {\n                      if (value instanceof Component) {\n                        const generatedChildren = (this.#isSr)\n                          ? value.getElementsSr()\n                          : value.getElements()\n\n                        if (isInitialRun) {\n                          addChildToStack(commentElementBegin, children)\n                          children = addChildrenToStack(generatedChildren[0], children)\n                          addChildToStack(commentElementEnd, children)\n                        }\n                        else {\n                          this.#collectedElements[0].addElements(generatedChildren[0])\n                        }\n                      }\n                      else if (symTemplateFunction in value) {\n                        // @ts-ignore\n                        value(this)\n\n                        if (isInitialRun) {\n                          const level = this.#collectedElements.length - 1\n\n                          const generatedElements = this.#collectedElements[level].getElements()\n\n                          addChildToStack(commentElementBegin, children)\n                          addChildrenToStack(generatedElements, children)\n                          addChildToStack(commentElementEnd, children)\n                        }\n                        else {\n                          children.length = 0 // maybe not necessary\n                        }\n                      }\n                    }\n                    else {\n                      if (isInitialRun && commentElementBegin) {\n                        this.#unsubscribeElementAndItsChildren(commentElementBegin)\n                        this.#setPropertiesToElement(element, { textContent: argument })\n                      }\n                    }\n                  })\n              }\n            }\n          }\n        }\n      }\n      else if (\n        argument instanceof Object\n        && !(argument instanceof Function)\n        && argumentID === 1\n      ) {\n        // If Object, and the first argument, this is a property.\n        // This condition needs to be at the end of the 'if' chain.\n\n        this.#setPropertiesToElement(element, argument)\n      }\n    }\n\n    const level = this.#collectedElements.length - 1\n\n    /**\n     * Along with the known children, there might be unknown children,\n     * created from a function call such as templateCall($). These unknown\n     * children would be placed after the first known child.\n     *\n     * @example\n     * $.div($.span(), templateCall($))\n     *\n     * However, the scenario when the function call is the first argument is\n     * not covered:\n     * @example\n     * $.div(templateCall($), $.span())\n     */\n    if (children.length > 0) {\n      const collectedElements = this.#collectedElements[level].getElements()\n      const indexOfFirstKnownChild = collectedElements.indexOf(children[0])\n\n      if (indexOfFirstKnownChild > -1) {\n        if (children.length < collectedElements.length - indexOfFirstKnownChild) {\n          // Replace the children with all collected elements, starting from the first known child\n          children = collectedElements.slice(indexOfFirstKnownChild)\n        }\n      }\n    }\n\n    appendChildrenToElement(element, children)\n\n    this.#collectedElements[level].removeTheseElements(children)\n    this.#collectedElements[level].addElement(element)\n\n    return element\n  }\n\n  /**\n   * For loop with from-to numbers\n   *\n   * @param {number} from\n   * @param {number} to\n   * @param {ForLoopIterableCallback} handler\n   * @returns {Node[] | Error}\n   */\n  for(from, to, handler) {\n    const callback = () => {\n      const result = forLoop(from, to, handler)\n\n      if (result instanceof Error) console.error(result)\n    }\n\n    return this.#statementHandler('for', null, callback)\n  }\n\n  /**\n   * \"for\" loop for objects, arrays, maps and sets\n   *\n   * @template T\n   * @param {T | function() : T} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forEach(input, handler) {\n    return this.#forEachLoop(1, input, handler)\n  }\n\n  /**\n   * \"for\" loop for states\n   *\n   * @template T\n   * @param {State} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  forState(input, handler) {\n    return this.#forEachLoop(2, input, handler)\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  getCreatedElements() {\n    return this.#collectedElements[0].getElements()\n  }\n\n  /**\n   * - Browser mode: Returns an empty string\n   * - Server mode: Generate HTML code of the elements at level 0\n   *\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   * - Browser mode: Empty string\n   * - Server mode: The final HTML code\n   */\n  getHtmlCode(htmlOptions) {\n    let htmlCode = ''\n\n    if (this.#isSr) {\n      const containerElement = this.#containerElement\n\n      if (containerElement) {\n        // @ts-ignore\n        htmlCode = containerElement.paintChildren(htmlOptions)\n      }\n    }\n\n    return htmlCode\n  }\n\n  /**\n   * @param {string[] | string} strings\n   * A string when html is used as a function, or an array of strings when used as template\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  html(strings, ...keys) {\n    const elements = (\n      keys.length === 0\n      && this.#translations.length === 0 // the faster method doesn't translate anything\n    )\n      ? this.#htmlForSimpleString((strings instanceof Array) ? strings[0] : strings)\n      : this.#htmlForTemplateLiteral((strings instanceof Array) ? strings : [strings], ...keys)\n\n    for (const element of elements) {\n      if (\n        // Dummy tag (virtual mode) when simple string, or text node when template literal\n        // In both cases the tag name is an empty string\n        // @ts-ignore\n        element.tagName === ''\n      ) {\n        element.textContent = this.#translate(element.textContent)\n      }\n    }\n\n    return elements\n  }\n\n  /**\n   * \"IF\" condition\n   *\n   * @param {boolean | StatementBindFunction} condition\n   * @param {function():void} handler\n   * @param {function():void} [elseHandler]\n   * @returns {Node[]}\n   */\n  if(condition, handler, elseHandler) {\n    /**\n     * If the condition is a value (true or false), the elements\n     * are either created or not.\n     *\n     * If the condition is a function, two helper Comment elements\n     * are created - one in the beginning and another at the end.\n     * All normal elements are placed in between.\n     */\n\n    /**\n     * @param {any} data\n     */\n    const callback = (data) => {\n      if (Boolean(data)) {\n        if (handler instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            ? handler.getElementsSr()\n            : handler.getElements()\n\n          const level = this.#collectedElements.length - 1\n\n          this.#collectedElements[level].addElements(generatedChildren[0])\n        }\n        else if (handler instanceof Function) {\n          handler()\n        }\n      }\n      else {\n        if (elseHandler instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            ? elseHandler.getElementsSr()\n            : elseHandler.getElements()\n\n          const level = this.#collectedElements.length - 1\n\n          this.#collectedElements[level].addElements(generatedChildren[0])\n        }\n        else if (elseHandler instanceof Function) {\n          elseHandler()\n        }\n      }\n    }\n\n    return (condition instanceof Function)\n      ? this.#statementHandlerForFunction('if', condition, true, callback)\n      : this.#statementHandler('if', condition, callback)\n  }\n\n  async render() {\n    this.#collectedElements = [new ElementsCollector()] // Reset\n\n    for (const template of this.#templates) {\n      if (template instanceof Function) {\n        // @ts-ignore\n        let returnedValue = template(this)\n\n        if (returnedValue instanceof Promise) {\n          returnedValue = await returnedValue\n        }\n\n        if (returnedValue && typeof returnedValue === 'string') {\n          this.html(returnedValue)\n        }\n        else if (returnedValue instanceof Component) {\n          const generatedChildren = (this.#isSr)\n            // @ts-ignore\n            ? returnedValue.useTranslations(this.#translations).getElementsSr()\n            // @ts-ignore\n            : returnedValue.useTranslations(this.#translations).getElements()\n\n          for (const childrenGroup of generatedChildren) {\n            this.#collectedElements[0].addElements(childrenGroup)\n          }\n        }\n        else if (returnedValue instanceof Function) {\n          // @ts-ignore\n          returnedValue(this)\n        }\n        else if (returnedValue instanceof Array) {\n          let allComponents   = true\n          let allFunctions = true\n\n          for (const value of returnedValue) {\n            if (!(value instanceof Component)) {\n              allComponents = false\n\n              break\n            }\n\n            if (!(value instanceof Function)) {\n              allFunctions = false\n\n              break\n            }\n          }\n\n          if (allComponents) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Component)) break\n\n              const generatedChildren = (this.#isSr)\n                ? value.getElementsSr()\n                : value.getElements()\n\n              for (const childrenGroup of generatedChildren) {\n                this.#collectedElements[0].addElements(childrenGroup)\n              }\n            }\n          }\n          else if (allFunctions) {\n            for (const value of returnedValue) {\n              if (!(value instanceof Function)) break\n\n              // @ts-ignore\n              value(this)\n            }\n          }\n        }\n      }\n      else if (template instanceof Component) {\n        const generatedChildren = (this.#isSr)\n          ? template.useTranslations(this.#translations).getElementsSr()\n          : template.useTranslations(this.#translations).getElements()\n\n        for (const childrenGroup of generatedChildren) {\n          this.#collectedElements[0].addElements(childrenGroup)\n        }\n      }\n    }\n\n    this.#appendChildrenToContainer()\n  }\n\n  /**\n   * This method should be called in the IF or FOR loop after calling the handler.\n   *\n   * @param {object} input\n   * @param {number} input.thisLevel\n   * @param {number} input.upperLevel\n   * @returns {Node[]}\n   */\n  #afterStatement({ thisLevel, upperLevel }) {\n    // Save what will be returned, because the array will be cleared\n    const elements = this.#collectedElements[thisLevel].getElements()\n\n    // Move everything collected at this level to the upper level...\n    this.#collectedElements[upperLevel].importElements(this.#collectedElements[thisLevel])\n    this.#collectedElements[thisLevel].removeAllElements()\n\n    // ... and clean this level\n    delete this.#collectedElements[thisLevel]\n    this.#collectedElements.pop()\n\n    return elements\n  }\n\n  #appendChildrenToContainer() {\n    const containerElement = this.#containerElement\n\n    if (containerElement) {\n      appendChildrenToElement(containerElement, this.getCreatedElements())\n    }\n  }\n\n  /**\n   * @template T\n   * @param {T[]} array\n   * @returns {(string | T)[]}\n   */\n  #arrayTranslate(array) {\n    const needsTranslation = Boolean(this.#translations)\n\n    return (needsTranslation)\n      ? array.map((value) => this.#translate(value))\n      : array\n  }\n\n  /**\n   * This function first translations each part of the input array,\n   * then formats it, then translations the result.\n   *\n   * @template T\n   * @param {T[]} array\n   * The input array is supposed to be what would format() arguments be\n   * (format string plus multiple arguments), but as an array.\n   * @returns {string}\n   */\n  #arrayTranslateFormatTranslate(array) {\n    return this.#translate(\n      format.apply(\n        null,\n        // @ts-ignore\n        this.#arrayTranslate(array),\n      ),\n    )\n  }\n\n  /**\n   * Prepare the levels to be used in IF or FOR loop, and return them.\n   * This method must be called in the IF or FOR loop, before calling\n   * the handler.\n   *\n   * @returns {{thisLevel : number, upperLevel : number}}\n   */\n  #beforeStatement() {\n    // Create a new level for collecting\n    this.#collectedElements.push(new ElementsCollector())\n\n    const thisLevel = this.#collectedElements.length - 1\n    const upperLevel = thisLevel - 1\n\n    return { thisLevel, upperLevel }\n  }\n\n  /**\n   * @template T\n   * @param {ForLoopType} forLoopType\n   * @param {(T | function() : T) | State} input\n   * @param {ForLoopCallback<T>} handler\n   * @returns {Node[] | Error}\n   */\n  #forEachLoop(forLoopType, input, handler) {\n    /**\n     * @param {any} value\n     * @returns {any}\n     */\n    const beforeIterationCallback = (value) => {\n      return this.#translate(value)\n    }\n\n    if (isState(input)) {\n      /**\n       * @param {State} data\n       * @param {ElementsCollector} elementsCollector\n       * @param {string | number | symbol} [keyToRender]\n       * @returns {RenderedElementsMap}\n       */\n      const callbackForState = (data, elementsCollector, keyToRender) => {\n        /** @type {RenderedElementsMap} */\n        const renderedElementsMap = []\n\n        /**\n         * Initially there is 1 element - the forEach-begin element.\n         * We want to start after this element.\n         */\n        let index = elementsCollector.getElements().length\n\n        /**\n         * @param {number | string} key\n         */\n        function onIteration(key) {\n          const elementsFromCollector = elementsCollector.getElements()\n          const elements = (index === 0)\n            ? elementsFromCollector\n            : elementsFromCollector.slice(index)\n\n          renderedElementsMap.push({ key, elements })\n\n          index = elementsFromCollector.length\n        }\n\n        forEachLoop(forLoopType, data, handler, beforeIterationCallback, keyToRender, onIteration)\n\n        return renderedElementsMap\n      }\n\n      return this.#statementHandlerForState('forEach', input, callbackForState)\n    }\n\n    /**\n     * @param {State} data\n     */\n    const callback = (data) => {\n      forEachLoop(forLoopType, data, handler, beforeIterationCallback)\n    }\n\n    if (input instanceof Function) {\n      // @ts-ignore\n      return this.#statementHandlerForFunction('forEach', input, true, callback)\n    }\n\n    return this.#statementHandler('forEach', input, callback)\n  }\n\n  /**\n   * Quicker version for the 'html' function that does not use parsing,\n   * because the input is just a single string.\n   *\n   * @param {string} string\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForSimpleString(string) {\n    /** @type {(Element | Node)[]} */\n    let elements = []\n\n    if (this.#isSr) {\n      // We create a new dummy element every time.\n      // An element with no tag name is skipped in the render stage.\n      const element = this.#document.createElement('')\n\n      element.innerHTML = string ?? ''\n\n      elements = [element]\n    }\n    else {\n      if (\n        false\n        && 'DOMParser' in this.#window\n      ) {\n        elements = Array.from(stringToHTML(string.trim() ?? '').childNodes)\n      }\n      else {\n        if (!this.#reusableTemplateElement) {\n          this.#reusableTemplateElement = this.#document.createElement('template')\n        }\n\n        // In DOM, we can reuse the same element\n        const template = this.#reusableTemplateElement\n\n        //element.setHTML(string.trim() ?? '')\n        template.innerHTML = string.trim() ?? ''\n\n        // childNodes also contains the text nodes\n        elements = Array.from(template.content.childNodes)\n\n        template.innerHTML = ''\n      }\n    }\n\n    // Add the newly created elements into the collection\n    const level = this.#collectedElements.length - 1\n\n    this.#collectedElements[level].addElements(elements)\n\n    return elements\n  }\n\n  /**\n   * @param {string[]} strings\n   * @param {...*} keys\n   * @returns {(Element | Node)[]}\n   */\n  #htmlForTemplateLiteral(strings, ...keys) {\n    const htmlTemplateParser = new HtmlTemplateParser(strings, keys)\n\n    return htmlTemplateParser.generate(this)\n  }\n\n  /**\n   * @param {Comment} beginCommentElement\n   * @param {Node[]} elements\n   * @returns {boolean}\n   * Returns false if there is no element after which to insert the other elements,\n   * otherwise returns true\n   */\n  #insertStatementElements(beginCommentElement, elements) {\n    if (!(this.#containerElement?.contains(beginCommentElement))) {\n      return false\n    }\n\n    /** @type {Node|Comment} */\n    let lastElement = beginCommentElement\n\n    for (const newElement of elements) {\n      insertAfter(newElement, lastElement)\n\n      lastElement = newElement\n    }\n\n    return true\n  }\n\n  /**\n   * Remove all DOM elements, starting after BEGIN element and ending before END element.\n   * BEGIN and END are a pair of two comment elements, one of the following pairs:\n   * <!--IF BEGIN--> and <!--IF END-->\n   * <!--FOR BEGIN--> and <!--FOR END-->\n   *\n   * @param {Comment} beginCommentElement\n   * - The 'begin' Comment element\n   * @returns {number}\n   * - The number of deleted elements or -1 on failure\n   */\n  #removeStatementElements(beginCommentElement) {\n    /**\n     * @type {number}\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n     */\n    const COMMENT_NODE = 8 // Node.COMMENT_NODE\n\n    if (beginCommentElement.nodeType !== COMMENT_NODE) {\n      return -1\n    }\n\n    // Decide what will be the text content of the end element\n    const beginCommentElementText = beginCommentElement.textContent\n    let endElementText = ''\n\n    if (beginCommentElementText) {\n      endElementText = beginCommentElementText.slice(0, -6) + '-end'\n    }\n    else {\n      return -1\n    }\n\n    /**\n     * Delete elements between the 'begin' and 'end' element,\n     * including inner 'begin' and 'end' elements\n     */\n\n    let currentElement = beginCommentElement.nextSibling\n    let statementsCounter = 0\n    let deletedElementsCount = 0\n\n    while (true) {\n      if (currentElement === null) {\n        break\n      }\n\n      if (currentElement.nodeType === COMMENT_NODE) {\n        const text = currentElement.textContent\n\n        if (text === beginCommentElementText) { // inner 'begin' element\n          statementsCounter += 1\n        }\n        else if (text === endElementText) {\n          statementsCounter -= 1\n\n          if (statementsCounter < 0) {\n            break\n          }\n        }\n      }\n\n      const { nextSibling } = currentElement\n\n      this.#unsubscribeElementAndItsChildren(currentElement)\n\n      currentElement.remove()\n      deletedElementsCount += 1\n      currentElement = nextSibling\n    }\n\n    return deletedElementsCount\n  }\n\n  /**\n   * @param {HTMLElement | Text} element\n   * @param {Object<string, string|number|Object<*,*>|function(*):*|BindFunction|HTMLElement>} properties\n   */\n  #setPropertiesToElement(element, properties) {\n    for (let propertyName in properties) {\n      let property = properties[propertyName]\n\n      if (this.#isSr) {\n        // When the property name is an event and the property is a function, turn it into a string\n        if (isEventAttribute(propertyName) && property instanceof Function) {\n          setElementAttrOrProp(element, propertyName, property)\n\n          continue\n        }\n      }\n      else if (property instanceof Function) {\n        // If the property name is an event (for example onClick),\n        // then the property is a function. This function should not\n        // be immediately called to get a value from it. Instead, it\n        // should be added as a listener.\n        if (addEventListenerIfPossible(element, propertyName, property)) {\n          continue\n        }\n      }\n\n      // if (propertyName === 'text') propertyName = 'textContent'\n\n      if (property instanceof Function) {\n        /** @type {BindFunction} */\n        const bindFunction = property\n\n        setSuggestItems(\n          element,\n          propertyName,\n          '',\n          bindFunction,\n          null,\n        )\n\n        let value = bindFunction(element)\n\n        if (value instanceof Function) {\n          /**\n           * Remark \"() => value\"\n           *\n           * In forEach the value is provided as a function, so it is not necessary\n           * to use it like this () => value. However, when used like this, the function\n           * returns a function. Resolve the returned function here.\n           */\n          value = value()\n        }\n        else {\n          const textNode = this.#document.createTextNode((value ?? '').toString())\n          element.appendChild(textNode)\n        }\n\n        unsetSuggestedItems()\n\n        if (value instanceof Array) {\n          value = this.#arrayTranslateFormatTranslate(value)\n        }\n        else if (typeof value === 'string') {\n          value = this.#translate(value)\n        }\n\n        if (propertyName) {\n          setElementAttrOrProp(element, propertyName, value)\n        }\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'style'\n        && property instanceof Object\n      ) {\n        // @ts-ignore\n        this.#setStylesToElement(element, property)\n      }\n      else if (\n        // @ts-ignore\n        element instanceof this.#window.HTMLElement\n        && propertyName === 'data'\n      ) {\n        if (property instanceof Object) {\n          // @ts-ignore\n          setDataSetAttributesToElement(element, property)\n        }\n      }\n      else if (propertyName === 'textContent') {\n        if (property instanceof Array) {\n          element[propertyName] = this.#arrayTranslateFormatTranslate(property)\n        }\n        else {\n          element[propertyName] = this.#translate(property)\n        }\n      }\n      else {\n        if (\n          propertyName === 'innerText'\n          || (\n            propertyName === 'value'\n            && (\n              // Can't use HTMLInputElement here, because it does not exist in SrDOM\n              // @ts-ignore\n              element.tagName === 'INPUT'\n              // @ts-ignore\n              && (element.getAttribute('type') ?? '').toLowerCase() === 'button'\n            )\n          )\n        ) {\n          property = this.#translate(property)\n        }\n\n        setElementAttrOrProp(element, propertyName, property)\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} element\n   * @param {Object<keyof CSSStyleDeclaration, (string | BindFunction)>} styleRules\n   */\n  #setStylesToElement(element, styleRules) {\n    for (const ruleName in styleRules) {\n      const ruleValue = styleRules[ruleName]\n      let finalValue  = ''\n\n      if (ruleValue instanceof Function) {\n        const propertyName = 'style'\n        const bindFunction = ruleValue\n\n        setSuggestItems(\n          element,\n          propertyName,\n          ruleName,\n          bindFunction,\n          null,\n        )\n\n        finalValue = bindFunction(element)\n\n        unsetSuggestedItems()\n      }\n      else {\n        finalValue = ruleValue\n      }\n\n      if (typeof ruleName === 'string') {\n        // @ts-ignore\n        element.style[ruleName] = modifyStyleRule(ruleName, finalValue)\n      }\n    }\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach'} type\n   * @param {any} data\n   * @param {function(any): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandler(type, data, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    callback(data)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'if' | 'for' | 'forEach' | 'nest'} type\n   * @param {function(): any} bindFunction\n   * @param {boolean} autoAddCommentElements\n   * @param {function((boolean | State | Template | Component), boolean, Comment?, Comment?): void} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForFunction(type, bindFunction, autoAddCommentElements, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n    const isFunction = bindFunction instanceof Function\n\n    if (isFunction) {\n      const commentElementBegin = this.#document.createComment(`${type}-begin`)\n      const commentElementEnd   = this.#document.createComment(`${type}-end`)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementBegin)\n      }\n\n      /**\n       * @type {StatementRepaintFunctionForFunction}\n       */\n      const statementRepaintFunction = (bindFunctionResult) => {\n        if (this.#isSr) {\n          return\n        }\n\n        const level = this.#collectedElements.length - 1\n\n        // Clean all contents.\n        this.#collectedElements[level].removeAllElements()\n        this.#removeStatementElements(commentElementBegin)\n\n        // Create the new elements\n        callback(bindFunctionResult, false, null, null)\n\n        const success = this.#insertStatementElements(\n          commentElementBegin,\n          this.#collectedElements[level].getElements(),\n        )\n\n        if (!success) {\n          console.error('Element ', commentElementBegin, ' does not exist anymore')\n        }\n      }\n\n      const element = commentElementBegin\n      const propertyName = `--${type}` // --if or --for\n\n      setSuggestItems(\n        element,\n        propertyName,\n        '',\n        bindFunction,\n        statementRepaintFunction,\n      )\n\n      const resolved = bindFunction()\n\n      unsetSuggestedItems()\n\n      // Run the handler function\n      callback(resolved, true, commentElementBegin, commentElementEnd)\n\n      if (autoAddCommentElements) {\n        this.#collectedElements[thisLevel].addElement(commentElementEnd)\n      }\n    }\n    else {\n      const resolved = bindFunction\n\n      // Run the handler function\n      callback(resolved, false, null, null)\n    }\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {'forEach'} type\n   * @param {any} state\n   * @param {function(\n   *   State, ElementsCollector, (string | number | symbol)=\n   * ): RenderedElementsMap} callback\n   * @returns {Node[]}\n   */\n  #statementHandlerForState(type, state, callback) {\n    const { thisLevel, upperLevel } = this.#beforeStatement()\n\n    const commentElementBegin = this.#document.createComment(`${type}-begin`)\n    /**\n     * Use the 'end' comment element as a storage for the rendered elements.\n     * It's easier this way, and if the element is being deleted along with\n     * the rendered elements, no references to these elements remains.\n     *\n     * @type {Comment & {renderedElementsMap: RenderedElementsMap}}\n     */\n    // @ts-ignore\n    const commentElementEnd = this.#document.createComment(`${type}-end`)\n\n    this.#collectedElements[thisLevel].addElement(commentElementBegin)\n\n    /**\n     * TODO Refactor this function, because it's too long\n     *\n     * @type {StatementRepaintFunctionForState}\n     */\n    const statementRepaintFunction = (action, updatedObject, updatedState, prop) => {\n      if (!(updatedObject instanceof Object)) {\n        return\n      }\n\n      if (this.#isSr) {\n        return\n      }\n\n      /**\n       * Elements have been deleted from the state?\n       * - Remove the DOM elements not present in the updated state\n       * - Remove these same elements from .renderedElementsMap\n       */\n      if (action === EnumStateAction.DELETE) {\n        let index = commentElementEnd.renderedElementsMap.length\n\n        while (index--) {\n          const item = commentElementEnd.renderedElementsMap[index]\n\n          if (!(objectHasKey(updatedObject, item.key))) {\n            item.elements.forEach((element) => {\n              // @ts-ignore\n              element.remove()\n            })\n\n            commentElementEnd.renderedElementsMap\n              = arrayRemoveKey(commentElementEnd.renderedElementsMap, index)\n          }\n        }\n      }\n      else {\n        /**\n         * @type {Node}\n         */\n        let lastElement = commentElementBegin\n\n        // Add what is not in the updated state\n        const renderedElementsMapNew = []\n\n        const keys = (\n          updatedObject instanceof Map\n          || updatedObject instanceof Set\n          || updatedObject instanceof Array\n        )\n          ? updatedObject.keys()\n          : Object.keys(updatedObject)\n\n        for (let i of keys) {\n        // for (let i = 0, len = updatedObject.length; i< len; i++) {\n        // console.log(typeof i)\n\n          /**\n           * When Array, if an element is deleted, the key remains and the\n           * value is undefined. But also, the array iterates differently\n           * when 'of' or 'in' is used. With 'of', the deleted value is iterated,\n           * while with 'if' it's not. That's why this 'in' is here, to prevent\n           * iteration of deleted array elements.\n           */\n          if (!(i in updatedObject)) {\n            continue\n          }\n\n          let isKeyInRenderedElementsMap = false\n\n          for (const item of commentElementEnd.renderedElementsMap) {\n            if (item.key === i) {\n              const { elements } = item\n\n              lastElement = (elements.length > 0)\n                ? elements[elements.length - 1]\n                : lastElement\n              renderedElementsMapNew.push(item)\n              isKeyInRenderedElementsMap = true\n\n              break\n            }\n          }\n\n          if (!isKeyInRenderedElementsMap) {\n            let isTemporaryLevel = false\n\n            if (commentElementBegin.parentElement) {\n              // When the loop is in inner level, make a new temporary collector,\n              // which will be deleted after that. Otherwise, the new elements are\n              // placed on level 0\n              this.#collectedElements.push(new ElementsCollector())\n              isTemporaryLevel = true\n            }\n\n            const level = this.#collectedElements.length - 1\n\n            const added = callback(updatedState, this.#collectedElements[level], i)\n\n            for (const item of added) {\n              renderedElementsMapNew.push(item)\n\n              // eslint-disable-next-line @typescript-eslint/no-loop-func\n              for (const element of item.elements) {\n                if (level === 0) {\n                  /**\n                   * Parent element is needed in order to apply 'after'.\n                   * But if for example there is a for loop (for a state) at top level and\n                   * immediately after that a new element is added to the state, that new\n                   * element can't be properly added after the previous one, because of the\n                   * lack of parent element.\n                   * Because of this, let's reorder the collected elements.\n                   */\n\n                  this.#collectedElements[level].moveElementAfterAnother(element, lastElement)\n                }\n\n                // @ts-ignore\n                lastElement.after(element)\n                lastElement = element\n              }\n            }\n\n            if (isTemporaryLevel) {\n              this.#collectedElements.pop()\n            }\n          }\n        }\n\n        commentElementEnd.renderedElementsMap = renderedElementsMapNew\n      }\n    }\n\n    const propertyName = `-s-${type}` // --if or --for\n    const bindFunction = () => state\n\n    setSuggestItems(\n      commentElementEnd,\n      propertyName,\n      '',\n      bindFunction,\n      statementRepaintFunction,\n    )\n\n    // In this callback the 'for' loop is called\n    commentElementEnd.renderedElementsMap = callback(\n      state,\n      this.#collectedElements[thisLevel],\n    )\n\n    unsetSuggestedItems()\n\n    this.#collectedElements[thisLevel].addElement(commentElementEnd)\n\n    return this.#afterStatement({ thisLevel, upperLevel })\n  }\n\n  /**\n   * @param {any} input\n   * @returns {string}\n   */\n  #translate(input) {\n    if (typeof input === 'string') {\n      const translated = this.#translateString(input, this.#translations)\n\n      if (typeof translated === 'string') {\n        return translated\n      }\n\n      // Use the global translation\n      const globalObject = getGlobalObject()\n\n      const globallyTranslated = this.#translateString(\n        input,\n        // @ts-ignore\n        globalObject?.paintorTranslations,\n      )\n\n      if (typeof globallyTranslated === 'string') {\n        return globallyTranslated\n      }\n    }\n\n    return input\n  }\n\n  /**\n   * @param {string} str\n   * @param {Translation[]} [translations]\n   * @returns {string | boolean}\n   */\n  #translateString(str, translations) {\n    if (translations instanceof Array && translations.length > 0) {\n      for (const translateObject of translations) {\n        if (str in translateObject) {\n          return translateObject[str]\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Recursively search in an element's child nodes for\n   * elements, who are used in state subscriptions, and\n   * unsubscribe them. Also unsubscribe the initial element.\n   *\n   * Note: This function works only on the browser!\n   *\n   * @param {Node} element\n   */\n  #unsubscribeElementAndItsChildren(element) {\n    if (Object.hasOwn(element, '--subscribed')) {\n      Object.assign(element, { '--deleted': true })\n    }\n\n    /**\n     * Unsubscribe each child element recursively.\n     *\n     * Performance Notes:\n     * - This loop is reached too often for its performance to be ignored\n     * - Used .forEach() before, but while loop is more than 30% faster\n     */\n\n    let index = element.childNodes.length\n\n    while (index--) {\n      this.#unsubscribeElementAndItsChildren(element.childNodes[index])\n    }\n  }\n}\n\n// Add methods in the prototype for each standard HTML tag\n\n/**\n * @see https://stackoverflow.com/questions/13851088/how-to-bind-function-arguments-without-binding-this\n * @param {...any} boundArgs\n * @returns {function(...[*]):*}\n * @this {any}\n */\nfunction bindArgs(...boundArgs) {\n  const targetFunction = this\n\n  /**\n   * @param {...any} args\n   * @returns {any}\n   * @this {any}\n   */\n  return function targetFunctionCaller(...args) {\n    return targetFunction.call(this, ...boundArgs, ...args)\n  }\n}\n\nconst { prototype } = ElementsCreator\n\n// prototype.createElement.bindArgs = bindArgs\nObject.assign(prototype.createElement, { bindArgs })\n\nhtmlTags.forEach((tagName) => {\n  // @ts-ignore\n  prototype[tagName] = prototype.createElement.bindArgs(tagName)\n})\n\nexport { ElementsCreator }\n","/**\n * @see https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7#gistcomment-3231272\n * @readonly\n * @enum {string[]}\n */\nexport const BOOLEAN_ATTRIBUTES = Object.freeze([\n  'async',\n  'autofocus',\n  'autoplay',\n  'checked',\n  'contenteditable',\n  'controls',\n  'default',\n  'defer',\n  'disabled',\n  'formNoValidate',\n  'frameborder',\n  'hidden',\n  'ismap',\n  'itemscope',\n  'loop',\n  'multiple',\n  'muted',\n  'nomodule',\n  'novalidate',\n  'open',\n  'readonly',\n  'required',\n  'reversed',\n  'scoped',\n  'selected',\n  'typemustmatch',\n])\n\n/**\n * List of HTML tags\n *\n * @see http://xahlee.info/js/html5_non-closing_tag.html\n * @readonly\n * @enum {string[]}\n */\nexport const SELF_CLOSING_TAGS = Object.freeze([\n  'area',\n  'base',\n  'br',\n  'col',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n  'command',\n  'keygen',\n  'menuitem',\n])\n\n/**\n * An integer that identifies what the node is.\n * It distinguishes different kind of nodes from\n * each other, such as elements, text and comments.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n * @readonly\n * @enum {number}\n */\nexport const EnumNodeTypes = Object.freeze({\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n})\n","export class DOMException extends Error {\n  /**\n   * @param {string} message\n   * @param {string} [name]\n   */\n  constructor(message, name) {\n    super(message)\n    this.name = name ?? 'DOMException'\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { paint } from './functions.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\nclass Node {\n  /** @type {Node | null} */\n  nextSibling = null\n\n  /** @type {Node | null} */\n  previousSibling = null\n\n  /** @type {string} */\n  textContent = ''\n\n  /** @type {Node[]} */\n  #childNodes = []\n\n  /**\n   * @type {string}\n   */\n  #nodeName = ''\n\n  /** @type {number} */\n  #nodeType = 1\n\n  /** @type {Node | null} */\n  #parentNode = null\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} nodeName\n   */\n  constructor(nodeType, nodeName) {\n    this.#nodeType = nodeType\n    this.#nodeName = nodeName\n  }\n\n  /**\n   * @returns {string}\n   */\n  get baseURI() {\n    return ''\n  }\n\n  /**\n   * @returns {Node[]}\n   */\n  get childNodes() {\n    return this.#childNodes\n  }\n\n  /**\n   * @returns {Node | null}\n   */\n  get firstChild() {\n    return this.#childNodes[0] ?? null\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_nodename.asp\n   * @returns {string}\n   */\n  get nodeName() {\n    return this.#nodeName\n  }\n\n  /**\n   * @returns {number}\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_parentnode.asp\n   * @returns {Node | null}\n   */\n  get parentNode() {\n    return this.#parentNode\n  }\n\n  /**\n   * Not in DOM\n   *\n   * @param {Node | null} parentNode\n   */\n  set parentNode(parentNode) {\n    this.#parentNode = parentNode\n  }\n\n  /**\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild\n   *\n   * @param {Node} aChild\n   * @throws {DOMException | TypeError}\n   */\n  appendChild(aChild) {\n    // If the parent of aChild is not a Document, DocumentFragment, or an Element.\n    if (\n      this.nodeType !== EnumNodeTypes.DOCUMENT_NODE\n      && this.nodeType !== EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n      && this.nodeType !== EnumNodeTypes.ELEMENT_NODE\n    ) {\n      throw new DOMException('This node type does not support this method.')\n    }\n\n    // If the insertion of aChild would lead to Document with more than one Element as child.\n    // (document should contain body here, which is an Element)\n    if (\n      this.nodeType === EnumNodeTypes.DOCUMENT_NODE\n    ) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': Only one element on document allowed.')\n    }\n\n    // If aChild is not a DocumentFragment, a DocumentType, an Element, or a CharacterData.\n    if (!(aChild instanceof Node)) {\n      const errorMessage = 'Failed to execute \\'appendChild\\' on \\'Node\\''\n        + ': parameter 1 is not of type \\'Node\\'.'\n\n      throw new TypeError(errorMessage)\n    }\n\n    // If the node already exists, do not append it\n    if (this.#childNodes.includes(aChild)) {\n      return\n    }\n\n    if (aChild === this) {\n      throw new DOMException('Failed to execute \\'appendChild\\' on \\'Node\\': The new child element contains the parent.')\n    }\n\n    this.#childNodes.push(aChild)\n    aChild.parentNode = this\n\n    // Set nextSibling and previousSibling\n    const prevKey = this.#childNodes.length - 2\n\n    if (prevKey >= 0) {\n      this.#childNodes[prevKey].nextSibling = aChild\n      aChild.previousSibling = this.#childNodes[prevKey] ?? null\n    }\n  }\n\n  /**\n   * TODO Make this function do whatever it has to do\n   *\n   * @returns {boolean}\n   */\n  contains() {\n    return false\n  }\n\n  /**\n   * TODO Check whether this function works correctly\n   *\n   * @param {Node} newElement\n   * @param {Node} referenceElement\n   * @returns {Node}\n   */\n  insertBefore(newElement, referenceElement) {\n    /** @type {Node[]} */\n    const newChildren = []\n\n    for (const child of this.#childNodes) {\n      if (child === referenceElement) {\n        newChildren.push(newElement)\n      }\n\n      newChildren.push(child)\n    }\n\n    this.#childNodes = newChildren\n\n    return newElement\n  }\n\n  /**\n   * Removes a child node and returns the removed node.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild\n   * @param {Node} childNode\n   * @returns {Node}\n   */\n  removeChild(childNode) {\n    if (!childNode) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'parameter 1 is not of type \\'HTMLElement\\'.',\n      )\n    }\n\n    if (!this.#childNodes.includes(childNode)) {\n      throw new Error(\n        'Failed to execute \\'removeChild\\' on \\'HTMLElement\\': ' +\n        'The node to be removed is not a child of this node.',\n      )\n    }\n\n    this.#childNodes = this.#childNodes.filter((node) => node !== childNode)\n\n    return childNode\n  }\n\n  /**\n   * @param {object} htmlOptions\n   * @param {string} [htmlOptions.indent='']\n   * @returns {string}\n   */\n  paintChildren({ indent = '' }) {\n    // Paint the children\n    let children = ''\n    let childNumber = 0\n\n    for (const child of this.childNodes) {\n      childNumber += 1\n\n      // The first child will not be marked as a child, so no \\n will be put before it\n      const isChild = childNumber > 1\n\n      children += paint(child, indent, '', isChild)\n    }\n\n    return children\n  }\n}\n\nexport { Node }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Comment extends Node {\n  constructor() {\n    super(EnumNodeTypes.COMMENT_NODE, '#comment')\n  }\n}\n\nexport default Comment\n\nexport { Comment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass Text extends Node {\n  constructor() {\n    super(EnumNodeTypes.TEXT_NODE, '#text')\n  }\n}\n\nexport { Text }\n","import { Comment } from './Comment.js'\nimport { BOOLEAN_ATTRIBUTES, SELF_CLOSING_TAGS } from './constants.js'\nimport { HTMLElement } from './HTMLElement.js'\nimport { Text } from './Text.js'\nimport { Node } from './Node.js'\n\n/**\n * @param {number} count\n * @param {string} [chars='\\t']\n * @returns {string}\n */\nfunction generateIndents(count, chars = '\\t') {\n  let output = ''\n\n  for (let i = 0; i < count; i++) {\n    output += chars\n  }\n\n  return output\n}\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * @param {SrAttr[]} attributes\n * @returns {string}\n */\nfunction generateAttributesString(attributes) {\n  let output = ''\n\n  for (const attribute of attributes) {\n    const { name } = attribute\n    let { value } = attribute\n\n    if (BOOLEAN_ATTRIBUTES.includes(name)) {\n      // Boolean Attributes in the browser are only false when they don't exist as attributes\n      // Only few values can cause this to happen in the browser, like 0, false, undefined or null.\n      if (\n        value !== false\n        && value !== 0\n        && value !== undefined\n        && value !== null\n      ) {\n        output += ` ${name}`\n      }\n    }\n    else {\n      // Fix the value\n      if (value instanceof Array) value = value.join(',')\n      else if (value === true) value = 'true'\n      else if (value === false) value = 'false'\n      else if (value === undefined) value = 'undefined'\n      else if (value === null) value = 'null'\n      else if (value instanceof Function) value = `return(${value.toString()}).call(this,window.event)`\n      else value = value.toString()\n\n      value = value.replace(/\\\"/g, '\\\\\"')\n      value = escapeHTML(value)\n\n      output += ` ${name}=\"${value}\"`\n    }\n  }\n\n  return output\n}\n\n/**\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringFromCamelCase(str) {\n  let output = ''\n\n  output = str.replace(/([A-Z])/g, (all, char) => `-${char.toLowerCase()}`)\n\n  return output\n}\n\n/**\n * @param {StylesObject} input\n * @returns {string}\n */\nfunction getStyleStringFromObject(input) {\n  let style = ''\n\n  for (const key in input) {\n    const value = input[key]\n\n    style += `${formatStringFromCamelCase(key)}:${value};`\n  }\n\n  return style.trim()\n}\n\n/**\n * @param {Node} node\n * @param {string} indentWith\n * @param {string} indentCurrent\n * @param {boolean} isChild If true, a new row is put in the beginning\n * @returns {string}\n */\nfunction paint(node, indentWith, indentCurrent, isChild = false) {\n  let output = ''\n  let indent = ''\n  let newRow = ''\n\n  if (indentWith) {\n    indent = indentCurrent\n    newRow = '\\n'\n  }\n\n  if (node instanceof Comment) {\n    output += `${newRow}${indent}<!--${node.textContent}-->`\n  }\n  else if (node instanceof Text) {\n    output += `${newRow}${indent}${node.textContent}`\n  }\n  else if (node instanceof HTMLElement) {\n    const selfClosingTag = (SELF_CLOSING_TAGS.includes(node.tagName))\n    const attributes = generateAttributesString(node.attributes)\n\n    let style = ''\n\n    if (Object.keys(node.style).length > 0) {\n      style = ` style=\"${getStyleStringFromObject(node.style)}\"`\n    }\n\n    // Paint the opening tag (including attributes)\n    if (isChild) output += newRow // Don't prepend with \\n the very first element\n\n    output += indent\n\n    // Paint the opening tag\n    if (node.tagName) {\n      output += `<${node.tagName.toLowerCase()}${attributes}${style}`\n      output += (selfClosingTag) ? '' : '>'\n    }\n\n    // Paint the text in the element\n    output += node.textContent\n\n    // Paint the children\n    let children = ''\n\n    for (const child of node.childNodes) {\n      children += paint(child, indentWith, indentCurrent + indentWith, true)\n    }\n\n    if (children) {\n      output += children + newRow + indent\n    }\n\n    // Paint the closing tag\n    if (\n      node.tagName !== ''\n    ) {\n      output += (selfClosingTag) ? '/>' : `</${node.tagName.toLowerCase()}>`\n    }\n  }\n\n  return output\n}\n\nexport { paint, escapeHTML }\n","import { EnumNodeTypes } from './constants.js'\nimport { escapeHTML } from './functions.js'\nimport { Node } from './Node.js'\n\nexport class Element extends Node {\n  /** @type {SrAttr[]} */\n  #attributes = []\n\n  /** @type {string} */\n  #tagName = ''\n\n  /**\n   * @param {EnumNodeTypes} nodeType\n   * @param {string} tagName\n   */\n  constructor(nodeType, tagName) {\n    super(nodeType, tagName.toUpperCase())\n\n    this.#tagName = tagName.toUpperCase()\n  }\n\n  /**\n   * @returns {SrAttr[]}\n   */\n  get attributes() {\n    return this.#attributes\n  }\n\n  /**\n   * Includes only Element nodes\n   *\n   * @returns {Element[]}\n   */\n  get children() {\n    // @ts-ignore\n    return this.childNodes.filter((node) => node instanceof Element)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_classname.asp\n   * @returns {string}\n   */\n  get className() {\n    let className = ''\n\n    for (const attribute of this.#attributes) {\n      if (attribute.name === 'class') {\n        className = attribute.value\n        break\n      }\n    }\n\n    return className\n  }\n\n  /**\n   * @param {string} className\n   */\n  set className(className) {\n    this.setAttribute('class', className)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_innerhtml.asp\n   * @returns {string}\n   */\n  get innerHTML() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerHTML(text) {\n    this.textContent = text\n  }\n\n  /**\n   * @returns {string}\n   */\n  get tagName() {\n    return this.#tagName\n  }\n\n  /**\n   * This method is used to add an element in form of a Node object\n   * or a DOMString (basically means text).\n   *\n   * @param {Node | string} childElement\n   */\n  append(childElement) {\n    if (childElement instanceof Node) {\n      this.appendChild(childElement)\n    }\n    else {\n      this.textContent = escapeHTML(childElement.toString())\n    }\n  }\n\n  /**\n   * @param {string} attributeName\n   * @returns {string | null}\n   */\n  getAttribute(attributeName) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return null\n    }\n\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      return null\n    }\n    else {\n      return this.#attributes[index].value\n    }\n  }\n\n  /**\n   * Removes the element from the children list of its parent.\n   *\n   * @returns {void}\n   */\n  remove() {\n    this.parentNode?.removeChild(this)\n  }\n\n  /**\n   * In Chrome there are the following rules:\n   * - Attributes are painted in the order of their definition\n   * - If an attribute is redefined, the last value is painted\n   * - If an attribute is redefined, its place in the order is where the initial definition is\n   * - Name: If the attribute has no name, it's not painted\n   * - Name: Attribute names are lower case\n   * - Value: If boolean type, this is converted to string - \"true\" or \"false\"\n   * - Value: If undefined or null, it is converted to empty string\n   * - Value: If Array, the value is all values separated with commas\n   * - Value: If Object, the value is [object Object]\n   * - Value: If Boolean Attribute (hidden, disabled...), it doesn't have value\n   *\n   * @see https://www.w3schools.com/jsref/met_element_setattribute.asp\n   * @param {string} attributeName\n   * @param {*} attributeValue\n   */\n  setAttribute(attributeName, attributeValue) {\n    let name = ''\n\n    // Fix the name\n    name = attributeName.trim().toLowerCase()\n\n    if (!name) {\n      return\n    }\n\n    // Fix the value\n    // Nope, the value is not fixed here. Instead, the actual value is preserved here.\n    // It's fixed later on the paining stage, because a special care is needed\n    // for Boolean Attributes\n\n    // Set\n    const value = attributeValue\n    const index = this.#attributes.findIndex((attribute) => attribute.name === name)\n\n    if (index === -1) {\n      this.#attributes.push({ name, value })\n    }\n    else {\n      this.#attributes[index] = { name, value }\n    }\n  }\n}\n","import { EnumNodeTypes } from './constants.js'\nimport { Element } from './Element.js'\n\n/**\n * @param {string} html\n * @returns {string}\n */\nfunction escapeHTML(html) {\n  let text = html\n\n  // Remove white space between tags\n  // text = text.replace(/>\\s+</, '><')\n\n  /** @type {Object<string, string>} */\n  const charsToReplace = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n\n  text = text.replace(/[&<>\"]/g, (tag) => {\n    let output = tag\n\n    if (tag in charsToReplace) {\n      output = charsToReplace[tag]\n    }\n\n    return output\n  })\n\n  return text\n}\n\n/**\n * Turn something like 'background-color' into 'backgroundColor'\n *\n * @param {string} str\n * @returns {string}\n */\nfunction formatStringToCamelCase(str) {\n  const split = str.split('-')\n\n  if (split.length === 1) return split[0]\n\n  return (\n    split[0]\n    + split.slice(1)\n        .map((word) => word[0].toUpperCase() + word.slice(1))\n        .join('')\n  )\n}\n\n/**\n * @param {string} str\n * @returns {StylesObject}\n */\nfunction getStyleObjectFromString(str) {\n  /** @type {StylesObject} */\n  const style = {}\n\n  str.split(';').forEach((el) => {\n    const [property, value] = el.split(':')\n\n    if (!property) return\n\n    const formattedProperty = formatStringToCamelCase(property.trim())\n\n    style[formattedProperty] = value.trim()\n  })\n\n  return style\n}\n\n/**\n * Similar to a DOM element in the browser, but the result is HTML code.\n */\nclass HTMLElement extends Element {\n  /** @type {StylesObject} */\n  #style = {}\n\n  /**\n   * @param {string} tagName\n   */\n  constructor(tagName) {\n    super(EnumNodeTypes.ELEMENT_NODE, tagName)\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_node_innertext.asp\n   * @returns {string}\n   */\n  get innerText() {\n    return this.textContent\n  }\n\n  /**\n   * @param {string} text\n   */\n  set innerText(text) {\n    this.textContent = escapeHTML(text.toString())\n  }\n\n  /**\n   * @see https://www.w3schools.com/jsref/prop_html_style.asp\n   * @returns {StylesObject}\n   */\n  get style() {\n    return this.#style\n  }\n\n  /**\n   * @param {string | StylesObject} input\n   */\n  set style(input) {\n    // In the browser there are few ways to set the style:\n    // - By setting each individual property (.style.color = red)\n    // - By setting '.style.cssText' to a string (.style.cssText = 'color:red')\n    // - By setting '.style' itself to a string (.style = 'color:red')\n\n    if (typeof input === 'string') {\n      const style = getStyleObjectFromString(input)\n\n      for (const key in style) {\n        this.#style[key] = style[key].toString()\n      }\n    }\n  }\n}\n\nexport { HTMLElement }\n","import { EnumNodeTypes } from './constants.js'\nimport { Node } from './Node.js'\n\nclass DocumentFragment extends Node {\n  constructor() {\n    super(EnumNodeTypes.DOCUMENT_FRAGMENT_NODE, '#document-fragment')\n  }\n}\n\nexport { DocumentFragment }\n","import { EnumNodeTypes } from './constants.js'\nimport { Comment, DocumentFragment, HTMLElement, Element, Node, Text } from './orderedExports.js'\n\n/**\n * Similar to 'document' in the browser, but used to create virtual elements\n * that end up generating HTML string instead of DOM elements.\n */\nclass Document extends Node {\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ELEMENT_NODE = EnumNodeTypes.ELEMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  ATTRIBUTE_NODE = EnumNodeTypes.ATTRIBUTE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  TEXT_NODE = EnumNodeTypes.TEXT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  CDATA_SECTION_NODE = EnumNodeTypes.CDATA_SECTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  PROCESSING_INSTRUCTION_NODE = EnumNodeTypes.PROCESSING_INSTRUCTION_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  COMMENT_NODE = EnumNodeTypes.COMMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_NODE = EnumNodeTypes.DOCUMENT_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_TYPE_NODE = EnumNodeTypes.DOCUMENT_TYPE_NODE\n\n  /**\n   * @type { number }\n   * @readonly\n   */\n  DOCUMENT_FRAGMENT_NODE = EnumNodeTypes.DOCUMENT_FRAGMENT_NODE\n\n  /** @type {HTMLElement} */\n  #body\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @type {Element[]}\n   */\n  #children = []\n\n  constructor() {\n    super(/* DOCUMENT_NODE */ 9, '#document')\n\n    const html = new HTMLElement('html')\n    const head = new HTMLElement('head')\n    const body = new HTMLElement('body')\n\n    html.appendChild(head)\n    html.appendChild(body)\n\n    this.#children.push(html)\n\n    this.#body = body\n  }\n\n  /**\n   * @returns {HTMLElement}\n   */\n  get body() {\n    return this.#body\n  }\n\n  /**\n   * For HTML documents, this is usually only the root <html> element.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/children\n   * @returns {Element[]}\n   */\n  get children() {\n    return this.#children\n  }\n\n  /**\n   * @returns {null}\n   */\n  get parentElement() {\n    return null\n  }\n\n  /**\n   * @returns {DocumentFragment}\n   */\n  createDocumentFragment() {\n    return new DocumentFragment()\n  }\n\n  /**\n   * @param {string} [text]\n   * @returns {Comment}\n   */\n  createComment(text = '') {\n    const element = new Comment()\n\n    element.textContent = text\n\n    return element\n  }\n\n  /**\n   * @param {string} tagName\n   * @returns {HTMLElement}\n   */\n  createElement(tagName) {\n    return new HTMLElement(tagName)\n  }\n\n  /**\n   * @param {string} text\n   * @returns {Text}\n   */\n  createTextNode(text) {\n    const element = new Text()\n\n    element.textContent = text\n\n    return element\n  }\n\n  // /**\n  //  * @param {boolean} [prettyPrint]\n  //  * @returns {string}\n  //  */\n  // paint(prettyPrint = true) {\n  //   const tabsCount = (prettyPrint) ? 0 : -1\n  //\n  //   return this.body.paint(tabsCount)\n  // }\n}\n\nexport { Document, HTMLElement }\n","import { Comment, Document, DocumentFragment, Element, HTMLElement, Node, Text } from './orderedExports.js'\nimport { DOMException } from './exceptions/DOMException.js'\n\n/**\n * String-Rendering DOM\n */\nclass Window {\n  /** @type {typeof Comment} */\n  Comment = Comment\n\n  /** @type {typeof DocumentFragment} */\n  DocumentFragment = DocumentFragment\n\n  /** @type {typeof Element} */\n  Element = Element\n\n  /** @type {typeof HTMLElement} */\n  HTMLElement = HTMLElement\n\n  /** @type {typeof Node} */\n  Node = Node\n\n  /** @type {typeof Text} */\n  Text = Text\n\n  /** @type {typeof DOMException} */\n  DOMException = DOMException\n\n  /** @type {typeof Error} */\n  Error = Error\n\n  /** @type {typeof TypeError} */\n  TypeError = TypeError\n\n  /** @type {Document} */\n  document\n\n  constructor() {\n    this.document = new Document()\n  }\n}\n\nexport { Window }\n","import { ElementsCreator } from './ElementsCreator.js'\nimport {\n  isBrowserEnvironment,\n  isValidCustomElementName,\n  selectorEndsWithId,\n} from './functions.js'\nimport { Window as SrWindow } from './SrDOM/Window.js'\nimport { state } from './state.js'\n\nconst isBrowserEnv = isBrowserEnvironment()\nconst srWindow = new SrWindow()\n\nclass Component {\n  state = null\n\n  /**\n   * The main element in which to append all the contents\n   *\n   * @type {HTMLElement[] | HTMLCollection}\n   */\n  #containerDOMElements = []\n\n  /** @type {Node[][]} */\n  #finalElements = []\n\n  /**\n   * In server mode this will hold the final WebApi code\n   *\n   * @type {string}\n   */\n  #finalHtmlCode = ''\n\n  /** @type {boolean} */\n  #isStatic = false\n\n  /** @type {boolean} */\n  #renderCustomElements = false\n\n  /** @type {string} */\n  #selector = ''\n\n  /** @type {string} */\n  #selectorNonId = ''\n\n  /** @type {Map<Translation | null, string>} */\n  #staticHtmlCodes = new Map()\n\n  /** @type {(Template | Component)[]} */\n  #templates = []\n\n  /** @type {Translation[]} */\n  #translations = []\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElements() {\n    this.#render(null, window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * @returns {Node[][]}\n   */\n  getElementsSr() {\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true)\n\n    return this.#finalElements\n  }\n\n  /**\n   * Renders the components into an HTML code and returns it\n   *\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  html(options) {\n    if (this.#isStatic) {\n      return this.staticHtml(options)\n    }\n\n    const window = this.#getSrWindow()\n\n    this.#render('', window, true, options)\n\n    return this.#finalHtmlCode\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection} container\n   * @returns {void}\n   */\n  paint(container) {\n    if (!isBrowserEnv) {\n      throw new Error('You can only use this function in browser environment')\n    }\n\n    if (!container) {\n      throw new Error('No container selected.')\n    }\n\n    if (\n      typeof container !== 'string'\n      && !(container instanceof HTMLElement)\n      && !(container instanceof NodeList)\n      && !(container instanceof Array)\n      && !(container instanceof HTMLCollection)\n    ) {\n      throw new Error(\n        'Wrong type for the container element. '\n        + 'Expected <string> or <Node>, '\n        + `got <${typeof container}>`,\n      )\n    }\n\n    this.#render(container, window, true)\n  }\n\n  /**\n   * @param {boolean} [on=true]\n   * @returns {Component}\n   */\n  static(on = true) {\n    this.#isStatic = on\n\n    return this\n  }\n\n  /**\n   * @param {object} [options]\n   * @param {string} [options.indent='']\n   * @returns {string}\n   */\n  staticHtml(options) {\n    const key = this.#translations[0] ?? null\n\n    if (!this.#staticHtmlCodes.has(key)) {\n      const window = this.#getSrWindow()\n\n      this.#render('', window, true, options)\n      this.#staticHtmlCodes.set(\n        key,\n        this.#finalHtmlCode,\n      )\n    }\n\n    return this.#staticHtmlCodes.get(key) ?? ''\n  }\n\n  /**\n   * @param {TemplateTree} tree\n   * @returns {void\n   *   | string\n   *   | HTMLElement | HTMLElement[]\n   *   | Component | Component[]\n   *   | Template | Template[]\n   * }\n   */\n  template(tree) {\n  }\n\n  /**\n   * @param {...(Template | Template[] | Component | Component[])} from\n   * @returns {Component}\n   */\n  useTemplates(...from) {\n    if (from instanceof Array) {\n      for (const item of from) {\n        if (item instanceof Array) {\n          for (const template of item) {\n            this.#templates.push(template)\n          }\n        }\n        else {\n          this.#templates.push(item)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * @param {...Translation} translations\n   * @returns {Component}\n   */\n  useTranslations(...translations) {\n    // Reset translations here, because the whole api chain (containing this function)\n    // can be executed multiple times, but with different translations every time.\n    // EDIT: Commented out, so that translations can be used in Components\n    // this.#translations = []\n\n    translations.map((item) => {\n      if (item instanceof Array) {\n        item.forEach((subItem) => {\n          if (!this.#translations.includes(subItem)) {\n            this.#translations = [...this.#translations, subItem]\n          }\n        })\n      }\n      else if (item instanceof Object) {\n        if (!this.#translations.includes(item)) {\n          this.#translations = [...this.#translations, item]\n        }\n      }\n    })\n\n    return this\n  }\n\n  /**\n   * Clear contents of the container element\n   */\n  #clearContainerElements() {\n    if (this.#containerDOMElements) {\n      for (const el of this.#containerDOMElements) {\n        while (el?.firstChild) {\n          el.removeChild(el.firstChild)\n        }\n      }\n    }\n  }\n\n  /**\n   * This method is for tricking TS that the string-rendering DOM's Window\n   * has the same type of the browser DOM's window\n   *\n   * @returns {Window}\n   */\n  #getSrWindow() {\n    // @ts-ignore\n    return srWindow\n  }\n\n  /**\n   * @param {string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {Translation[]} translations\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #init(container, window, translations, templates) {\n    this.#finalElements.length = 0\n    this.#finalHtmlCode = ''\n\n    this.#initContainer(container, window)\n    this.#initTranslations(translations)\n    this.#initTemplates(templates)\n\n    return true\n  }\n\n  /**\n   * @param {string | HTMLElement| HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @returns {boolean}\n   */\n  #initContainer(container, window) {\n    const isSr = window.document.baseURI === ''\n\n    if (typeof container === 'string') {\n      this.#selector = container\n      this.#renderCustomElements = false\n\n      if (isValidCustomElementName(container)) {\n        this.#renderCustomElements = true\n      }\n      else {\n        if (!selectorEndsWithId(container)) {\n          this.#selectorNonId = container\n        }\n\n        // @ts-ignore\n        this.#containerDOMElements = (isSr)\n          ? [window.document.createElement('#container')]\n          : window.document.querySelectorAll(container)\n\n        if (!this.#containerDOMElements) {\n          throw new Error(`Could not find an element by the following query: ${container}`)\n        }\n      }\n    }\n    else if (container instanceof HTMLElement) {\n      this.#containerDOMElements = [container]\n    }\n    else if (\n      container instanceof NodeList\n      || container instanceof HTMLCollection\n    ) {\n      this.#containerDOMElements = container\n    }\n    else if (container instanceof Array) {\n      for (const element of container) {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('All elements in the input array must be DOM elements')\n        }\n      }\n\n      this.#containerDOMElements = container\n    }\n\n    return true\n  }\n\n  /**\n   * @param {(Template | Component)[]} templates\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTemplates(templates) {\n    if (this.template instanceof Function) {\n      this.state = (this.state)\n        ? state(this.state)\n        : this.state\n\n      // @ts-ignore\n      this.#templates.push(this.template.bind(this))\n    }\n\n    for (let template of templates) {\n      if (\n        !(template instanceof Function)\n        && !(template instanceof Component)\n      ) {\n        throw new Error('The template must be a function')\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @param {Translation[]} translations\n   * @returns {boolean}\n   * @throws {Error}\n   */\n  #initTranslations(translations) {\n    if (!(translations instanceof Array)) {\n      throw new Error('The argument \\'translations\\' must be an Array')\n    }\n\n    this.#translations = translations\n\n    return true\n  }\n\n  /**\n   * @param { string | HTMLElement | HTMLElement[] | HTMLCollection | null} container\n   * @param {Window} window\n   * @param {boolean} clearContainers\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #render(container, window, clearContainers = true, htmlOptions = {}) {\n    this.#init(container, window, this.#translations, this.#templates)\n\n    if (clearContainers) {\n      this.#clearContainerElements()\n    }\n\n    const templates = this.#templates\n    const translations = this.#translations\n\n    if (!window) {\n      throw new Error('Missing window element')\n    }\n\n    if (this.#renderCustomElements) {\n      // Custom Elements\n\n      /**\n       * @param {Component} component\n       * @returns {CustomElementConstructor}\n       */\n      const getCustomElementConstructor = (component) => {\n        return class extends HTMLElement {\n          constructor() {\n            super()\n            this.attachShadow({ mode: 'open' })\n          }\n\n          connectedCallback() {\n            if (!this.shadowRoot) {\n              throw new Error('Missing shadow root')\n            }\n\n            component.#renderElements(window, this.shadowRoot, templates, translations, htmlOptions)\n          }\n        }\n      }\n\n      customElements.define(\n        this.#selector,\n        getCustomElementConstructor(this),\n      )\n    }\n    else {\n      // DOM or SrDOM\n\n      if (this.#selectorNonId) {\n        const domObserver = new MutationObserver((mutationList) => {\n          for (const mutation of mutationList) {\n            const addedNodes = mutation.addedNodes\n\n            for (let node of addedNodes) {\n              // we track only elements, skip other nodes (e.g. text nodes)\n              if (!(node instanceof HTMLElement)) continue\n\n              // check the inserted element for being a code snippet\n              if (node.matches(this.#selectorNonId)) {\n                this.#renderElements(window, node, templates, translations, htmlOptions)\n              }\n\n              // or maybe there's a code snippet somewhere in its subtree?\n              // for (let containerElement of node.querySelectorAll(this.#selectorNonId)) {\n              //   this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n              // }\n            }\n\n          }\n        })\n\n        domObserver.observe(\n          document.body,\n          { attributes: false, childList: true, characterData: false, subtree: true },\n        )\n      }\n\n      if (this.#containerDOMElements.length === 0) {\n        this.#renderElements(window, null, templates, translations, htmlOptions)\n      }\n      else {\n        for (const containerElement of this.#containerDOMElements) {\n          this.#renderElements(window, containerElement, templates, translations, htmlOptions)\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Window} window\n   * @param {Element | ShadowRoot | null} container\n   * @param {(Template | Component)[]} templates\n   * @param {Translation[]} translations\n   * @param {object} [htmlOptions]\n   * @param {string} [htmlOptions.indent]\n   * @throws {Error}\n   */\n  #renderElements(window, container, templates, translations, htmlOptions = {}) {\n    const creator = new ElementsCreator(\n      window, container, templates, translations,\n    )\n    creator.render()\n\n    this.#finalHtmlCode = creator.getHtmlCode(htmlOptions)\n    this.#finalElements.push(creator.getCreatedElements())\n  }\n}\n\nexport { Component }\n","import { isBrowserEnvironment } from './functions.js'\n\n/**\n * TODO make it work for server environment\n *\n * @returns {string}\n */\nconst getLocale = function () {\n  let locale = 'en'\n\n  if (isBrowserEnvironment()) {\n    const html = document.getElementById('html')\n\n    locale = html?.getAttribute('lang') ?? locale\n  }\n\n  return locale\n}\n\n/**\n * @param {string} defaultPath\n * @param {string} locale\n * @returns {Promise<Translation>}\n * @throws\n */\nconst createSingleTranslation = async function (defaultPath, locale) {\n  if (typeof defaultPath !== 'string') {\n    throw new Error('Translation path must be a string')\n  }\n\n  let translation = null\n\n  /**\n   * Matches on /path/to/filename.ext\n   * [1] /path/to/\n   * [2] filename\n   * [3] .ext\n   *\n   * @type {RegExpMatchArray | null}\n   */\n  const match = defaultPath.match(/^(.*?)([^.\\/\\\\]+)(.\\w+)$/m)\n\n  if (match === null) {\n    throw new TypeError(`Incorrect path: ${defaultPath}`)\n  }\n\n  const filePath = match[1] + locale + match[3]\n\n  try {\n    translation = (await import(/* @vite-ignore */ filePath)).default\n  }\n  catch (e) {\n    if (filePath !== defaultPath) {\n      translation = (await import(/* @vite-ignore */ defaultPath)).default\n    }\n  }\n\n  if (!(translation instanceof Object)) {\n    throw new TypeError(`Translation at ${filePath} must export an object`)\n  }\n\n  return translation\n}\n\n/**\n * @param {...string} defaultPaths\n * @returns {Promise<Translation[]>}\n * @throws\n */\nconst fetchTranslations = async function (...defaultPaths) {\n  const locale = getLocale()\n\n  const promises = []\n\n  for (let path of defaultPaths) {\n    promises.push(createSingleTranslation(path, locale))\n  }\n\n  return Promise.all(promises)\n}\n\nexport { fetchTranslations }\n","import { Component } from './Component.js'\nimport { state } from './state.js'\nimport { fetchTranslations } from './Translation.js'\nimport { symTemplateFunction } from './constants.js'\n\n/**\n * @param {...(Template | Template[] | Component | Component[])} from\n * @returns {Component}\n */\nfunction component(...from) {\n  return new Component().useTemplates(...from)\n}\n\n/**\n * Returns the input function, but marked to be used easily in Paintor\n *\n * @param {Template} from\n * @returns {Template}\n */\nfunction template(from) {\n  /**\n   * Mark the function, so it can be recognized later\n   * as a Template function\n   */\n  // @ts-ignore\n  from[symTemplateFunction] = true\n\n  return from\n}\n\nconst paintor = { component, state, template, fetchTranslations, Component }\n\nexport default paintor\nexport { paintor, component, state, template, fetchTranslations, Component }\n"],"names":["symStateId","symArrayAccess","symObjectAccess","symTemplateFunction","EnumStateAction","suggestedItems","setSuggestItems","element","propertyName","subPropertyName","bindFunction","statementRepaintFunction","unsetSuggestedItems","StateSubscriptions","#subscriptions","#state","state","stateProp","subscriptions","item","subscription","key","object","statePath","handler","#createProxyHandler","proxy","innerStatePath","#onPropCreateOrDelete","action","updatedObject","updatedState","prop","index","length","#onPropCreate","#onPropUpdate","target","receiver","value","listItem","result","modifyStyleRule","setElementAttrOrProp","#onPropDelete","fn","args","stateIdCounter","isState","getGlobalObject","format","fmt","re","replacer","match","escaped","ptn","flag","arg","out","isBrowserEnvironment","isBrowser","addChildToStack","inputChild","childrenStack","addChildrenToStack","inputChildren","child","isEventAttribute","attributeName","isWhitespace","char","isValidCustomElementName","name","selectorEndsWithId","selector","stringToBoolean","string","int","addEventListenerIfPossible","callback","eventSmallName","appendDOMChildrenToElement","children","fragment","appendVirtualChildrenToElement","appendChildrenToElement","forEachLoop","forLoopType","data","beforeIterationCallback","keyToRender","iterationCallback","isProxy","val","ret","forLoop","start","end","arrayRemoveKey","arr","el","insertAfter","newNode","existingNode","nextSibling","parentNode","setDataSetAttributesToElement","dataSet","attrOrPropName","output","objectHasKey","arrayMoveIndex","array","oldIndex","newIndex","k","ElementsCollector","elements","elementsCollector","elementToMove","referenceElement","indexOfElementToMove","indexOfReferenceElement","indexInput","indexOutput","htmlTags","HtmlTemplateParserElement","parent","attributes","SELF_CLOSING_TAGS","HtmlTemplateParser","#attrName","#attrQuote","#attrValue","#attributes","#char","#charPrevious","#data","#stage","#stageNothing","#styleAttrName","#styleAttrValue","#styles","#tagName","#tagNameClosing","#textContents","#topElement","#currentElement","strings","keys","#mergeStringsAndKeys","#rotate","elementsCreator","#generateChildren","#appendData","to","#makeNewElement","dataIndex","charIndex","#setAttribute","#setStage","stage","#stageAttrName","#setStyle","#stageTagToClose","#stageAttrOpenQuote","#stageStyleAttrName","#stageAttrValue","#stageTag","#stageTextContents","#stageStyleAttrValue","ElementsCreator","#collectedElements","#containerElement","#document","#isSr","#reusableTemplateElement","#templates","#translations","#window","window","containerElement","templates","translations","tagName","argumentID","argument","textNode","#translate","isChildrenArray","#arrayTranslateFormatTranslate","Component","generatedChildren","childrenGroup","thisLevel","upperLevel","#beforeStatement","generatedElements","#afterStatement","inlineScript","#setPropertiesToElement","#statementHandlerForFunction","isInitialRun","commentElementBegin","commentElementEnd","level","#unsubscribeElementAndItsChildren","collectedElements","indexOfFirstKnownChild","from","#statementHandler","input","#forEachLoop","htmlOptions","htmlCode","#htmlForSimpleString","#htmlForTemplateLiteral","condition","elseHandler","template","returnedValue","allComponents","allFunctions","#appendChildrenToContainer","#arrayTranslate","callbackForState","renderedElementsMap","onIteration","elementsFromCollector","#statementHandlerForState","#insertStatementElements","beginCommentElement","lastElement","newElement","#removeStatementElements","beginCommentElementText","endElementText","currentElement","statementsCounter","deletedElementsCount","text","properties","property","#setStylesToElement","styleRules","ruleName","ruleValue","finalValue","type","autoAddCommentElements","bindFunctionResult","resolved","renderedElementsMapNew","i","isKeyInRenderedElementsMap","isTemporaryLevel","added","translated","#translateString","globalObject","globallyTranslated","str","translateObject","bindArgs","boundArgs","targetFunction","prototype","BOOLEAN_ATTRIBUTES","EnumNodeTypes","DOMException","message","Node","#childNodes","#nodeName","#nodeType","#parentNode","nodeType","nodeName","aChild","errorMessage","prevKey","newChildren","childNode","node","indent","childNumber","isChild","paint","Comment","Text","escapeHTML","html","charsToReplace","tag","generateAttributesString","attribute","formatStringFromCamelCase","all","getStyleStringFromObject","style","indentWith","indentCurrent","newRow","HTMLElement","selfClosingTag","Element","className","childElement","attributeValue","formatStringToCamelCase","split","word","getStyleObjectFromString","formattedProperty","#style","Document","#body","#children","head","body","DocumentFragment","Window","isBrowserEnv","srWindow","SrWindow","#containerDOMElements","#finalElements","#finalHtmlCode","#isStatic","#renderCustomElements","#selector","#selectorNonId","#staticHtmlCodes","#render","#getSrWindow","options","container","on","tree","subItem","#clearContainerElements","#init","#initContainer","#initTranslations","#initTemplates","isSr","clearContainers","getCustomElementConstructor","component","#renderElements","mutationList","mutation","addedNodes","creator","getLocale","locale","createSingleTranslation","defaultPath","translation","filePath","__vitePreload","fetchTranslations","defaultPaths","promises","path","paintor"],"mappings":"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"}